<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh-cn" lang="zh-cn" >
<head>
<title>Time - WIKI-HIT IBM CLUB</title>
<meta name="KEYWORDS" content="首页,ALP,Address,Android,Android Newbie Guide,Android Project Development,Android Research Field,Android Third Party Lib And Tool,BoardGame,CSAPP" />
<meta http-equiv="Content-type" content="text/html; charset=UTF-8" />
<meta name="robots" content="index,follow" />
<link rel="shortcut icon" href="/favicon.ico" />
<link rel='stylesheet' type='text/css' media='print' href='../../../../skins/common/wikiprintable.css' />
<script type="text/javascript" src="../../../../skins/common/wikibits.js"></script>
<style type='text/css'>
/*/*/ /*<![CDATA[*/
@import "../../../../skins/common/wikistandard.css";
@import "../../../s/t/a/MediaWiki%7EStandard.css.html";
a.new, #quickbar a.new { color: #CC2200; }
.editsection { display: none; }
#quickbar { position: absolute; top: 4px; left: 4px; border-right: 1px solid gray; }
#article { margin-left: 152px; margin-right: 4px; }

/*]]>*/ /* */
</style>
</head>

<body bgcolor='#FFFFFF' onload=''>

<div id='content'>
<div id='topbar'>
<table border='0' cellspacing='0' width='98%'>
<tr>
<td width='152' rowspan='1'>&nbsp;</td><td class="top" align='left' valign='top'>
<a href="../../../index.html" title="首页">首页</a> |
<a href="../../../r/e/c/Special%7ERecentchanges.html" title="Special:Recentchanges">最近更改</a> |
<a href="../../../t/i/m/Time.html" title="Time">编辑本页</a> |
<a href="../../../t/i/m/Time.html" title="Time">较早版本</a><p class='subtitle'><a href="../../../t/i/m/Time.html">可打印版</a> | <a href="../../../g/e/n/WIKI-HIT_IBM_CLUB%7EGeneral_disclaimer.html" title="WIKI-HIT IBM CLUB:General disclaimer">Disclaimers</a></p>
</td>
<td class="top" valign='top' align='right' nowrap='nowrap'>Not logged in
<br /><a href="../../../u/s/e/Special%7EUserlogin.html" title="Special:Userlogin">登录</a> | <a href="../../../w/i/k/Wikipedia%7E%E5%B8%AE%E5%8A%A9.html" title="Wikipedia:帮助">帮助</a>
<br /><form name="search" class="inline" method="post" action="../../../s/e/a/Special%7ESearch.html">
<input type="text" name="search" size="19" value="" />
<input type="submit" name="go" value="进入" />&nbsp;<input type="submit" name="fulltext" value="搜索" />
</form></td></tr>
</table>
</div>

<div id='article'>
<h1 class="pagetitle">Time</h1><p class='subtitle'>Wikipedia，自由的百科全书</p>
<table id='toc' class='toc'><tr><td><div id='toctitle'><h2>目录</h2></div>
<ul>
<li class='toclevel-1'><a href="#.E7.AC.AC.E5.8D.81.E7.AB.A0_.E6.97.B6.E9.97.B4"><span class="tocnumber">1</span> <span class="toctext">第十章 时间</span></a>
<ul>
<li class='toclevel-2'><a href="#.E6.97.B6.E9.97.B4.E7.9A.84.E6.95.B0.E6.8D.AE.E7.BB.93.E6.9E.84"><span class="tocnumber">1.1</span> <span class="toctext">时间的数据结构</span></a>
<ul>
<li class='toclevel-3'><a href="#.E5.8E.9F.E5.A7.8B.E8.A1.A8.E7.A4.BA"><span class="tocnumber">1.1.1</span> <span class="toctext">原始表示</span></a></li>
<li class='toclevel-3'><a href="#.E6.AF.AB.E7.A7.92.E7.BA.A7.E7.B2.BE.E5.BA.A6"><span class="tocnumber">1.1.2</span> <span class="toctext">毫秒级精度</span></a></li>
<li class='toclevel-3'><a href="#.E7.BA.B3.E7.A7.92.E7.BA.A7.E7.B2.BE.E5.BA.A6"><span class="tocnumber">1.1.3</span> <span class="toctext">纳秒级精度</span></a></li>
<li class='toclevel-3'><a href="#.E2.80.9C.E5.88.86.E8.A7.A3.E2.80.9D.E6.97.B6.E9.97.B4"><span class="tocnumber">1.1.4</span> <span class="toctext">“分解”时间</span></a></li>
<li class='toclevel-3'><a href="#.E4.B8.80.E7.A7.8D.E8.BF.9B.E7.A8.8B.E6.97.B6.E9.97.B4.E7.B1.BB.E5.9E.8B"><span class="tocnumber">1.1.5</span> <span class="toctext">一种进程时间类型</span></a></li>
</ul>
</li>
<li class='toclevel-2'><a href="#POSIX.E6.97.B6.E9.92.9F"><span class="tocnumber">1.2</span> <span class="toctext">POSIX时钟</span></a></li>
<li class='toclevel-2'><a href="#.E6.97.B6.E9.97.B4.E6.BA.90.E7.B2.BE.E5.BA.A6"><span class="tocnumber">1.3</span> <span class="toctext">时间源精度</span></a></li>
<li class='toclevel-2'><a href="#.E5.8F.96.E5.BE.97.E4.BB.8A.E6.97.A5.E7.9A.84.E5.BD.93.E5.89.8D.E6.97.B6.E9.97.B4"><span class="tocnumber">1.4</span> <span class="toctext">取得今日的当前时间</span></a>
<ul>
<li class='toclevel-3'><a href="#.E4.B8.80.E4.B8.AA.E6.9B.B4.E5.A5.BD.E7.9A.84.E6.8E.A5.E5.8F.A3"><span class="tocnumber">1.4.1</span> <span class="toctext">一个更好的接口</span></a></li>
<li class='toclevel-3'><a href="#.E4.B8.80.E4.B8.AA.E9.AB.98.E7.BA.A7.E6.8E.A5.E5.8F.A3"><span class="tocnumber">1.4.2</span> <span class="toctext">一个高级接口</span></a></li>
<li class='toclevel-3'><a href="#.E5.8F.96.E5.BE.97.E8.BF.9B.E7.A8.8B.E6.97.B6.E9.97.B4"><span class="tocnumber">1.4.3</span> <span class="toctext">取得进程时间</span></a></li>
</ul>
</li>
<li class='toclevel-2'><a href="#.E8.AE.BE.E7.BD.AE.E4.B8.80.E5.A4.A9.E7.9A.84.E5.BD.93.E5.89.8D.E6.97.B6.E9.97.B4"><span class="tocnumber">1.5</span> <span class="toctext">设置一天的当前时间</span></a>
<ul>
<li class='toclevel-3'><a href="#.E9.AB.98.E7.B2.BE.E5.BA.A6.E5.AE.9A.E6.97.B6"><span class="tocnumber">1.5.1</span> <span class="toctext">高精度定时</span></a></li>
<li class='toclevel-3'><a href="#.E8.AE.BE.E7.BD.AE.E6.97.B6.E9.97.B4.E7.9A.84.E4.B8.80.E4.B8.AA.E9.AB.98.E7.BA.A7.E6.8E.A5.E5.8F.A3"><span class="tocnumber">1.5.2</span> <span class="toctext">设置时间的一个高级接口</span></a></li>
</ul>
</li>
<li class='toclevel-2'><a href="#.E7.8E.A9.E8.BD.AC.E6.97.B6.E9.97.B4"><span class="tocnumber">1.6</span> <span class="toctext">玩转时间</span></a></li>
<li class='toclevel-2'><a href="#.E8.B0.83.E6.A0.A1.E7.B3.BB.E7.BB.9F.E6.97.B6.E9.92.9F"><span class="tocnumber">1.7</span> <span class="toctext">调校系统时钟</span></a></li>
<li class='toclevel-2'><a href="#.E7.9D.A1.E7.9C.A0.E5.92.8C.E7.AD.89.E5.BE.85"><span class="tocnumber">1.8</span> <span class="toctext">睡眠和等待</span></a>
<ul>
<li class='toclevel-3'><a href="#.E5.BE.AE.E7.A7.92.E7.BA.A7.E7.B2.BE.E5.BA.A6.E7.9D.A1.E7.9C.A0"><span class="tocnumber">1.8.1</span> <span class="toctext">微秒级精度睡眠</span></a></li>
<li class='toclevel-3'><a href="#.E7.BA.B3.E7.A7.92.E7.BA.A7.E7.B2.BE.E5.BA.A6.E7.9D.A1.E7.9C.A0"><span class="tocnumber">1.8.2</span> <span class="toctext">纳秒级精度睡眠</span></a></li>
<li class='toclevel-3'><a href="#.E5.AE.9E.E7.8E.B0.E7.9D.A1.E7.9C.A0.E7.9A.84.E9.AB.98.E7.BA.A7.E6.96.B9.E6.B3.95"><span class="tocnumber">1.8.3</span> <span class="toctext">实现睡眠的高级方法</span></a></li>
<li class='toclevel-3'><a href="#sleep.E7.9A.84.E4.B8.80.E7.A7.8D.E5.8F.AF.E7.A7.BB.E6.A4.8D.E5.AE.9E.E7.8E.B0"><span class="tocnumber">1.8.4</span> <span class="toctext">sleep的一种可移植实现</span></a></li>
<li class='toclevel-3'><a href="#.E8.B6.85.E9.99.90"><span class="tocnumber">1.8.5</span> <span class="toctext">超限</span></a></li>
<li class='toclevel-3'><a href="#.E6.9B.BF.E4.BB.A3.E7.9D.A1.E7.9C.A0"><span class="tocnumber">1.8.6</span> <span class="toctext">替代睡眠</span></a></li>
</ul>
</li>
<li class='toclevel-2'><a href="#.E8.AE.A1.E6.97.B6.E5.99.A8"><span class="tocnumber">1.9</span> <span class="toctext">计时器</span></a>
<ul>
<li class='toclevel-3'><a href="#.E7.AE.80.E5.8D.95.E7.9A.84.E9.97.B9.E9.92.9F"><span class="tocnumber">1.9.1</span> <span class="toctext">简单的闹钟</span></a></li>
<li class='toclevel-3'><a href="#.E9.97.B4.E6.AD.87.E8.AE.A1.E6.97.B6.E5.99.A8"><span class="tocnumber">1.9.2</span> <span class="toctext">间歇计时器</span></a></li>
<li class='toclevel-3'><a href="#.E9.AB.98.E7.BA.A7.E8.AE.A1.E6.97.B6.E5.99.A8"><span class="tocnumber">1.9.3</span> <span class="toctext">高级计时器</span></a>
<ul>
<li class='toclevel-4'><a href="#.E5.BB.BA.E7.AB.8B.E4.B8.80.E4.B8.AA.E8.AE.A1.E6.97.B6.E5.99.A8"><span class="tocnumber">1.9.3.1</span> <span class="toctext">建立一个计时器</span></a></li>
<li class='toclevel-4'><a href="#.E8.AE.BE.E7.BD.AE.E8.AE.A1.E6.97.B6.E5.99.A8"><span class="tocnumber">1.9.3.2</span> <span class="toctext">设置计时器</span></a></li>
<li class='toclevel-4'><a href="#.E5.8F.96.E5.BE.97.E8.AE.A1.E6.97.B6.E5.99.A8.E7.9A.84.E8.BF.87.E6.9C.9F.E6.97.B6.E9.97.B4"><span class="tocnumber">1.9.3.3</span> <span class="toctext">取得计时器的过期时间</span></a></li>
<li class='toclevel-4'><a href="#.E5.8F.96.E5.BE.97.E8.AE.A1.E6.97.B6.E5.99.A8.E7.9A.84.E8.B6.85.E9.99.90.E5.80.BC"><span class="tocnumber">1.9.3.4</span> <span class="toctext">取得计时器的超限值</span></a></li>
<li class='toclevel-4'><a href="#.E5.88.A0.E9.99.A4.E8.AE.A1.E6.97.B6.E5.99.A8"><span class="tocnumber">1.9.3.5</span> <span class="toctext">删除计时器</span></a></li>
</ul>
</li>
</ul>
</li>
<li class='toclevel-2'><a href="#.E5.8E.9F.E6.B3.A8.EF.BC.9A"><span class="tocnumber">1.10</span> <span class="toctext">原注：</span></a></li>
</ul>
</li>
</ul>
</td></tr></table>
<p><script type="text/javascript"> if (window.showTocToggle) { var tocShowText = "显示"; var tocHideText = "隐藏"; showTocToggle(); } </script>
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../t/i/m/Time.html" title="Time">编辑</a>]</div><a name=".E7.AC.AC.E5.8D.81.E7.AB.A0_.E6.97.B6.E9.97.B4"></a><h1>第十章 时间</h1>
<p>时间服务于现代操作系统方方面面，许多程序都需要追踪它。内核从三个角度来度量时间：
</p><p>Wall time（或真实时间）
</p><p>这是真实世界中的实际时间和日期——就是说，是墙上挂钟的时间。进程在与用户交互以及为事件标记时间戳时使用真实时间。
</p><p>进程时间
</p><p>即进程消耗的时间，包括用户空间代码直接使用的时间和在内核在该进程上消耗的时间。进程通常在对程序进行剖析和统计时使用它(例如，来衡量一个操作耗时多少)。因为Linux是多任务的，真实时间会在衡量进程行为时起误导作用，一个操作的进程时间可能比实际时间少许多。进程也会消耗掉相当多个时钟周期去等待I/O（尤其是键盘输入）。
</p><p>单调时间
</p><p>这个时间源是严格的线性增长的。包括Linux在内的大多数操作系统，使用计算机的正常运行时间（从启动时开始计时）。实际时间可能会发生变化(例如用户可以进行设定或系统会由于误差不断调校这个时间),也会引入某些不精确性，例如闰秒。系统正常运行时间，从另一方面来说，是一种确定的不可改变的时间表示方法。单调时间源的重要性不在于当前值，而是可以保证时间源线性增长，并利用该特性来计算两次时间采样的差值。
</p><p>因而单调时间适合来计算相对时间，而真实时间对于衡量绝对时间更为理想。
</p><p>这三种时间测量方法可以用以下两种形式来表现：
</p><p>相对时间
</p><p>这是某个基准时间的相对值，像current instant：举个例子，从现在起5秒钟，或者10分钟之前。
</p><p>绝对时间
</p><p>表示不含任何基准的时间，例如1968年3月25日中午。
</p><p>相对和绝对两种时间形式都是有用的。一个进程可能需要在500毫秒内取消一个请求，每秒刷新60次屏幕，或者记录某操作开始后已经过去了7秒。所有这些都需计算相对时间。反过来，一个日历应用可能要保存用户聚会日期为2月8日，一个文件系统将在某个文件创建时写入完整的日期和时间（而不是“5秒前”这样的相对时间），用户的时钟显示公历日期，不是自系统启动后的相对时间。
</p><p>Unix系统使用从大纪元——定义为1970年1月1日00:00:00——以来经过的秒数来表示绝对时间。UTC（协调世界时）差不多就是GMT（格林尼治标准时间）或祖鲁时间。有意思的是，这意味着在Unix中即便是绝对时间本身，从低层实现来讲也是相对的。Unix引入了一种特殊日期形式来存储“自从大纪元以来的时间，”，我们将在下一节探讨。
</p><p>软件时钟由内核维护的时钟，操作系统通过软件时钟来追踪时间进程。内核初始化一个遵循特定频率的周期计时器，一般被称为系统计时器(system timer)。当一个计时器间隔结束时，内核将消耗时间值增加一个单位，记做一个tick 或者 jiffy。记录jiffly数量的计数器被称作jiffy计数器(jiffies counter)。jiffy以前是32位值，在2.6 Linux内核后则使用64位值进行计数。#
</p><p>在Linux中，因为预处理中使用HZ来表示系统计时器频率，所以系统计时器平率被称为HZ。HZ的值是与体系结构有关，并且不是Linux ABI的一部分——就是说，程序不能依赖于任何给定值。历史上，x86架构定义该值为100，表示系统计时器每秒钟运行100次（就是说系统计时器的频率是100HZ）。这就使每个jiffy的值为0.01秒——1/HZ秒。在2.6 Linux内核中，内核开发者把HZ的值一下子提升到1000，使得每个jiffy的值变成0.001秒。然而，在2.6.13和之后的版本中，HZ是250，每个滴答值为0.004秒。† 在HZ的值的选择上需要加以权衡：较高的值能提供较高的精度，但带来了更大的计时器开销。
</p><p>尽管进程不应依赖于任何确定的HZ值，POSIX定义了一种在运行时确定系统计时器频率的机制：
</p>
<pre>long hz;

hz = sysconf (_SC_CLK_TCK);
if (hz == -1)
	perror ("sysconf"); /* should never occur */
</pre>
<p>当一个程序想要确定系统时钟频率的时候，这个函数很有有帮助，但将系统时间转换到秒就没有必要了，因为大多数POSIX函数输出的时间测量结果已经被转换或者设定为一个与HZ无关的确定值。与HZ不同的是，这个固定的频率是系统ABI的一部分；在x86上的值是100。以系统时钟周期数做为返回值的POSIX函数用CLOCKS_PER_SEC来表示该固定的频率。
</p><p>某些时间会导致计算机意外关闭。有时计算机甚至会被断电；然而到启动时，时间仍然正确无误。这是因为大多数计算机都有一个电池供电的硬件时钟在其关闭时存储时间和日期。当内核启动时，就从该硬件时钟来初始化当前时间。同样，当用户关闭计算机时，内核将时间写回到硬件时钟里。系统管理员可以通过hwclock命令将时钟更新为其他时间。
</p><p>管理Unix系统的时间包括几个任务，其中只有一部分是所有进程都需要关心的，其中包括设定和取得当前真实时间，计算消耗时间，睡眠一段时间，进行精确的时间测量，以及控制计时器。本章涵盖了时间相关的所有内容。我们将从Linux表示时间的数据结构开始看起。
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../t/i/m/Time.html" title="Time">编辑</a>]</div><a name=".E6.97.B6.E9.97.B4.E7.9A.84.E6.95.B0.E6.8D.AE.E7.BB.93.E6.9E.84"></a><h2>时间的数据结构</h2>
<p>随着各种Unix系统的发展，它们用多种数据结构来表示看似简单的时间概念，并在此基础上实现了各自的时间管理函数。这些数据结构可以说是花样繁多，既有简单的整型，也有多字段结构体。在我们深入函数细节之前，我们先来讨论一下这些数据结构、。
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../t/i/m/Time.html" title="Time">编辑</a>]</div><a name=".E5.8E.9F.E5.A7.8B.E8.A1.A8.E7.A4.BA"></a><h3>原始表示</h3>
<p>最简单的数据结构是time_t，定义在头文件&lt;time.h&gt;中。time_t的意图是隐晦的类型。然而，在大多数Unix系统上(包括Linux)这个类型是一个简单的C语言的长整型：
</p>
<pre>typedef long time_t;
</pre>
<p>time_t表示以秒计的从大纪元起经过的描述。知道这个，人们典型的反应是“那岂不是过不了多久就会溢出！”。实际上，会比你想的要久一些，但在大量目前仍然在使用的Unix系统中确实会出现溢出。使用32位的长整型，time_t最多能表示大纪元后2,147,483,647秒。这表示我们将会在2038年再一次遭遇千年虫！然而幸运的是，在2038年一月18日，星期一的22:14:07时，大多数系统和软件将会是64位的。
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../t/i/m/Time.html" title="Time">编辑</a>]</div><a name=".E6.AF.AB.E7.A7.92.E7.BA.A7.E7.B2.BE.E5.BA.A6"></a><h3>毫秒级精度</h3>
<p>与time_t相关的另外一个问题是一秒钟内会发生很多事情。timeval结构对time_t进行了扩展而达到了毫秒级精度。头文件&lt;sys/time.h&gt;中如下定义了这种结构:
</p>
<pre>#include &lt;sys/time.h&gt;
struct timeval {
    time_t tv_sec; /* seconds */
    suseconds_t tv_usec; /* microseconds */
};
</pre>
<p>tv_sec衡量秒数，而tv_usec衡量毫秒数。令人困惑的suseconds_t通常是一个整型的typedef。
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../t/i/m/Time.html" title="Time">编辑</a>]</div><a name=".E7.BA.B3.E7.A7.92.E7.BA.A7.E7.B2.BE.E5.BA.A6"></a><h3>纳秒级精度</h3>
<p>出于对毫秒级精度的不满，timespec结构将精度提高到了纳秒级。头文件&lt;time.h&gt;如下定义了如下结构：
</p>
<pre>#include &lt;time.h&gt;
struct timespec {
    time_t tv_sec; /* seconds */
    long tv_nsec; /* nanoseconds */
};
</pre>
<p>如果有选择，函数会更愿意采用纳秒级精度而非毫秒级。因此，引入timespec结构后，大多数时间相关的函数就采用了它，并获得了更高的精度。然而，正如我们将看到的，一个重要的函数仍然使用timeval。
</p><p>实际上，因为系统计时器没有提供纳秒级甚至毫秒级的精度，没有一个结构能够提供所声明的精度。不过，函数中尽量采用可用的高精度是较好的选择，因为这样就可以利用系统所提供的各种精度。
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../t/i/m/Time.html" title="Time">编辑</a>]</div><a name=".E2.80.9C.E5.88.86.E8.A7.A3.E2.80.9D.E6.97.B6.E9.97.B4"></a><h3>“分解”时间</h3>
<p>我们将要讨论的一些函数经常需要进行Unix时间与字符串的互转，或者构建一个字符串来表示时间。为了简化该过程，标准C提供了结构体tm，将Unix时间拆分为人们容易理解的格式。这个结构也定义在&lt;time.h&gt;中：
</p>
<pre>#include &lt;time.h&gt;
struct tm {
	int tm_sec; /* seconds */
	int tm_min; /* minutes */
	int tm_hour; /* hours */
	int tm_mday; /* the day of the month */
	int tm_mon; /* the month */
	int tm_year; /* the year */
	int tm_wday; /* the day of the week */
	int tm_yday; /* the day in the year */
	int tm_isdst; /* daylight savings time? */
#ifdef _BSD_SOURCE
	long tm_gmtoff; /* time zone's offset from GMT */
	const char *tm_zone; /* time zone abbreviation */
#endif /* _BSD_SOURCE */
};
</pre>
<p>tm结构体可以让我们更容易的理解time_t的值代表什么，比如说，314159是周日还是周六（应该是前者）。从占用空间的角度来看，这样表示日期时间显然是一个糟糕的选择，但这样却更有利于使用易于用户理解的方式进行转换。
</p><p>这些字段如下：
</p><p>tm_sec
</p><p>在分钟后的秒数。这个值通常在0到59之间，但可以使用61来表示2个闰秒。$$$
</p><p>tm_min
</p><p>小时后的分钟数。这个值在0到59之间。
</p><p>tm_hour
</p><p>午夜过后的小时数。这个值在0到23之间。
</p><p>tm_mday
</p><p>该月的日期。这个值在0到31之间。POSIX并没有指定0值；然而，Linux用它表示上个月的最后一天。
</p><p>tm_mon
</p><p>从一月以来的月数。这个值在0到11之间。
</p><p>tm_year
</p><p>从1900年以来的年数。
</p><p>tm_wday
</p><p>从周日以来的天数。这个值在0到6之间。
</p><p>tm_yday
</p><p>从一月1日以来的日期数。这个值在0到365之间。
</p><p>tm_isdst
</p><p>这个值用来表示夏令时（DST）在其他字段描述的时间是否有效。如果这个值为正，那么DST有效。如果是0，DST无效。如果是负数，DST的状态未知。
</p><p>tm_gmtoff
</p><p>以秒计的当前时区与格林尼治时间偏差值。这个字段仅仅在包含&lt;time.h&gt;之前定义了_BSD_SOURCE才会出现。
</p><p>tm_zone
</p><p>当前时区的缩写——像，EST。这个字段仅仅在包含&lt;time.h&gt;之前定义了_BSD_SOURCE才会出现。
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../t/i/m/Time.html" title="Time">编辑</a>]</div><a name=".E4.B8.80.E7.A7.8D.E8.BF.9B.E7.A8.8B.E6.97.B6.E9.97.B4.E7.B1.BB.E5.9E.8B"></a><h3>一种进程时间类型</h3>
<p>clock_t类型表示时钟"滴答“数。这是个整数类型，通常是长整型。对于不同函数，clock_t表示系统实际计时器频率（HZ）或者CLOCKS_PER_SEC。
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../t/i/m/Time.html" title="Time">编辑</a>]</div><a name="POSIX.E6.97.B6.E9.92.9F"></a><h2>POSIX时钟</h2>
<p>本章讨论的一些系统调用使用了POSIX时钟，它是一种实现和表示时间源的标准。clockid_t类型表示了特定的POSIX时钟，Linux支持其中四种：
</p><p>CLOCK_MONOTONIC
</p><p>一个不可被任何进程设置的单调增长的时钟。它表示自某个非特定起始点以来流逝的时间，例如从系统启动开始。
</p><p>CLOCK_PROCESS_CPUTIME_ID
</p><p>一个处理器提供给每个进程的高精度时钟。例如，在i386架构上，这个时钟采用时间戳计数（TSC）寄存器。
</p><p>CLOCK_REALTIME
</p><p>系统级真实时间（wall time）时钟。设置该时钟需要特殊权限。
</p><p>CLOCK_THREAD_CPUTIME_ID
</p><p>和每个进程的时钟类似，但是是线程独有的。
</p><p>POSIX定义了所有四个时间源，但只需要CLOCK_REALTIME。因而，虽然Linux提供了所有四个时钟，但可移植的代码应该仅仅使用CLOCK_REALTIME。
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../t/i/m/Time.html" title="Time">编辑</a>]</div><a name=".E6.97.B6.E9.97.B4.E6.BA.90.E7.B2.BE.E5.BA.A6"></a><h2>时间源精度</h2>
<p>POSIX定义了clock_getres()函数来取得给定时间源的精度。
</p>
<pre>#include &lt;time.h&gt;
int clock_getres (clockid_t clock_id,
               struct timespec *res);
</pre>
<p>成功调用clock_getres()会将clock_id指定的时钟精度存储到res中，如果结果不是NULL，就返回0。失败时，函数返回-1，并设置errno为以下两个错误码&gt;之一：
</p><p>EFAULT
</p><p>	res是一个非法的指针。
</p><p>EINVAL
</p><p>	clock_id在该系统上不是一个可用的时间源。
</p><p>以下的示例代码将输出先前讨论的四种时间源的精度：
</p>
<pre>clockid_t clocks[] = {
	CLOCK_REALTIME,
	CLOCK_MONOTONIC,
	CLOCK_PROCESS_CPUTIME_ID,
	CLOCK_THREAD_CPUTIME_ID,
	(clockid_t) -1 };
int i;

for (i = 0; clocks[i]&nbsp;!= (clockid_t) -1; i++) {
	struct timespec res;
	int ret;

	ret = clock_getres (clocks[i], &amp;res);
	if (ret)
		perror ("clock_getres");
	else
		printf ("clock=%d sec=%ld nsec=%ld\n",
	clocks[i], res.tv_sec, res.tv_nsec);
}
</pre>
<p>在现代x86系统上，输出大致类似于下面的样子：
</p>
<pre>clock=0 sec=0 nsec=4000250
clock=1 sec=0 nsec=4000250
clock=2 sec=0 nsec=1
clock=3 sec=0 nsec=1
</pre>
<p>注意到4,000,250纳秒是4毫秒，也就是0.004秒。反过来，0.004秒也是给定HZ值为250的x86系统时钟的精度(这正是我们在本章第一节所讨论的)。这样，我们看到CLOCK_REALTIME和CLOCK_MONOTONIC二者都和jiffy数以及系统计时器所提供的精度有关。相反的，CLOCK_PROCESS_CPUTIME_ID和CLOCK_THREAD_CPUTIME_ID则使用了一种更高精度的时间源——在同一台x86机器上，就是TSC，它能提供纳秒级精度。
</p><p>在Linux上（还有大多数其他Unix系统），所有使用POSIX时钟的函数都需要将目标文件与librt链接。举例来说，如果想把刚才的片断编译成完整的可执行程序，
你可能会用到以下的命令：
</p>
<pre>$ gcc -Wall -W -O2 -lrt -g -o snippet snippet.c
</pre>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../t/i/m/Time.html" title="Time">编辑</a>]</div><a name=".E5.8F.96.E5.BE.97.E4.BB.8A.E6.97.A5.E7.9A.84.E5.BD.93.E5.89.8D.E6.97.B6.E9.97.B4"></a><h2>取得今日的当前时间</h2>
<p>应用程序出于以下几个目的来获取当前日期和时间：显示给用户，计算相对时间或者流逝的时间，给事件标记时间戳等等。最简单也是最常用的获取当前时间的方法是通过time()函数：
</p>
<pre>       #include &lt;time.h&gt;

       time_t time (time_t *t);
</pre>
<p>time()调用返回当前时间，以自从大纪元以来用秒计的的流逝的时间来表示。如果参数t非NULL，该函数也将当前时间写入到提供的指针中。
</p><p>错误时，函数返回-1（类型转换到一个time_t），并且设置errno为相应的值。
</p><p>举个例子：
</p>
<pre>       time_t t;

       printf("current time: %ld\n", (long) time (&amp;t));
       printf("the same value: %ld\n". (long) t);
</pre>
<p><br />
</p>
<pre>               一个简陋的计时方法
time_t表示的“自从大纪元以来流逝的秒数”并不是真正的从那刻起经过的秒数。Unix的计算方法假定了所有能被四整除的年份都是闰年，并且忽略了所有的闰秒。time_t的表示法并不精确，但却始终这样处理。
</pre>
<p><br />
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../t/i/m/Time.html" title="Time">编辑</a>]</div><a name=".E4.B8.80.E4.B8.AA.E6.9B.B4.E5.A5.BD.E7.9A.84.E6.8E.A5.E5.8F.A3"></a><h3>一个更好的接口</h3>
<p>gettimeofday()函数拓展了time()，在其基础上提供了微秒精度支持：
</p>
<pre>#include &lt;sys/time.h&gt;

int gettimeofday (struct timeval *tv,
		struct timezone *tz);
</pre>
<p>成功调用gettimeofday()将当前时间放到由tv指向的timeval结构中，并返回0。timezone结构和tz参数已经老掉牙了；都不该在Linux中使用。一般传递NULL给tz。
</p><p>失败时，调用返回-1，并设置errno为EFAULT；这是唯一可能的错误，表示tv或者tz不是合法指针。
</p><p>看个例子：
</p>
<pre>struct timeval tv;
int ret;

ret = gettimeofday (&amp;tv, NULL);
if (ret)
	perror ("gettimeofday");
else
	printf ("seconds=%ld useconds=%ld\n",
		(long) tv.sec, (long) tv.usec);
</pre>
<p>timezone结构已经过时，因为内核不再管理时区，而且glibc不能使用timezone结构的tz_dstime字段。我们将在下一节研究如何操作时区。
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../t/i/m/Time.html" title="Time">编辑</a>]</div><a name=".E4.B8.80.E4.B8.AA.E9.AB.98.E7.BA.A7.E6.8E.A5.E5.8F.A3"></a><h3>一个高级接口</h3>
<p>POSIX提供了clock_gettime()来取得一个指定时间源的时间。然而更有用的是，该函数可以达到纳秒级精度。
</p>
<pre>#include &lt;time.h&gt;

int clock_gettime (clockid_t clock_id,
		    struct timespec *ts);
</pre>
<p>成功时，调用返回0，并将clock_id指定的时间源的当前时间存储到ts中。失败时，调用返回-1，并设置errno为下列值之一：
</p><p>EFAULT
</p><p>ts不是合法指针。
</p><p>EINVAL
</p><p>clock_id在该系统上不是合法时间源。
</p><p>下面的例子从所有四种标准时间源中取得当前时间：
</p>
<pre>clockid_t clocks[] = {
	CLOCK_REALTIME,
	CLOCK_MONOTONIC,
	CLOCK_PROCESS_CPUTIME_ID,
	CLOCK_THREAD_CPUTIME_ID,
	(clockid_t) -1 };
int i;

for (i = 0; clocks[i]&nbsp;!= (clockid_t) -1; i++) {
	struct timespec ts;
	int ret;
	
	ret = clock_gettime (clocks[i], &amp;ts);
	if (ret)
		perror ("clock_gettime");
	else
		printf ("clock=%d sec=%ld nsec=%ld\n",
	clocks[i], ts.tv_sec, ts.tv_nsec);
}
</pre>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../t/i/m/Time.html" title="Time">编辑</a>]</div><a name=".E5.8F.96.E5.BE.97.E8.BF.9B.E7.A8.8B.E6.97.B6.E9.97.B4"></a><h3>取得进程时间</h3>
<p>times()系统调用取得正在运行的进程及其子进程的进程时间，进程时间以时钟报时信号表示。
</p>
<pre>#include &lt;sys/times.h&gt;

struct tms {
	clock_t tms_utime; /* user time consumed */
	clock_t tms_stime; /* system time consumed */
	clock_t tms_cutime; /* user time consumed by children */
	clock_t tms_cstime; /* system time consumed by children */
};

clock_t times (struct tms *buf);
</pre>
<p>成功时，调用将发起进程及其子进程消耗的进程时间写入到buf所指的tms结构中。统计的时间分成用户和系统时间。用户时间是在用户空间执行代码所用的时间。系统时间是在内核空间执行所用的时间(例如进行系统调用或者发生一个页错误所消耗的时间)。每个子进程的耗时统计只在该子进程已经终结，且父进程对其调用了waitpid()（或者相关函数）之后才被包含进来。调用返回时钟报时信号数，并从过去的某个参考点单调递增。过去曾以系统时间时间做为参考点(就是说，times()函数返回系统开机来的时间，以时钟报时信号数进行计算),目前的参考点是以系统启动前大约四亿两千九百万秒。内核开发者之所以这样做是为了捕获那些无法处理系统启动瞬间发生问题的内核代码。这个函数返回的绝对值是没什么用的；而两次调用的相对时间，则仍然有意义。$$$
</p><p>失败时，调用返回-1，并设置errno。在Linux上，唯一可能的错误码是EFAULT，表示buf不是合法指针。
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../t/i/m/Time.html" title="Time">编辑</a>]</div><a name=".E8.AE.BE.E7.BD.AE.E4.B8.80.E5.A4.A9.E7.9A.84.E5.BD.93.E5.89.8D.E6.97.B6.E9.97.B4"></a><h2>设置一天的当前时间</h2>
<p>前面的章节讨论了如何获取时间，应用程序偶尔也会需要将当前时间日期设置为一个给定值。大多数系统都会提供一个独立的工具(例如date命令)来解决这个问题。
</p><p>在时间设置中，与time()相对的是stime()：
</p>
<pre>#define _SVID_SOURCE
#include &lt;time.h&gt;

int stime (time_t *t);
</pre>
<p>成功调用stime()会设置系统时间为t所指向的值并返回0。调用需要发起者拥有CAP_SYS_TIME权限。一般的，只有root用户才有该权限。
</p><p>失败时，调用返回-1，并设置errno为EFAULT，表示t不是合法指针，或者EPERM，表示发起者没有CAP_SYS_TIME权限。
</p><p>用法相当简单：
</p>
<pre>time_t t = 1;
int ret;

/* set time to one second after the epoch */
ret = stime (&amp;t);
if (ret)
	perror ("stime");
</pre>
<p>我们将在接下来一节看看将我们所习惯的时间格式方便的转换成time_t类型。
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../t/i/m/Time.html" title="Time">编辑</a>]</div><a name=".E9.AB.98.E7.B2.BE.E5.BA.A6.E5.AE.9A.E6.97.B6"></a><h3>高精度定时</h3>
<p>与gettimeofday()对应的是settimeofday()：
</p>
<pre>#include &lt;sys/time.h&gt;

int settimeofday (const struct timeval *tv ,
const struct timezone *tz);
</pre>
<p>成功调用settimeofday()将系统时间设定为tv给出的值并返回0。和gettimeofday()一样，让tz传递NULL是不错的选择。失败时，调用返回-1，并将errno设置为下列值之一：
</p><p>EFAULT
</p><p>tv或者tz在内存非法区域。
</p><p>EINVAL
</p><p>提供的结构体中某个字段非法。
</p><p>EPERM
</p><p>调用进程没有CAP_SYS_TIME权限。
</p><p>下面的例子将当前时间设置为1979年十二月中的一个周六。
</p>
<pre>struct timeval tv = { .tv_sec = 31415926,
			.tv_usec = 27182818 };
int ret;

ret = settimeofday (&amp;tv, NULL);
if (ret)
	perror ("settimeofday");
</pre>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../t/i/m/Time.html" title="Time">编辑</a>]</div><a name=".E8.AE.BE.E7.BD.AE.E6.97.B6.E9.97.B4.E7.9A.84.E4.B8.80.E4.B8.AA.E9.AB.98.E7.BA.A7.E6.8E.A5.E5.8F.A3"></a><h3>设置时间的一个高级接口</h3>
<p>就像clock_gettime()改进了gettimeofday()一样，clock_settime()让settimeofday()过时了：
</p>
<pre>#include &lt;time.h&gt;

int clock_settime (clockid_t clock_id,
const struct timespec *ts);
</pre>
<p>成功调用，返回0，而clock_id指定的时间源被设置为ts指定的时间。失败时，调用返回-1，并设置errno为下列值之一：
</p><p>EFAULT
</p><p>ts不是一个合法指针。
</p><p>EINVAL
</p><p>clock_id在该系统上不是合法时间源。
</p><p>EPERM
</p><p>进程没有设定该时间源的相关权限，或则该时间源不能被设置。
</p><p>在大多数系统上，唯一可以设置的时间源是CLOCK_REALTIME。因此，这个函数比settimeofday()唯一优越之处在于提供了纳秒级精度（还有不用处理无聊的timezone结构体）。
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../t/i/m/Time.html" title="Time">编辑</a>]</div><a name=".E7.8E.A9.E8.BD.AC.E6.97.B6.E9.97.B4"></a><h2>玩转时间</h2>
<p>Unix系统和C语言提供了一系列函数来提供时间（这里的时间是被分解，并用表ASCII字符串表示的时间）和time_t之间的转换。asctime()将tm结构体（分解的时间)转换成一个ASCII字符串：
</p>
<pre>#include &lt;time.h&gt;

char * asctime (const struct tm *tm);
char * asctime_r (const struct tm *tm, char *buf);
</pre>
<p>它返回一个指向静态分配的字符串的指针。之后对任何时间函数的调用都可能覆盖该字符串；asctime()不是线程安全的。
</p><p>这样，多线程程序（以及讨厌这种糟糕设计的开发者）应该使用asctime_r()。该函数不使用静态分配字符串的指针，而使用buf提供的，至少有26个字符长度的字符串。
</p><p>两个函数在错误时都返回NULL。
</p><p>mktime()也转换tm结构体，但是转换为一个time_t。
</p>
<pre>#include &lt;time.h&gt;

time_t mktime (struct tm *tm);
</pre>
<p>mktime()也通过tzset()将时区设置为tm指定的值。错误时返回-1（类型转换到一个time_t）。
</p><p>ctime()将一个time_t转换为ASCII表示：
</p>
<pre>#include &lt;time.h&gt;

char * ctime (const time_t *timep);
char * ctime_r (const time_t *timep, char *buf);
</pre>
<p>失败时，返回NULL。举例来说：
</p>
<pre>time_t t = time (NULL);

printf ("the time a mere line ago: %s", ctime (&amp;t));
</pre>
<p>需要注意的是没有新行出现。可能有些不方便，但ctime()还是在其返回字符串后追加了一个空行。
</p><p>像asctime()，ctime()返回一个静态字符串的指针。由于这样不是线程安全的，基于线程的程序应该用ctime_r()来替代她，该函数在buf所指向的缓冲区上工作。缓冲区最少应有26个字符长度。
</p><p>gmtime()将给出的time_t转换到tm结构体，用UTC时区格式表示：
</p>
<pre>#include &lt;time.h&gt;

struct tm * gmtime (const time_t *timep);
struct tm * gmtime_r (const time_t *timep, struct tm *0result);
</pre>
<p>失败时，返回NULL。
</p><p>这个函数静态的分配返回结构体，因此也不是线程安全的。基于线程的程序应使用gmtime_r()，该函数在result指向的结构体上完成操作。
</p><p>localtime()和localtime_r()函数则分别类似于gmtime()和gmtime_r()，但他们将给出的time_t表示为用户时区:
</p>
<pre>#include &lt;time.h&gt;

struct tm * localtime (const time_t *timep);
struct tm * localtime_r (const time_t *timep, struct tm *result);
</pre>
<p>像mktime()那样，localtime()的调用也会调用tzset()，并初始化时区。localtime_r()是否执行此步骤，则并未指明。
</p><p>difftime()返回两个time_t值的差值，并转换到双精度浮点类型来表示相差的秒数。
</p>
<pre>#include &lt;time.h&gt;

double difftime (time_t time1, time_t time0);
</pre>
<p>在所有POSIX系统上，time_t是一个算术类型，而difftime()等价于以下值，且不进行减法溢出的检测：
</p>
<pre>(double) (time1 - time0)
</pre>
<p>在Linux上，由于time_t是一个整型，没有必要将其转换成双精度浮点。然而为了保持可移植性，最好使用difftime()。
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../t/i/m/Time.html" title="Time">编辑</a>]</div><a name=".E8.B0.83.E6.A0.A1.E7.B3.BB.E7.BB.9F.E6.97.B6.E9.92.9F"></a><h2>调校系统时钟</h2>
<p>真实时间的突然变化会对哪些操作依赖于绝对时间的应用造成严重破坏。考虑一个make(make是根据Makefile的内容来构建软件项目的程序)的例子。每次执行该程序并不重建整个源代码树；如果这样处理，对于大型软件项目，一个文件的小改动可能会花费数个小时进行重新编译。make一半是比对源文件（比如，wolf.c）和目标文件（wolf.o）的改变的时间戳。如果源文件——或者它的任何依赖文件，像wolf.h——比目标文件新，make会将源文件编译成一个更新的目标文件。然而如果源文件不比目标文件新，则不做处理。
</p><p>了解这些基本知识后，考虑下如果用户知道了他的时钟比正确时间晚了几个小时，并运行了date来更新系统时间后会发生什么事情。如果用户接下来更新并再次存储了wolf.c，我们就可能有麻烦了。如果用户把当前时间向前调整，wolf.c可能会比wolf.o要旧(即使并非如此！),并不会进行重建。
</p><p>为了防止这样的问题发生，Unix提供了adjtime()函数，用户可以以指定的增量逐渐的调整时间。这样做是为了让类似网络时间协议守护进程（NTP）一类的一后台程序可以逐渐的调整时间的差值，用adjtime()来最小化它们对系统的影响：
</p>
<pre>#define _BSD_SOURCE
#include &lt;sys/time.h&gt;

int adjtime (const struct timeval *delta,
		struct timeval *olddelta);
</pre>
<p>成功调用djtime()，指示内核使用增量delta来逐渐调整时间，然后返回0。如果delta指定的时间是正值，内核将加速系统时钟直到修正彻底完成。如果delta指定时间是负值，内核将减缓系统时钟直到修正完成。内核进行的所有改动都保证时钟单调递增并且不会有突然的跳变。即使是delta为负值，调整仍然不会回拨时钟；而是调慢时钟直到系统时间达到正确的时间。
</p><p>如果delta不是NULL，内核停止处理所有之前注册的改动。对于已经完成的改动，内核将继续保留。如果olddelta不是NULL，所有先前注册但未完成的改动将写入timeval结构体。delta设置为NULL，并将olddelta设置为一个合法值将可以获得所有正在进行的改动。
</p><p>adjtime()所进行的改动应该不大——理想的例子是之前提到的NTP,每次只改动几秒。Linux可以做的最小修改和最大修改阈值均有几千秒。
</p><p>错误时，adjtime()返回-1，并设置errno为下列值之一：
</p><p>EFAULT
</p><p>delta或olddelta不是合法指针。
</p><p>EINVAL
</p><p>delta指定的调整过大或者过小。
</p><p>EPERM
</p><p>发起调用的用户没有CAP_SYS_TIME权限。
</p><p><a href='http://www.ietf.org/rfc/rfc1305.txt' class='external' title="http://www.ietf.org/rfc/rfc1305.txt">RFC 1305</a>定义了一个比adjtime()采用的渐进调整方法更加强大和更加复杂的时钟调整算法。Linux用adjtimex()系统调用实现了该算法。
</p>
<pre>#include &lt;sys/timex.h&gt;

int adjtimex (struct timex *adj);
</pre>
<p>调用adjtimex()可以将内核中与时间相关的参数读取到adj指向的timex结构体中。系统调用可以选择性的根据该结构体的modes字段来额外设置某些参数。
</p><p>在头文件&lt;sys/time.h&gt;中定义了timex结构体：
</p>
<pre>struct timex {
	int modes; /* mode selector */
	long offset; /* time offset (usec) */
	long freq; /* frequency offset (scaled ppm) */
	long maxerror; /* maximum error (usec) */
	long esterror; /* estimated error (usec) */
	int status; /* clock status */
	constant; /* PLL time constant */
	long precision; /* clock precision (usec) */
	long tolerance; /* clock frequency tolerance (ppm) */
	struct timeval time; /* current time */
	long tick; /* usecs between clock ticks */
};
</pre>
<p>modes字段是由零或以下标志位按位或的结果：
</p><p>ADJ_OFFSET
</p><p>通过offset设置时间偏移量。
</p><p>ADJ_FREQUENCY
</p><p>通过freq设置频率偏移量。
</p><p>ADJ_MAXERROR
</p><p>通过maxerror设置最大错误值。
</p><p>ADJ_ESTERROR
</p><p>通过esterror设置估计错误值。
</p><p>ADJ_STATUS
</p><p>通过status设置时钟状态。
</p><p>ADJ_TIMECONST
</p><p>通过constant设置锁相环（PLL）时间常量。
</p><p>ADJ_TICK
</p><p>通过tick设置时钟计时信号值。
</p><p>ADJ_OFFSET_SINGLESHOT
</p><p>使用简单算法(例如adjtime)通过offset设置一次时间偏移量。
</p><p>如果modes是0，就没有设置值。只有拥有CAP_SYS_TIME权限的用户才能给modes赋非零值；任何用户均可，将取得所有参数，但不能设置任何值。
</p><p>成功时，adjtimex()返回当前时钟状态，是下列几个值之一：
</p><p>TIME_OK
</p><p>时钟被同步。
</p><p>TIME_INS
</p><p>将插入一闰秒。
</p><p>TIME_DEL
</p><p>将去除一秒。
</p><p>TIME_OOP
</p><p>恰好正在一个闰秒的进行中
</p><p>TIME_WAIT
</p><p>一闰秒刚刚出现。
</p><p>TIME_BAD
</p><p>时钟未同步。
</p><p>失败时，adjtimex()返回-1，并设置errno为下列错误码之一：
</p><p>EFAULT
</p><p>adj不是一个合法指针。
</p><p>EINVAL
</p><p>一个或更多的modes，offset或者tick非法。
</p><p>EPERM
</p><p>modes是非零值，但发起者没有CAP_SYS_TIME权限。
</p><p>adjtimex()系统调用是Linux特有的。关心可移植性的应用应该倾向于使用adjtime()。
</p><p><a href='http://www.ietf.org/rfc/rfc1305.txt' class='external' title="http://www.ietf.org/rfc/rfc1305.txt">RFC 1305</a>定义了一个复杂的算法，对adjtimex()的完整讨论超出了本书的范围。想知道更多信息，请参阅RFC。
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../t/i/m/Time.html" title="Time">编辑</a>]</div><a name=".E7.9D.A1.E7.9C.A0.E5.92.8C.E7.AD.89.E5.BE.85"></a><h2>睡眠和等待</h2>
<p>有各种各样的函数能使进程睡眠（暂停执行）一段指定时间。第一个这样的函数，sleep()，让发起进程睡眠由seconds指定的秒数。
</p>
<pre>﻿#include &lt;unistd.h&gt;

unsigned int sleep (unsigned int seconds);
</pre>
<p>该调用返回未睡眠的秒数。就是说，成功的调用返回0，但该函数可能返回介于0到包括seconds之间的值（比如说一个信号中断了睡眠）。函数不会设置errno。大多数sleep()的用户不会关心进程实际上睡眠了多久，因而接下来就不检查返回值了。
</p>
<pre>sleep (7); /* sleep seven seconds */
</pre>
<p>如果真的希望进程睡眠达到指定时间的话，你可以根据返回值来继续调用sleep()，直到返回0。
</p>
<pre>unsigned int s = 5;

/* sleep five seconds: no ifs, ands, or buts about it */
while ((s = sleep (s)))
	;
</pre>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../t/i/m/Time.html" title="Time">编辑</a>]</div><a name=".E5.BE.AE.E7.A7.92.E7.BA.A7.E7.B2.BE.E5.BA.A6.E7.9D.A1.E7.9C.A0"></a><h3>微秒级精度睡眠</h3>
<p>以整秒的粒度进行睡眠实在是太死板了。在一个现代操作系统上一秒钟简直就是永恒，所以程序经常需要在亚秒的精度下睡眠。看一下 usleep()：
</p>
<pre>/* BSD version */
#include &lt;unistd.h&gt;

void usleep (unsigned long usec);
 
/* SUSv2 version */
#define _XOPEN_SOURCE 500
#include &lt;unistd.h&gt;
 
int usleep (useconds_t usec);
</pre>
<p>成功调用usleep()可以使发起进程睡眠usec微秒。不幸的是，BSD和Single UNIX Specification（单一UNIX规范）在该函数原型定义上持不同意见。BSD版本使用一个无符号长整型，并且没有返回值。然而SUS版本定义usleep()接受一个useconds_t类型，并返回一个整型。如果XOPEN_SOURCE定义为500或者更大的值，Linux就和SUS一样。如果XOPEN_SOURCE未定义，或者设定值小于500，Linux就和BSD一样。
</p><p>SUS版本在成功时返回0，出错时返回-1。合法的errno值包括: 睡眠被信号打断时为EINTR，由于usecs太大而导致的错误为EINVAL（在Linux上，该类型的整个范围都是合法的，这样该错误就不会出现）。
</p><p>根据规范，useconds_t类型是能满足最大值为1,000,000的无符号整型。
</p><p>由于不同原型之间的冲突，以及部分Unix系统可能只支持一种，不要在你的代码中包括useconds_t类型是明智的做法。为了尽可能满足可移植性，最好假设参数是无符号整型，并且不要依赖于usleep()的返回值：
</p>
<pre>void usleep (unsigned int usec);
</pre>
<p>用法就是：
</p>
<pre>unsigned int usecs = 200;

usleep (usecs);
</pre>
<p>这样就可以满足该函数的不同形式，并且可以检测错误：
</p>
<pre>errno = 0;
usleep (1000);
if (errno)
	perror ("usleep");
</pre>
<p>但是对大多数程序来讲，它们并不检查也不关心usleep()的错误。
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../t/i/m/Time.html" title="Time">编辑</a>]</div><a name=".E7.BA.B3.E7.A7.92.E7.BA.A7.E7.B2.BE.E5.BA.A6.E7.9D.A1.E7.9C.A0"></a><h3>纳秒级精度睡眠</h3>
<p>Linux不赞成使用usleep()函数，而是提供了一个更加智能且可以提供纳秒级精度的函数-nanosleep()：
</p>
<pre>#define _POSIX_C_SOURCE 199309
#include &lt;time.h&gt;

int nanosleep (const struct timespec *req,
		struct timespec *rem);
</pre>
<p>成功调用nanosleep(),使进程睡眠req所指定的时间，并返回0。错误时，调用返回-1，并设置errno为相应值。如果一个信号打断了睡眠，调用可在指定时间消耗完之前返回。在这种情况下，nanosleep()返回-1，并设置errno为EINTR。如果rem不是NULL，函数把剩余睡眠时间（req中没有睡眠的值）放到rem中。程序随后会重新调用，将rem作参数传递给req（像本节之后所示）。
</p><p>下面是其他errno值：
</p><p>EFAULT
</p><p>req或者rem不是合法指针。
</p><p>EINVAL
</p><p>req中一个字段非法。
</p><p><br />
</p><p>在一般情况下，用法很简单：
</p><p><br />
</p>
<pre>struct timespec req = { .tv_sec = 0,
			.tv_nsec = 200 };

/* sleep for 200 ns */
ret = nanosleep (&amp;req, NULL);
if (ret)
	perror ("nanosleep");
</pre>
<p><br />
</p><p>下面是当睡眠被打断时使用第二个参数来继续的例子：
</p>
<pre>struct timespec req = { .tv_sec = 0,
			.tv_nsec = 1369 };
struct timespec rem;
int ret;
 
/* sleep for 1369 ns */
retry:
ret = nanosleep (&amp;req, &amp;rem);
if (ret) {
	if (errno == EINTR) {
		/* retry, with the provided time remaining */
		req.tv_sec = rem.tv_sec;
		req.tv_nsec = rem.tv_nsec;
		goto retry;
	}
	perror ("nanosleep");
}
</pre>
<p>最后，下面是另外一种方法（可能更加有效，但可读性较差），可以达到同样效果：
</p>
<pre>struct timespec req = { .tv_sec = 1,
			.tv_nsec = 0 };
struct timespec rem, *a = &amp;req, *b = &amp;rem;

/* sleep for 1s */
while (nanosleep (a, b) &amp;&amp; errno == EINTR) {
 	struct timespec *tmp = a;
 	a = b;
	b = tmp;
}
</pre>
<p>nanosleep()相对于sleep()和usleep()有几个优点：
</p><p>•提供纳秒级精度，其他两者只能提供秒或者微秒精度。
</p><p>•POSIX.1b标准。
</p><p>•不是用信号来实现（该方法的缺陷将在之后讨论）
</p><p>尽管有反对之声，很多程序仍然倾向于使用usleep()而不是nanosleep()——所幸至少越来越少的程序使用sleep()。因为nanosleep()是POSIX标准，并且不使用信号，新程序最好使用它（或者将在下一节讨论的接口）而不要用sleep()或者usleep()。
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../t/i/m/Time.html" title="Time">编辑</a>]</div><a name=".E5.AE.9E.E7.8E.B0.E7.9D.A1.E7.9C.A0.E7.9A.84.E9.AB.98.E7.BA.A7.E6.96.B9.E6.B3.95"></a><h3>实现睡眠的高级方法</h3>
<p>我们已经见识过了各种类型的时间函数。此外，POSIX还提供了一个最高级的睡眠函数：
</p>
<pre>#include &lt;time.h&gt;

int clock_nanosleep (clockid_t clock_id,
			int flags,
			const struct timespec *req,
			struct timespec *rem);
</pre>
<p>clock_nanosleep()的行为类似于nanosleep()。实际上，这个调用：
</p>
<pre>ret = nanosleep (&amp;req, &amp;rem);
</pre>
<p>等价于这个调用：
</p>
<pre>ret = clock_nanosleep (CLOCK_REALTIME, 0, &amp;req, &amp;rem);
</pre>
<p>两者的差别在于clock_id和flags参数。前者指定了用来衡量的时间源。虽然你不能指定调用进程的CPU时钟（例如CLOCK_PROCESS_CPUTIME_ID），不过大部分时间源都是合法的；这样做没有任何意义，因为调用将使进程挂起，这样进程时间将停止增长。
</p><p>时间源的选择取决于你让程序进入睡眠的目的。如果你想要睡眠到某个绝对时间值，CLOCK_REALTIME大概是最好的选择。如果你准备睡眠某个相对值的时间，CLOCK_MONITONIC绝对是理想的时间源。
</p><p>flags参数是TIMER_ABSTIME或者0。如果是TIMER_ABSTIME，req指定的是一个绝对的时间值。这样处理解决了一个潜在的竞态条件。为了解释该参数的值，可以假设一个进程处于时间T0，想要睡眠到时间T1。在T0时，进程调用了clock_gettime()来取得当前时间（T0）。然后从T1中减去T0，得到Y，传递给clock_nanosleep()。在获取时间和进程进入睡眠之间，总是需要一些时间的。然而糟糕的是，如果在这期间进程被调度失去处理器控制权或者发生一个页错误，对于此类情况，我们该如何处理？在取得当前时间，计算时间差，以及实际睡眠之间总是存在着竞争条件的。
</p><p><br />
TIMER_ABSTIME标志允许进程直接指定T1,从而避免了竞争。在指定时间源到达T1前，内核会一直挂起该进程。如果指定时间源的当前时间已经超过T1，调用立即返回。
</p><p>让我具体看一下相对睡眠和绝对睡眠。下面的例子中，进程睡眠1.5秒钟：
</p>
<pre>struct timespec ts = { .tv_sec = 1, .tv_nsec = 500000000 };
int ret;

ret = clock_nanosleep (CLOCK_MONOTONIC, 0, &amp;ts, NULL);
if (ret)
	perror ("clock_nanosleep");
</pre>
<p>相应的，下面的例子睡眠到某个绝对时间，在本例中是clock_gettime()调用返回CLOCK_MONOTONIC时间源之后精确的一秒钟。
</p>
<pre>struct timespec ts; 
int ret;

/* we want to sleep until one second from NOW */
ret = clock_gettime (CLOCK_MONOTONIC, &amp;ts);
if (ret) {
	perror ("clock_gettime");
	return;
}

ts.tv_sec += 1;
printf ("We want to sleep until sec=%ld nsec=%ld\n",
	ts.tv_sec, ts.tv_nsec);
ret = clock_nanosleep (CLOCK_MONOTONIC, TIMER_ABSTIME,
			&amp;ts, NULL);
if (ret)
	perror ("clock_nanosleep");
</pre>
<p>大多数程序只需要一个相对的睡眠，因为他们的睡眠并不十分严格。然而某些实时进程，对时间要求相当严格，需要绝对睡眠来避免产生潜在的具有破坏性的竞态条件。
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../t/i/m/Time.html" title="Time">编辑</a>]</div><a name="sleep.E7.9A.84.E4.B8.80.E7.A7.8D.E5.8F.AF.E7.A7.BB.E6.A4.8D.E5.AE.9E.E7.8E.B0"></a><h3>sleep的一种可移植实现</h3> 
<p>回忆我们在第二章中提到select()：
</p>
<pre>#include &lt;sys/select.h&gt;

int select (int n,
	     fd_set *readfds,
	     fd_set *writefds,
	     fd_set *exceptfds,
	     struct timeval *timeout);
</pre>
<p>正如当时所提到的那样，select()提供了一种实现亚秒精度、可移植睡眠的方法。在很长一段时间内，可移植的Unix程序由于sleep()无法满足短暂的睡眠需求而表现的很糟糕：usleep()并不是在各个系统上都实现的，而nanosleep()还没有编写。开发者发现给select()的n传递0，并给所有三个fd_set指针传递NULL，以及把需要睡眠的时间传给timeout，就产生了一种可移植且有效的方法让进程睡眠：
</p>
<pre>struct timeval tv = { .tv_sec = 0,
			.tv_usec = 757 };
</pre>
<pre>/* sleep for 757 us */
select (0, NULL, NULL, NULL, &amp;tv);
</pre>
<p>如果需要考虑对于较早的Unix系统的可移植性，使用select()可能是你最好的办法。
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../t/i/m/Time.html" title="Time">编辑</a>]</div><a name=".E8.B6.85.E9.99.90"></a><h3>超限</h3>
<p>本节讨论的所有接口都保证进程至少睡眠指定的时间（或者返回错误来表示其他情况）。睡眠进程不达到指定的时间绝不返回。但是存在某种可能，会使睡眠时间超过指定时间。
</p><p>这种现象可以归咎于简单的调度行为——指定的时间可能已经过去了，内核可能会及时唤醒进程，但调度器可能选择了另外一个任务运行。
</p><p>然而这里可以有一个更加隐蔽的原因：计时器超限(timer overruns)。当计时器的粒度比要求的时间间隔大时就会发生这种情况。举例来说，假设系统计时器每10毫秒产生一次报时信号，而进程要求1毫秒的睡眠。系统只能在10毫秒的精度下测量并响应时间相关的事件（例如把进程从睡眠中唤醒）。如果进程发起睡眠请求时，计时器距离下次报时信号还有1毫秒，一切都将正常——在1毫秒内，请求的时间（1毫秒）将会过去，而内核将唤醒进程。然而，如果计时器在进程请求睡眠时刚好产生报时信号，接下来的10毫秒将不会产生报时信号。那么，进程将会多睡眠9毫秒！也就是说，会有九个1毫秒的超限发生。平均来说，一个有X度量单位的计时器会有X/2的几率超限。
</p><p>使用POSIX时钟提供的高精度时间源，或者用较高的HZ值，可以减少计时器超限。
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../t/i/m/Time.html" title="Time">编辑</a>]</div><a name=".E6.9B.BF.E4.BB.A3.E7.9D.A1.E7.9C.A0"></a><h3>替代睡眠</h3>
<p>如果可能的话，你应该尽量避免使用睡眠。通常来说这很难做到，但问题也不大，特别是当你的代码的睡眠时间少于一秒钟的时候。为了等待事件而使用睡眠的代码是很糟糕的设计。在文件描述符上阻塞，允许内核来处理睡眠和唤醒进程的代码，则是比较好的。内核能够让进程从运行转到阻塞，并只在需要时唤醒它，而不是让进程为了等待事件触发而不断的循环。
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../t/i/m/Time.html" title="Time">编辑</a>]</div><a name=".E8.AE.A1.E6.97.B6.E5.99.A8"></a><h2>计时器</h2>
<p>计时器提供了在一定时间过去后通知进程的机制。计时器在到期前的时间叫做延迟（delay），或者期限（expiration）。内核通知进程计时器已经到期的方式与计时器有关。Linux内核提供了几种方式，我们随后将一一讨论。
</p><p>计时器在如下情况下非常有用:每秒刷新60次屏幕，或者当某个处理过程运行超过了500毫秒时取消它。
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../t/i/m/Time.html" title="Time">编辑</a>]</div><a name=".E7.AE.80.E5.8D.95.E7.9A.84.E9.97.B9.E9.92.9F"></a><h3>简单的闹钟</h3>
<p>alarm()是最简单的计时器接口：
</p>
<pre>#include &lt;unistd.h&gt;

unsigned int alarm (unsigned int seconds);
</pre>
<p>对该函数的调用会在真实时间(real time)seconds秒之后将SIGALRM信号发给调用进程。如果先前的信号尚未处理，调用就取消该信号，并用新的来代替它，并返回先前的剩余秒数。如果seconds是0，就取消掉之前的信号，但不设置新的闹钟。
</p><p>想要成功调用该函数，需要为SIGALRM信号注册一个信号处理程序。（信号和信号处理程序的内容在前一章已经讨论过。）下面的代码段注册了一个SIGALRM处理程序，alarm_handler()，并设置了一个五秒钟的闹钟：
</p>
<pre>void alarm_handler (int signum)
{
	printf ("Five seconds passed!\n");
}

void func (void)
{
	signal (SIGALRM, alarm_handler);
	alarm (5);

	pause ( );
}
</pre>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../t/i/m/Time.html" title="Time">编辑</a>]</div><a name=".E9.97.B4.E6.AD.87.E8.AE.A1.E6.97.B6.E5.99.A8"></a><h3>间歇计时器</h3>
<p>间歇计时器系统调用，最早出现在4.2BSD中，目前已经是POSIX标准，它可以提供比alarm()更多的控制。
</p>
<pre>#include &lt;sys/time.h&gt;

int getitimer (int which,
struct itimerval *value);

int setitimer (int which,
		const struct itimerval *value,
		struct itimerval *ovalue);
</pre>
<p>间歇计时器和alarm()的操作方式相似，但它能够自动重启自身，并在以下三个独有的模式中的一个下工作：
</p><p>ITIMER_REAL
</p><p>测量真实时间。当指定的真实时间过去后，内核将SIGALRM信号发给进程。
</p><p>ITIMER_VIRTUAL
</p><p>只在进程用户空间的代码执行时减少。当指定的进程时间过去后，内核将SIGVTALRM发给进程。
</p><p>ITIMER_PROF
</p><p>在进程执行以及内核为进程服务时（例如完成一个系统调用）都会减少。当指定的时间过去后，内核将SIGPROF信号发给进程。这个模式一般和ITIMER_VIRTUAL共用，这样程序就能衡量进程消耗的用户时间和内核时间。
</p><p>ITIMER_REAL衡量的时间和alarm()相同；另外两个模式对于剖析程序很有帮助。
</p><p>itimeval结构体允许用户在计时器过期或终止的时限，如果设定了值，则在过期后重启计时器:
</p>
<pre>struct itimerval {
	struct timeval it_interval; /* next value */
	struct timeval it_value; /* current value */
};
</pre>
<p>回忆先前可以提供微秒级精度的timeval结构体：
</p>
<pre>struct timeval {
	long tv_sec; /* seconds */
	long tv_usec; /* microseconds */
};
</pre>
<p>settimer()设置一个过期时间为it_value的计时器。一旦时长超过it_value，内核使用it_interval所指定的时长重启计时器。当it_value达到0时，时间间隔则被设置为it_interval。如果计时器失效且it_interval为0 ，则不会重启计时器。类似的，如果一个活动计时器的it_value被设置为0，则计时器停止，并且不会重启。
</p><p>如果ovalue不是NULL，则会返回which类型的间歇计时器的前一个值。
</p><p>getitimer()返回which类型的间歇计时器的当前值。
</p><p>两个函数在成功时都返回0，并在出错时返回-1，设置errno为下列值之一：
</p><p>EFAULT
</p><p>value或者ovalue不是合法指针。
</p><p>EINVAL
</p><p>which不是合法的间歇计时器类型。
</p><p>下面的代码段创建了一个SIGALRM信号处理程序（参见第九章），并将间歇计时器的过期时间设置为5秒，后续的过期时间为1秒。
</p>
<pre>void alarm_handler (int signo)
{
	printf ("Timer hit!\n");
}

void foo (void) {
	struct itimerval delay;
	int ret;

	signal (SIGALRM, alarm_handler);

	delay.it_value.tv_sec = 5;
	delay.it_value.tv_usec = 0;
	delay.it_interval.tv_sec = 1;
	delay.it_interval.tv_usec = 0;
	ret = setitimer (ITIMER_REAL, &amp;delay, NULL);
	if (ret) {
		perror ("setitimer");
		return;
	}

	pause ( );
}
</pre>
<p>一些Unix系统通过SIGALRM实现了sleep()和usleep()。很显然，alarm()和setitimer()也使用了SIGALRM。因而，程序员必须十分小心，不要重复调用这些函数。重复调用的结果是未定义的。如果只是需要短暂的等待，程序员应该使用nanosleep()，因为POSIX标准中规定nanosleep()不能使用信号。如果需要计时器，程序员应该使用setitimer()或者alarm()。
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../t/i/m/Time.html" title="Time">编辑</a>]</div><a name=".E9.AB.98.E7.BA.A7.E8.AE.A1.E6.97.B6.E5.99.A8"></a><h3>高级计时器</h3>
<p>最强大的计时器接口，毫无疑问来自于POSIX的时钟函数。
</p><p>POSIX中基于时钟的计时器，建立实例、初始化以及最终删除计时器函数分别使用三个函数：timer_create()建立计时器，timer_settime()初始化计时器，timer_delete()则销毁它。
</p><p>^^^^^^POSIX的计时器接口毫无疑问是最先进的，但也是最新的（因而可移植性最差），同时是最不易使用的。如果优先考虑简洁或者可移植性，那么setitimer()是更好的选择。
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../t/i/m/Time.html" title="Time">编辑</a>]</div><a name=".E5.BB.BA.E7.AB.8B.E4.B8.80.E4.B8.AA.E8.AE.A1.E6.97.B6.E5.99.A8"></a><h4>建立一个计时器</h4>
<p>使用timer_create()建立一个计时器：
</p>
<pre>#include &lt;signal.h&gt;
#include &lt;time.h&gt;

int timer_create (clockid_t clockid,
		   struct sigevent *evp,
		   timer_t *timerid);
</pre>
<p>成功调用timer_create()建立一个与POSIX时钟clockid相关联的新计时器，在timerid中存储一个唯一的计时器标记，并返回0。该调用很少设置计时器运行的条件；就像在下一节将要看到的那样，在启动计时器之前什么都不会发生。
</p><p>下面的例子建立了一个新的计时器来切断POSIX时钟CLOCK_PROCESS_CPUTIME_ID，并将计时器ID存储到timer中。
</p>
<pre>timer_t timer;
int ret;

ret = timer_create (CLOCK_PROCESS_CPUTIME_ID,
		     NULL,
		     &amp;timer);
if (ret)
	perror ("timer_create");
</pre>
<p>失败时，调用返回-1，timerid则未定义，调用设置errno为下列值之一：
</p><p>EAGAIN
</p><p>系统缺少足够的资源来完成请求。
</p><p>EINVAL
</p><p>clockid指定的POSIX时钟是非法的。
</p><p>ENOTSUP
</p><p>clockid指定的POSIX时钟合法，但是系统不支持使用该时钟作为计时器。POSIX保证所有实现均支持CLOCK_REALTIME时钟作为计时器。其它的时钟是否支持依赖于不同实现。
</p><p>evp参数(非NULL条件下)定义了当计时器到期时的异步通知。头文件&lt;signal.h&gt;定义了该结构体。它的内容对程序员来说是不可见的，但至少包含以下字段：
</p>
<pre>#include &lt;signal.h&gt;

struct sigevent {
	union sigval sigev_value;
	int sigev_signo;
		int sigev_notify;
	void (*sigev_notify_function)(union sigval);
	pthread_attr_t *sigev_notify_attributes;
};

union sigval {
	int sival_int;
	void *sival_ptr;
};
</pre>
<p>在基于时钟的POSIX计时器到期时，在内核在如何通知进程的问题上有更多的控制能力，它允许进程指定内核将发送的信号，甚至让内核产生一个新线程在计时器到期时完成一定的功能。进程在计时器过期时的行为通过sigev_notify来指定，必须是以下三个值之一：
</p><p>SIGEV_NONE
</p><p>一个“空的”通知。当计时器到期时，什么都不发生。
</p><p>SIGEV_SIGNAL
</p><p>当计时器到期时，内核给进程发送一个由sigev_signo指定的信号。在信号处理程序中，si_value被设置为sigev_value。
</p><p>SIGEV_THREAD
</p><p>当计时器过期时，内核产生一个新线程（在该进程内），并让其执行sigev_notify_function，将sigev_value做为它唯一的参数。该线程在这个函数返回时终止。如果sigev_notify_attributes不是NULL，pthread_attr_t结构体则定义了新线程的行为。
</p><p>就像之前的例子中看到的，如果evp不是NULL，，计时器的到期通知将做如下设置:sigev_notify为SIGEV_SIGNAL，sigev_signo为SIGALRM，sigev_value为计时器的ID。就是说，缺省情况下这些计时器以POSIX 间歇计时器的方式进行通知。然而通过自定义方式，可以做更多的工作！
</p><p>下面的例子建立了一个切断CLOCK_REALTIME的计时器。当计时器到期时，内核发出SIGUSR1信号，并把si_value设置成计时器ID中存储的地址值：
</p>
<pre>struct sigevent evp;
timer_t timer;
int ret;

evp.sigev_value.sival_ptr = &amp;timer;
evp.sigev_notify = SIGEV_SIGNAL;
evp.sigev_signo = SIGUSR1;
ret = timer_create (CLOCK_REALTIME,
		     &amp;evp,
		     &amp;timer);
if (ret)
	perror ("timer_create");
</pre>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../t/i/m/Time.html" title="Time">编辑</a>]</div><a name=".E8.AE.BE.E7.BD.AE.E8.AE.A1.E6.97.B6.E5.99.A8"></a><h4>设置计时器</h4>
<p>由timer_create()建立的计时器是未设置的。可以使用timer_settime()将其与一个过期时间关联并开始计时，：
</p>
<pre>#include &lt;time.h&gt;

int timer_settime (timer_t timerid,
		    int flags,
		    const struct itimerspec *value,
		    struct itimerspec *ovalue);
</pre>
<p>成功调用timer_settime()将设置timerid指定的计时器的过期时间为value,value为一个itimerspec结构体
</p>
<pre>struct itimerspec {
	struct timespec it_interval; /* next value */
	struct timespec it_value; /* current value */
};
</pre>
<p>像setitimer()一样，it_value指定了当前计时器过期时间。当计时器过期时，将用it_interval的值更新it_value。如果it_interval是0，计时器就不是间歇计时器，并在it_value 过期后停止运行。
</p><p>回顾一下之前提到的内容，timespec结构体可以提供纳秒级精度：
</p>
<pre>struct timespec {
	time_t tv_sec; /* seconds */
	long tv_nsec; /* nanoseconds */
};
</pre>
<p>如果flags是TIMER_ABSTIME，value指定的时间则为绝对时间（和相对于当前时间值的默认解释相反）。这个修正的操作可以避免在获取当前时间、计算相对的时间差值、确定未来时间点、以及设置计时器时产生竞争条件。详情可以参见先前一节“一个高级的睡眠方法”。
</p><p>如果ovalue不是NULL，之前计时器的过期时间将存储在itimerspec中。如果计时器之前未被设置，结构体的成员将全部设置为0。
</p><p>使用timer值来初始化timer_create()创建的计时器，下面的代码建立了一个每秒都过期的周期计时器：
</p>
<pre>struct itimerspec ts;
int ret;

ts.it_interval.tv_sec = 1;
ts.it_interval.tv_nsec = 0;
ts.it_value.tv_sec = 1;
ts.it_value.tv_nsec = 0;

ret = timer_settime (timer, 0, &amp;ts, NULL);
if (ret)
	perror ("timer_settime");
</pre>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../t/i/m/Time.html" title="Time">编辑</a>]</div><a name=".E5.8F.96.E5.BE.97.E8.AE.A1.E6.97.B6.E5.99.A8.E7.9A.84.E8.BF.87.E6.9C.9F.E6.97.B6.E9.97.B4"></a><h4>取得计时器的过期时间</h4>
<p>你可以在任何时刻使用timer_gettime()获取一个计时器的过期时间而不必重新设置它，：
</p>
<pre>#include &lt;time.h&gt;

int timer_gettime (timer_t timerid,
struct itimerspec *value);
</pre>
<p>成功调用timer_gettime()将timerid指定的计时器过期时间存储到value指向的结构体中，并返回0。失败时，调用返回-1，并设置errno为下列值之一：
</p><p>EFAULT
</p><p>value不是合法指针。
</p><p>EINVAL
</p><p>timerid不是合法计时器。
</p><p>看个例子：
</p>
<pre>struct itimerspec ts;
int ret;

ret = timer_gettime (timer, &amp;ts);
if (ret)
	perror ("timer_gettime");
else {
	printf ("current sec=%ld nsec=%ld\n",
	ts.it_value.tv_sec, ts.it_value.tv_nsec);
	printf ("next sec=%ld nsec=%ld\n",
	ts.it_interval.tv_sec, ts.it_interval.tv_nsec);
}
</pre>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../t/i/m/Time.html" title="Time">编辑</a>]</div><a name=".E5.8F.96.E5.BE.97.E8.AE.A1.E6.97.B6.E5.99.A8.E7.9A.84.E8.B6.85.E9.99.90.E5.80.BC"></a><h4>取得计时器的超限值</h4>
<p>POSIX定义了一个接口来确定一个给定计时器目前的超限值：
</p>
<pre>#include &lt;time.h&gt;

int timer_getoverrun (timer_t timerid);
</pre>
<p>成功时，timer_getoverrun()返回在计时器过期与实际计时器过期后通知(例如通过信号)进程间的多余时长。比方说，在我们先前的例子中，一个1毫秒的计时器运行了10毫秒，调用就会返回9。
</p><p>如果超限值大于等于DELAYTIMER_MAX，调用就返回DELAYTIMER_MAX。
</p><p>失败时，该函数返回-1，并设置errno为EINVAL，这个唯一的错误表明由timerid指定的计时器不合法。
</p><p>看个例子：
</p>
<pre>int ret;

ret = timer_getoverrun (timer);
if (ret == -1)
	perror ("timer_getoverrun");
else if (ret == 0)
	printf ("no overrun\n");
else
	printf ("%d overrun(s)\n", ret);
</pre>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../t/i/m/Time.html" title="Time">编辑</a>]</div><a name=".E5.88.A0.E9.99.A4.E8.AE.A1.E6.97.B6.E5.99.A8"></a><h4>删除计时器</h4>
<p>删除一个计时器很简单：
</p>
<pre>#include &lt;time.h&gt;

int timer_delete (timer_t timerid);
</pre>
<p>成功调用timer_delete()将销毁由timerid指定的计时器，并返回0。失败时，调用返回-1，并设置errno为EINVAL，这个唯一的错误表明timerid不是合法的计时器。
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../t/i/m/Time.html" title="Time">编辑</a>]</div><a name=".E5.8E.9F.E6.B3.A8.EF.BC.9A"></a><h2>原注：</h2>
<ol><li>jiffies on 2.6 Kernel： Linux内核的未来版本可能会是“无时钟报时”或者会实现“动态时钟报时”，即内核不会记录一个显式jiffy值。这样所有基于时间的内核操作将伴随动态建立的计时器执行，而不是系统计时器
</li><li>Given the choice, interfaces prefer nanosecond to microsecond resolution.     此外，timespec结构弃用了suseconds_t，转而使用了简单长整型。
</li></ol>
<p><br />
†HZ现在是内核编译期的可选项，在x86架构上值可以是100、250和1000。与此无关的是，用户空间不能依赖于任何特定的HZ值。
</p>
<div class="printfooter">
<p>取自"<a href="http://dns.cs.hit.edu.cn../../../t/i/m/Time.html">http://dns.cs.hit.edu.cn../../../t/i/m/Time.html</a>"</p>

<p>本页面已经被浏览71次。 This page was last modified 08:10 2009年4月10日 by <a href="../../../%E5%90%B4/%E6%99%8B/_/User%7E%E5%90%B4%E6%99%8B.html" title="User:吴晋">吴晋</a>. Based on work by <a href="../../../h/a/l/User%7EHalfelf.html" title="User:Halfelf">王澍</a>. </p>
</div>

</div><br style="clear:both" />

<div id='footer'><table border="0" cellspacing="0"><tr><td width='152' rowspan='1'>&nbsp;</td><td class='bottom' align='left' valign='top'><strong><a href="../../../t/i/m/Time.html" title="Time">编辑本页</a></strong> |
<a href="../../../t/i/m/Talk%7ETime.html" class="new" title="Talk:Time">讨论本页</a> |
<a href="../../../t/i/m/Time.html" title="Time">较早版本</a> |
<a href="../../../w/h/a/Special%7EWhatlinkshere.html" title="Special:Whatlinkshere">链入页面</a> |
<a href="../../../r/e/c/Special%7ERecentchangeslinked.html" title="Special:Recentchangeslinked">链出更改</a>
<br /><br />

<br /><a href="../../../index.html" title="首页">首页</a> | <a href="../../../w/i/k/Wikipedia%7E%E5%85%B3%E4%BA%8E.html" title="Wikipedia:关于">关于Wikipedia</a> | <a href="../../../r/e/c/Special%7ERecentchanges.html" title="Special:Recentchanges">最近更改</a> | <form name="search" class="inline" method="post" action="../../../s/e/a/Special%7ESearch.html">
<input type="text" name="search" size="19" value="" />
<input type="submit" name="go" value="进入" />&nbsp;<input type="submit" name="fulltext" value="搜索" />
</form><br /><span id="pagestats">本页面已经被浏览71次。 This page was last modified 08:10 2009年4月10日 by <a href="../../../%E5%90%B4/%E6%99%8B/_/User%7E%E5%90%B4%E6%99%8B.html" title="User:吴晋">吴晋</a>. Based on work by <a href="../../../h/a/l/User%7EHalfelf.html" title="User:Halfelf">王澍</a>. </span></td></tr></table>
</div>
</div>

<div id='quickbar'>
<a href='../../../index.html'><img src='../../../../skins/common/images/wiki.jpg' alt='[首页]' /></a>
<hr class='sep' /><a href="../../../index.html">首页</a>
<br /><a href="../../../c/o/m/WIKI-HIT_IBM_CLUB%7ECommunity_Portal_9150.html">社区</a>
<br /><a href="../../../c/u/r/Current_events.html">新闻动态</a>
<br /><a href="../../../r/e/c/Special%7ERecentchanges.html">最近更改</a>
<br /><a href="../../../r/a/n/Special%7ERandom.html">随机页面</a>
<br /><a href="../../../w/i/k/Wikipedia%7E%E5%B8%AE%E5%8A%A9.html">帮助</a>
<br /><a href="../../../s/i/t/WIKI-HIT_IBM_CLUB%7ESite_support.html">Donations</a>
<br />
<hr class='sep' /><strong><a href="../../../t/i/m/Time.html" title="Time">编辑本页</a></strong>
<br /><a href="../../../t/i/m/Talk%7ETime.html" class="new" title="Talk:Time">讨论本页</a>
<br /><a href="../../../t/i/m/Time.html" title="Time">较早版本</a>
<br /><a href="../../../w/h/a/Special%7EWhatlinkshere.html" title="Special:Whatlinkshere">链入页面</a>
<br /><a href="../../../r/e/c/Special%7ERecentchangeslinked.html" title="Special:Recentchangeslinked">链出更改</a>
<br /><hr class='sep' /><a href="../../../s/p/e/Special%7ESpecialpages.html" title="Special:Specialpages">特殊页面</a>
<br /><a href="../../../w/i/k/Wikipedia%7E%E9%94%99%E8%AF%AF%E6%8A%A5%E5%91%8A.html" title="Wikipedia:错误报告">错误报告</a>
<br /></div>
<!-- Served by dns.cs.hit.edu.cn in 1351393322.17 secs. -->
</body></html>