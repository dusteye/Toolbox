<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh-cn" lang="zh-cn" >
<head>
<title>王澍版 - WIKI-HIT IBM CLUB</title>
<meta name="KEYWORDS" content="首页,ALP,Address,Android,Android Newbie Guide,Android Project Development,Android Research Field,Android Third Party Lib And Tool,BoardGame,CSAPP" />
<meta http-equiv="Content-type" content="text/html; charset=UTF-8" />
<meta name="robots" content="index,follow" />
<link rel="shortcut icon" href="/favicon.ico" />
<link rel='stylesheet' type='text/css' media='print' href='../../../../skins/common/wikiprintable.css' />
<script type="text/javascript" src="../../../../skins/common/wikibits.js"></script>
<style type='text/css'>
/*/*/ /*<![CDATA[*/
@import "../../../../skins/common/wikistandard.css";
@import "../../../s/t/a/MediaWiki%7EStandard.css.html";
a.new, #quickbar a.new { color: #CC2200; }
.editsection { display: none; }
#quickbar { position: absolute; top: 4px; left: 4px; border-right: 1px solid gray; }
#article { margin-left: 152px; margin-right: 4px; }

/*]]>*/ /* */
</style>
</head>

<body bgcolor='#FFFFFF' onload=''>

<div id='content'>
<div id='topbar'>
<table border='0' cellspacing='0' width='98%'>
<tr>
<td width='152' rowspan='1'>&nbsp;</td><td class="top" align='left' valign='top'>
<a href="../../../index.html" title="首页">首页</a> |
<a href="../../../r/e/c/Special%7ERecentchanges.html" title="Special:Recentchanges">最近更改</a> |
<a href="../../../%E7%8E%8B/%E6%BE%8D/%E7%89%88/%E7%8E%8B%E6%BE%8D%E7%89%88.html" title="王澍版">编辑本页</a> |
<a href="../../../%E7%8E%8B/%E6%BE%8D/%E7%89%88/%E7%8E%8B%E6%BE%8D%E7%89%88.html" title="王澍版">较早版本</a><p class='subtitle'><a href="../../../%E7%8E%8B/%E6%BE%8D/%E7%89%88/%E7%8E%8B%E6%BE%8D%E7%89%88.html">可打印版</a> | <a href="../../../g/e/n/WIKI-HIT_IBM_CLUB%7EGeneral_disclaimer.html" title="WIKI-HIT IBM CLUB:General disclaimer">Disclaimers</a></p>
</td>
<td class="top" valign='top' align='right' nowrap='nowrap'>Not logged in
<br /><a href="../../../u/s/e/Special%7EUserlogin.html" title="Special:Userlogin">登录</a> | <a href="../../../w/i/k/Wikipedia%7E%E5%B8%AE%E5%8A%A9.html" title="Wikipedia:帮助">帮助</a>
<br /><form name="search" class="inline" method="post" action="../../../s/e/a/Special%7ESearch.html">
<input type="text" name="search" size="19" value="" />
<input type="submit" name="go" value="进入" />&nbsp;<input type="submit" name="fulltext" value="搜索" />
</form></td></tr>
</table>
</div>

<div id='article'>
<h1 class="pagetitle">王澍版</h1><p class='subtitle'>Wikipedia，自由的百科全书</p>
<table id='toc' class='toc'><tr><td><div id='toctitle'><h2>目录</h2></div>
<ul>
<li class='toclevel-1'><a href="#.E7.AC.AC.E5.8D.81.E7.AB.A0_.E6.97.B6.E9.97.B4"><span class="tocnumber">1</span> <span class="toctext">第十章 时间</span></a>
<ul>
<li class='toclevel-2'><a href="#.E6.97.B6.E9.97.B4.E7.9A.84.E6.95.B0.E6.8D.AE.E7.BB.93.E6.9E.84"><span class="tocnumber">1.1</span> <span class="toctext">时间的数据结构</span></a>
<ul>
<li class='toclevel-3'><a href="#.E5.8E.9F.E5.A7.8B.E8.A1.A8.E7.A4.BA"><span class="tocnumber">1.1.1</span> <span class="toctext">原始表示</span></a></li>
<li class='toclevel-3'><a href="#.E8.80.8C.E7.8E.B0.E5.9C.A8.EF.BC.8C.E6.AF.AB.E7.A7.92.E7.BA.A7.E7.B2.BE.E5.BA.A6"><span class="tocnumber">1.1.2</span> <span class="toctext">而现在，毫秒级精度</span></a></li>
<li class='toclevel-3'><a href="#.E7.94.9A.E8.87.B3.E6.9B.B4.E5.A5.BD.EF.BC.9A.E7.BA.B3.E7.A7.92.E7.BA.A7.E7.B2.BE.E5.BA.A6"><span class="tocnumber">1.1.3</span> <span class="toctext">甚至更好：纳秒级精度</span></a></li>
<li class='toclevel-3'><a href="#.E5.88.86.E8.A7.A3.E6.97.B6.E9.97.B4"><span class="tocnumber">1.1.4</span> <span class="toctext">分解时间</span></a></li>
<li class='toclevel-3'><a href="#.E4.B8.80.E7.A7.8D.E8.BF.9B.E7.A8.8B.E6.97.B6.E9.97.B4.E7.B1.BB.E5.9E.8B"><span class="tocnumber">1.1.5</span> <span class="toctext">一种进程时间类型</span></a></li>
</ul>
</li>
<li class='toclevel-2'><a href="#POSIX.E6.97.B6.E9.92.9F"><span class="tocnumber">1.2</span> <span class="toctext">POSIX时钟</span></a></li>
<li class='toclevel-2'><a href="#.E6.97.B6.E9.97.B4.E6.BA.90.E7.B2.BE.E5.BA.A6"><span class="tocnumber">1.3</span> <span class="toctext">时间源精度</span></a></li>
<li class='toclevel-2'><a href="#.E5.8F.96.E5.BE.97.E4.BB.8A.E6.97.A5.E5.BD.93.E5.89.8D.E6.97.B6.E9.97.B4"><span class="tocnumber">1.4</span> <span class="toctext">取得今日当前时间</span></a>
<ul>
<li class='toclevel-3'><a href="#.E4.B8.80.E4.B8.AA.E6.9B.B4.E5.A5.BD.E7.9A.84.E6.8E.A5.E5.8F.A3"><span class="tocnumber">1.4.1</span> <span class="toctext">一个更好的接口</span></a></li>
<li class='toclevel-3'><a href="#.E4.B8.80.E4.B8.AA.E9.AB.98.E7.BA.A7.E6.8E.A5.E5.8F.A3"><span class="tocnumber">1.4.2</span> <span class="toctext">一个高级接口</span></a></li>
<li class='toclevel-3'><a href="#.E5.8F.96.E5.BE.97.E8.BF.9B.E7.A8.8B.E6.97.B6.E9.97.B4"><span class="tocnumber">1.4.3</span> <span class="toctext">取得进程时间</span></a></li>
</ul>
</li>
<li class='toclevel-2'><a href="#.E8.AE.BE.E7.BD.AE.E4.B8.80.E5.A4.A9.E7.9A.84.E5.BD.93.E5.89.8D.E6.97.B6.E9.97.B4"><span class="tocnumber">1.5</span> <span class="toctext">设置一天的当前时间</span></a>
<ul>
<li class='toclevel-3'><a href="#.E9.AB.98.E7.B2.BE.E5.BA.A6.E5.AE.9A.E6.97.B6"><span class="tocnumber">1.5.1</span> <span class="toctext">高精度定时</span></a></li>
<li class='toclevel-3'><a href="#.E8.AE.BE.E7.BD.AE.E6.97.B6.E9.97.B4.E7.9A.84.E4.B8.80.E4.B8.AA.E9.AB.98.E7.BA.A7.E6.8E.A5.E5.8F.A3"><span class="tocnumber">1.5.2</span> <span class="toctext">设置时间的一个高级接口</span></a></li>
</ul>
</li>
<li class='toclevel-2'><a href="#.E7.8E.A9.E8.BD.AC.E6.97.B6.E9.97.B4"><span class="tocnumber">1.6</span> <span class="toctext">玩转时间</span></a></li>
<li class='toclevel-2'><a href="#.E8.B0.83.E6.A0.A1.E7.B3.BB.E7.BB.9F.E6.97.B6.E9.92.9F"><span class="tocnumber">1.7</span> <span class="toctext">调校系统时钟</span></a></li>
<li class='toclevel-2'><a href="#.E7.9D.A1.E7.9C.A0.E5.92.8C.E7.AD.89.E5.BE.85"><span class="tocnumber">1.8</span> <span class="toctext">睡眠和等待</span></a>
<ul>
<li class='toclevel-3'><a href="#.E5.BE.AE.E7.A7.92.E7.BA.A7.E7.B2.BE.E5.BA.A6.E7.9D.A1.E7.9C.A0"><span class="tocnumber">1.8.1</span> <span class="toctext">微秒级精度睡眠</span></a></li>
<li class='toclevel-3'><a href="#.E7.BA.B3.E7.A7.92.E7.BA.A7.E7.B2.BE.E5.BA.A6.E7.9D.A1.E7.9C.A0"><span class="tocnumber">1.8.2</span> <span class="toctext">纳秒级精度睡眠</span></a></li>
<li class='toclevel-3'><a href="#.E4.B8.80.E4.B8.AA.E9.AB.98.E7.BA.A7.E7.9A.84.E7.9D.A1.E7.9C.A0.E6.96.B9.E6.B3.95"><span class="tocnumber">1.8.3</span> <span class="toctext">一个高级的睡眠方法</span></a></li>
<li class='toclevel-3'><a href="#.E5.8F.AF.E7.A7.BB.E6.A4.8D.E7.9D.A1.E7.9C.A0"><span class="tocnumber">1.8.4</span> <span class="toctext">可移植睡眠</span></a></li>
<li class='toclevel-3'><a href="#overruns"><span class="tocnumber">1.8.5</span> <span class="toctext">overruns</span></a></li>
<li class='toclevel-3'><a href="#.E6.9B.BF.E4.BB.A3.E7.9D.A1.E7.9C.A0"><span class="tocnumber">1.8.6</span> <span class="toctext">替代睡眠</span></a></li>
</ul>
</li>
<li class='toclevel-2'><a href="#.E8.AE.A1.E6.97.B6.E5.99.A8"><span class="tocnumber">1.9</span> <span class="toctext">计时器</span></a>
<ul>
<li class='toclevel-3'><a href="#.E7.AE.80.E5.8D.95.E7.9A.84.E9.97.B9.E9.92.9F"><span class="tocnumber">1.9.1</span> <span class="toctext">简单的闹钟</span></a></li>
<li class='toclevel-3'><a href="#Interval_Timers"><span class="tocnumber">1.9.2</span> <span class="toctext">Interval Timers</span></a></li>
<li class='toclevel-3'><a href="#.E9.AB.98.E7.BA.A7.E8.AE.A1.E6.97.B6.E5.99.A8"><span class="tocnumber">1.9.3</span> <span class="toctext">高级计时器</span></a>
<ul>
<li class='toclevel-4'><a href="#.E5.BB.BA.E7.AB.8B.E4.B8.80.E4.B8.AA.E8.AE.A1.E6.97.B6.E5.99.A8"><span class="tocnumber">1.9.3.1</span> <span class="toctext">建立一个计时器</span></a></li>
<li class='toclevel-4'><a href="#.E8.AE.BE.E7.BD.AE.E8.AE.A1.E6.97.B6.E5.99.A8"><span class="tocnumber">1.9.3.2</span> <span class="toctext">设置计时器</span></a></li>
<li class='toclevel-4'><a href="#.E5.8F.96.E5.BE.97.E8.AE.A1.E6.97.B6.E5.99.A8.E7.9A.84expiration"><span class="tocnumber">1.9.3.3</span> <span class="toctext">取得计时器的expiration</span></a></li>
<li class='toclevel-4'><a href="#.E5.8F.96.E5.BE.97.E8.AE.A1.E6.97.B6.E5.99.A8.E7.9A.84overrun"><span class="tocnumber">1.9.3.4</span> <span class="toctext">取得计时器的overrun</span></a></li>
<li class='toclevel-4'><a href="#.E5.88.A0.E9.99.A4.E8.AE.A1.E6.97.B6.E5.99.A8"><span class="tocnumber">1.9.3.5</span> <span class="toctext">删除计时器</span></a></li>
</ul>
</li>
</ul>
</li>
<li class='toclevel-2'><a href="#.E5.8E.9F.E6.B3.A8.EF.BC.9A"><span class="tocnumber">1.10</span> <span class="toctext">原注：</span></a></li>
</ul>
</li>
</ul>
</td></tr></table>
<p><script type="text/javascript"> if (window.showTocToggle) { var tocShowText = "显示"; var tocHideText = "隐藏"; showTocToggle(); } </script>
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../%E7%8E%8B/%E6%BE%8D/%E7%89%88/%E7%8E%8B%E6%BE%8D%E7%89%88.html" title="王澍版">编辑</a>]</div><a name=".E7.AC.AC.E5.8D.81.E7.AB.A0_.E6.97.B6.E9.97.B4"></a><h1>第十章 时间</h1>
<p>在一个现代操作系统中时间服务于多种目的，而许多程序需要追踪时间。内核从三个角度来衡量时间：
</p><p>Wall time（或真实时间）
</p><p>这是真实世界中的实际时间和日期——就是说，这是可以从挂在墙上的钟上读出的时间。进程在接触用户或者给一个时间盖电子时戳时使用wall time。
</p><p>进程时间
</p><p>这是进程已使用的时间，直接在用户空间中的代码，或者是间接的，内核为了该进程工作的时间。进程通常在描述统计时关心这种时间——举个例子，衡量一个操作需耗时多少。wall time会对衡量进程表现起误导作用，因为Linux的多任务特性，一个操作的进程时间可以比wall time少许多。进程也会消耗掉相当多个周期去等待I/O（尤其是键盘输入）。
</p><p>单调时间
</p><p>这个时间源会严格线性增长。大多数操作系统，包括Linux，使用计算机的正常运行时间（从启动起的时间）。wall time会变化——举个例子，因为用户可以设定，而且因为系统会由于误差不断调整这个时间——也会有其它的不精确度引入，像闰秒。系统正常运行时间，从另一方面来说，是一种确定的不可改变的时间表示。单调时间源的重要性不在于当前值，而是时间源线性增长的保证，以及可以利用此特性来计算两两时间差。
</p><p>因而单调时间适合来计算相对时间，反而wall time对于衡量绝对时间更理想。
</p><p>这三种时间测量可以采用一两种形式：
</p><p>相对时间
</p><p>这是对某个基准时间的相对值，像current instant：举个例子，从现在起5秒钟，或者10分钟之前。
</p><p>绝对时间
</p><p>表示不含任何基准的时间，像1968年3月25日中午。
</p><p>相对和绝对两种时间形式都是有用的。一个进程可能需要在500毫秒内取消一个请求，每秒刷新60次屏幕，或者记录自从某个操作开始后已经过去了7秒。所有这些都需计算相对时间。反过来，一个日历应用可能要存储用户toga party的日期2月8日，一个文件系统将在某个文件创建时写下完整的日期和时间（而不是“5秒前”），用户的时钟显示公历日期，不是自机器启动以来的时间。
</p><p>Unix系统使用从大纪元——定义为1970年一月1日00:00:00——以来经过的秒数来表示绝对时间。UTC（通用协调时间）差不多是GMT（格林尼治标准时间）。有意思的是，这意味着在Unix中即便是绝对时间本身，从低层面来说，也是相对的。Unix引入了一种特殊日期形式来存储“自从大纪元以来的时间，”，我们将在下一节探讨。
</p><p>操作系统追踪时间进展是通过软件时钟实现的，一种软件中由内核维护的时钟。内核创建一个周期计时器实例，叫做系统计时器，遵循一种特定频率。当一个计时器间隔结束时，内核将消耗时间值增加一个单位，记做一个滴答。消耗滴答的计数器被称作滴答计数器(jiffies counter)。以前是32位值，在2.6 Linux内核中滴答则是64位计数的。#
</p><p>在Linux中，系统计时器的频率叫做HZ，因为一个定义了相同名字的预处理程序表示了它。HZ的值是架构指定的，而且不是Linux应用程序二进制接口的一部分——就是说，程序不能依赖于或者期望任何给定值。历史上，x86架构使用值100，表示系统计时器每秒钟跑100次（就是说系统计时器的频率是100赫兹）。这就使每个滴答的值为0。01秒——1/HZ秒。在2.6 Linux内核中，内核开发者把HZ的值暴涨到1000，使得每个滴答的值变成0.001秒。然而，在2.6.13和之后的版本中，HZ是250，让每个滴答值为0.004秒。† 在HZ的值上有这样的折衷方案：较高的值能提供较高的分辨率，但带来了更大的计时器开销。
</p><p>尽管进程不应依赖于任何确定的HZ值，POSIX定义了一种在运行期来确定系统计时器频率的机制：
</p>
<pre>long hz;

hz = sysconf (_SC_CLK_TCK);
if (hz == -1)
	perror ("sysconf"); /* should never occur */
</pre>
<p>当一个程序想要确定系统时钟频率的时候这个接口很有用，但将系统时间转换到秒就没有必要了，因为大多数POSIX时间测量结果的输出已经转换过了，或者定为了一个与HZ无关的确定值。和HZ不同，这个确定的频率是系统ABI的一部分；在x86上的值是100。以时钟滴答计时间返回值的POSIX函数用CLOCKS_PER_SEC来表示这个确定的频率。
</p><p>偶尔事件会企图关闭计算机。有时计算机甚至会被拔电unplugged$$$；然而到启动时，却有正确的时间。这是因为大多数计算机都有一个电池供电的硬件时钟在其关闭时存储时间和日期。当内核启动时，就从该硬件时钟来初始化当前时间。同样的，用户关闭计算机时，内核将时间写回到硬件时钟里。系统管理员可以通过hwclock命令将时钟同步到其他时刻。
</p><p>管理Unix系统的时间推移包括些许任务，其中只有一些是任何给定进程都关心的：包括设定和取得当前真实时间，计算消耗时间，睡眠一段给定时间，进行精确的时间测量，以及控制计时器。本章涵盖了时间相关的所有内容。我们将从Linux表示时间的数据结构开始看起。
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../%E7%8E%8B/%E6%BE%8D/%E7%89%88/%E7%8E%8B%E6%BE%8D%E7%89%88.html" title="王澍版">编辑</a>]</div><a name=".E6.97.B6.E9.97.B4.E7.9A.84.E6.95.B0.E6.8D.AE.E7.BB.93.E6.9E.84"></a><h2>时间的数据结构</h2>
<p>随着各种Unix系统的发展，实现了各种自己管理时间的接口，有多种数据结构来表示看似简单的时间概念。这些数据结构从简单的整型到各种各样的多字段结构。在一头扎进实际接口前，我们在这里讨论它们。
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../%E7%8E%8B/%E6%BE%8D/%E7%89%88/%E7%8E%8B%E6%BE%8D%E7%89%88.html" title="王澍版">编辑</a>]</div><a name=".E5.8E.9F.E5.A7.8B.E8.A1.A8.E7.A4.BA"></a><h3>原始表示</h3>
<p>最简单的数据结构是time_t，定义在头文件&lt;time.h&gt;中。time_t的意图是搞成一个不透明的类型。然而，在大多数Unix系统上——包括Linux——这个类型是一个简单的C长整型typedef：
</p>
<pre>typedef long time_t;
</pre>
<p>time_t表示以秒计的从大纪元以来流逝的时间。“那不会过多久就会上溢！”是一种经典的回应。实际上，会比你想的更久，但在大量Unix系统仍然在使用时确实会上溢。用32位的长整型，time_t最多能表示大纪元后2,147,483,647秒。这表示我们将会再一次遭遇千年虫混乱——在2038年！然而幸运的是，在2038年一月18日，星期一的22:14:07时，大多数系统和软件将会是64位的。
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../%E7%8E%8B/%E6%BE%8D/%E7%89%88/%E7%8E%8B%E6%BE%8D%E7%89%88.html" title="王澍版">编辑</a>]</div><a name=".E8.80.8C.E7.8E.B0.E5.9C.A8.EF.BC.8C.E6.AF.AB.E7.A7.92.E7.BA.A7.E7.B2.BE.E5.BA.A6"></a><h3>而现在，毫秒级精度</h3>
<p>与time_t相关的另外一个问题是一秒钟内会发生很多事情。timeval结构对time_t进行了扩展而达到了毫秒级精度。头文件&lt;sys/time.h&gt;中如下定义了这种结构:
</p>
<pre>#include &lt;sys/time.h&gt;
struct timeval {
    time_t tv_sec; /* seconds */
    suseconds_t tv_usec; /* microseconds */
};
</pre>
<p>tv_sec衡量秒数，而tv_usec衡量毫秒数。令人困惑的suseconds_t通常是一个整型的typedef。
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../%E7%8E%8B/%E6%BE%8D/%E7%89%88/%E7%8E%8B%E6%BE%8D%E7%89%88.html" title="王澍版">编辑</a>]</div><a name=".E7.94.9A.E8.87.B3.E6.9B.B4.E5.A5.BD.EF.BC.9A.E7.BA.B3.E7.A7.92.E7.BA.A7.E7.B2.BE.E5.BA.A6"></a><h3>甚至更好：纳秒级精度</h3>
<p>出于对毫秒级精度的不满，timespec结构将赌注提高到了纳秒级。头文件&lt;time.h&gt;如下定义了这种结构：
</p>
<pre>#include &lt;time.h&gt;
struct timespec {
    time_t tv_sec; /* seconds */
    long tv_nsec; /* nanoseconds */
};
</pre>
<p>如果有选择，接口会更愿意采用纳秒级精度而非毫秒级。# 结果，由于引入了timespec结构，大多数时间相关的接口就采用它了，并获得了更高的精度。然而，正如我们将看到的，一个重要的函数仍然使用timeval。
</p><p>实际上，没有一个结构能够提供所声明的精度，因为系统计时器没有提供纳秒级甚至毫秒级的精度。尽管如此，采用可用的高精度仍是更佳选择，因为能适应系统提供的任何情况。
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../%E7%8E%8B/%E6%BE%8D/%E7%89%88/%E7%8E%8B%E6%BE%8D%E7%89%88.html" title="王澍版">编辑</a>]</div><a name=".E5.88.86.E8.A7.A3.E6.97.B6.E9.97.B4"></a><h3>分解时间</h3>
<p>我们将要讨论的一些函数能够在时间和串之间转换，或者用程序来建立一个时间日期的串表示。为了有助于这个过程，标准C提供了结构tm从一个更适合人理解的格式来表示“分解了的”时间。这个结构也定义在&lt;time.h&gt;中：
</p>
<pre>#include &lt;time.h&gt;
struct tm {
	int tm_sec; /* seconds */
	int tm_min; /* minutes */
	int tm_hour; /* hours */
	int tm_mday; /* the day of the month */
	int tm_mon; /* the month */
	int tm_year; /* the year */
	int tm_wday; /* the day of the week */
	int tm_yday; /* the day in the year */
	int tm_isdst; /* daylight savings time? */
#ifdef _BSD_SOURCE
	long tm_gmtoff; /* time zone's offset from GMT */
	const char *tm_zone; /* time zone abbreviation */
#endif /* _BSD_SOURCE */
};
</pre>
<p>tm结构能更简单的告诉我们time_t的值是多少，就是说，314159是周日还是周六（在前面的）。按照空间顺序，这样表示时间日期显然是一个糟糕的选择，但却更方便向或者从面向用户的值转换。
</p><p>这些字段如下：
</p><p>tm_sec
</p><p>在分钟后的秒数。这个值通常在0到59之间，但可以高达61来表示跳了两秒。$$$
</p><p>tm_min
</p><p>小时后的分钟数。这个值在0到59之间。
</p><p>tm_hour
</p><p>午夜过后的小时数。这个值在0到23之间。
</p><p>tm_mday
</p><p>该月的日期。这个值在0到31之间。POSIX并没有指定0值；然而，Linux用它表示上个月的最后一天。
</p><p>tm_mon
</p><p>从一月以来的月数。这个值在0到11之间。
</p><p>tm_year
</p><p>从1900年以来的年数。
</p><p>tm_wday
</p><p>从周日以来的天数。这个值在0到6之间。
</p><p>tm_yday
</p><p>从一月1日以来的日期数。这个值在0到365之间。
</p><p>tm_isdst
</p><p>一个特殊值表示日光节约时间（DST）在其他字段描述的当时是否有效。如果这个值为正，那么DST有效。如果是0，DST无效。如果是负数，DST的状态未知。
</p><p>tm_gmtoff
</p><p>以秒计的当前时区与格林尼治时间偏差值。这个字段仅仅在包含&lt;time.h&gt;之前定义了_BSD_SOURCE才会出现。
</p><p>tm_zone
</p><p>当前时区的缩写——像，EST。这个字段仅仅在包含&lt;time.h&gt;之前定义了_BSD_SOURCE才会出现。
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../%E7%8E%8B/%E6%BE%8D/%E7%89%88/%E7%8E%8B%E6%BE%8D%E7%89%88.html" title="王澍版">编辑</a>]</div><a name=".E4.B8.80.E7.A7.8D.E8.BF.9B.E7.A8.8B.E6.97.B6.E9.97.B4.E7.B1.BB.E5.9E.8B"></a><h3>一种进程时间类型</h3>
<p>clock_t类型表示时钟滴答。这是个整数类型，通常是长整型。根据接口，clock_t的滴答表示系统实际计时器频率（HZ）或者CLOCKS_PER_SEC。
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../%E7%8E%8B/%E6%BE%8D/%E7%89%88/%E7%8E%8B%E6%BE%8D%E7%89%88.html" title="王澍版">编辑</a>]</div><a name="POSIX.E6.97.B6.E9.92.9F"></a><h2>POSIX时钟</h2>
<p>本章讨论的一些系统调用使用了POSIX时钟，一种实现和表示时间源的标准。clockid_t类型表示了特定的POSIX时钟，Linux支持其中四种：
</p><p>CLOCK_MONOTONIC
</p><p>一个不受任何进程设置的单调增长的时钟。它表示自从某个非特定起始点以来流逝的时间，像从系统启动开始。
</p><p>CLOCK_PROCESS_CPUTIME_ID
</p><p>一个高精度，来自处理器的每个进程都可用的时钟。举例来说，在i386架构上，这个时钟采用时间戳计数（TSC）寄存器。
</p><p>CLOCK_REALTIME
</p><p>系统级真实时间（wall time）钟。设置该时钟需要特殊权限。
</p><p>CLOCK_THREAD_CPUTIME_ID
</p><p>和每个进程的时钟类似，但是是线程独有的。
</p><p>POSIX定义了所有四个时间源，但只需要CLOCK_REALTIME。因而，虽然Linux可靠的提供了所有四个时钟，但可移植的代码应该仅仅依赖于CLOCK_REALTIME。
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../%E7%8E%8B/%E6%BE%8D/%E7%89%88/%E7%8E%8B%E6%BE%8D%E7%89%88.html" title="王澍版">编辑</a>]</div><a name=".E6.97.B6.E9.97.B4.E6.BA.90.E7.B2.BE.E5.BA.A6"></a><h2>时间源精度</h2>
<p>POSIX定义了clock_getres()函数来取得给定时间源的精度。
</p>
<pre>#include &lt;time.h&gt;
int clock_getres (clockid_t clock_id,
               struct timespec *res);
</pre>
<p>一个clock_getres()的成功调用会将clock_id指定的时钟精度存储到res中，如果结果不是NULL，就返回0。失败时，函数返回-1，并设置errno为以下两个错误码&gt;之一：
</p><p>EFAULT
</p><p>	res是一个非法的指针。
</p><p>EINVAL
</p><p>	clock_id在该系统上不是一个可用的时间源。
</p><p>以下的样例将先前讨论的四种时间源输出：
</p>
<pre>clockid_t clocks[] = {
	CLOCK_REALTIME,
	CLOCK_MONOTONIC,
	CLOCK_PROCESS_CPUTIME_ID,
	CLOCK_THREAD_CPUTIME_ID,
	(clockid_t) -1 };
int i;

for (i = 0; clocks[i]&nbsp;!= (clockid_t) -1; i++) {
	struct timespec res;
	int ret;

	ret = clock_getres (clocks[i], &amp;res);
	if (ret)
		perror ("clock_getres");
	else
		printf ("clock=%d sec=%ld nsec=%ld\n",
	clocks[i], res.tv_sec, res.tv_nsec);
}
</pre>
<p>在现代x86系统上，输出大致类似于下面的样子：
</p>
<pre>clock=0 sec=0 nsec=4000250
clock=1 sec=0 nsec=4000250
clock=2 sec=0 nsec=1
clock=3 sec=0 nsec=1
</pre>
<p>注意到4,000,250纳秒是4微秒，也就是0.004秒。反过来，0.004秒也是给定HZ值为250的x86系统时钟的精度，回想我们在本章第一节所讨论的。这样，我们看到CLOCK_REALTIME和CLOCK_MONOTONIC二者都和滴答数，以及系统计时器所提供的精度有联系。相反的，CLOCK_PROCESS_CPUTIME_ID和CLOCK_THREAD_CPUTIME_ID利用了一种更高精度的时间源——在同一台x86机器上，就是TSC，我们看到它能提供纳秒级精度。 
</p><p>在Linux上（还有大多数其他Unix系统），所有使用POSIX时钟的函数都需要将目标文件与librt链接。举例来说，如果想把刚才的片断编译成完整的可执行程序，
你可能会用到以下的命令：
</p>
<pre>$ gcc -Wall -W -O2 -lrt -g -o snippet snippet.c
</pre>
<p><br />
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../%E7%8E%8B/%E6%BE%8D/%E7%89%88/%E7%8E%8B%E6%BE%8D%E7%89%88.html" title="王澍版">编辑</a>]</div><a name=".E5.8F.96.E5.BE.97.E4.BB.8A.E6.97.A5.E5.BD.93.E5.89.8D.E6.97.B6.E9.97.B4"></a><h2>取得今日当前时间</h2>
<p>应用有些理由想要取得当前时间和日期：显示给用户，计算相对或者流逝的时间，给事件打时间戳等等。最简单也是历史上最常用取得当前时间的办法是time()&gt;函数：
</p>
<pre>       #include &lt;time.h&gt;

       time_t time (time_t *t);
</pre>
<p>一个time()调用返回当前时间，以自从大纪元以来用秒计的的流逝的时间来表示。如果参数t非NULL，该函数也将当前时间写入到提供的指针中。
</p><p>错误时，函数返回-1（类型转换到一个time_t），并且设置errno为合适值。
</p><p>举个例子：
</p>
<pre>       time_t t;

       printf("current time: %ld\n", (long) time (&amp;t));
       printf("the same value: %ld\n". (long) t);
</pre>
<p><br />
</p>
<pre>               一个简陋的计时方法
time_t表示的“自从大纪元以来流逝的秒数”并不是真正的自从那个决定性一刻以来经过的时间的秒数。Unix计算假定了所有能被四整除的年份都是闰年，并且
忽略了所有的闰秒。time_t的表示法的要点并不精确，但却是一致的——而它确实如此。
</pre>
<p><br />
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../%E7%8E%8B/%E6%BE%8D/%E7%89%88/%E7%8E%8B%E6%BE%8D%E7%89%88.html" title="王澍版">编辑</a>]</div><a name=".E4.B8.80.E4.B8.AA.E6.9B.B4.E5.A5.BD.E7.9A.84.E6.8E.A5.E5.8F.A3"></a><h3>一个更好的接口</h3>
<p>gettimeofday()函数提供了微秒精度来拓展time()：
</p>
<pre>#include &lt;sys/time.h&gt;

int gettimeofday (struct timeval *tv,
		struct timezone *tz);
</pre>
<p>一个成功的gettimeofday()调用将当前时间放到由tv指向的timeval结构中，并返回0。timezone结构和tz参数已经老掉牙了；都不该在Linux中使用。总是传递NULL给tz。
</p><p>失败时，调用返回-1，并设置errno为EFAULT；这是唯一可能的错误，表示tv或者tz不是合法指针。
</p><p>看个例子：
</p>
<pre>struct timeval tv;
int ret;

ret = gettimeofday (&amp;tv, NULL);
if (ret)
	perror ("gettimeofday");
else
	printf ("seconds=%ld useconds=%ld\n",
		(long) tv.sec, (long) tv.usec);
</pre>
<p>timezone结构已经过时，因为内核不再管理时区，而且glibc不能使用timezone结构的tz_dstime字段。我们将在下一节研究如何操作时间区域。
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../%E7%8E%8B/%E6%BE%8D/%E7%89%88/%E7%8E%8B%E6%BE%8D%E7%89%88.html" title="王澍版">编辑</a>]</div><a name=".E4.B8.80.E4.B8.AA.E9.AB.98.E7.BA.A7.E6.8E.A5.E5.8F.A3"></a><h3>一个高级接口</h3>
<p>POSIX提供了clock_gettime()接口来取得一个指定时间源的时间。然而更有用的是，该函数可以达到纳秒级精度。
</p>
<pre>#include &lt;time.h&gt;

int clock_gettime (clockid_t clock_id,
		    struct timespec *ts);
</pre>
<p>成功时，调用返回0，并将clock_id指定的时间源当前时间存储到ts中。失败时，调用返回-1，并设置errno为下列值之一：
</p><p>EFAULT
</p><p>ts不是合法指针。
</p><p>EINVAL
</p><p>clock_id在该系统上不是合法时间源。
</p><p>下面的例子从所有四种标准时间源中取得当前时间：
</p>
<pre>clockid_t clocks[] = {
	CLOCK_REALTIME,
	CLOCK_MONOTONIC,
	CLOCK_PROCESS_CPUTIME_ID,
	CLOCK_THREAD_CPUTIME_ID,
	(clockid_t) -1 };
int i;

for (i = 0; clocks[i]&nbsp;!= (clockid_t) -1; i++) {
	struct timespec ts;
	int ret;
	
	ret = clock_gettime (clocks[i], &amp;ts);
	if (ret)
		perror ("clock_gettime");
	else
		printf ("clock=%d sec=%ld nsec=%ld\n",
	clocks[i], ts.tv_sec, ts.tv_nsec);
}
</pre>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../%E7%8E%8B/%E6%BE%8D/%E7%89%88/%E7%8E%8B%E6%BE%8D%E7%89%88.html" title="王澍版">编辑</a>]</div><a name=".E5.8F.96.E5.BE.97.E8.BF.9B.E7.A8.8B.E6.97.B6.E9.97.B4"></a><h3>取得进程时间</h3>
<p>times()系统调用取得正在运行的进程及其子女的进程时间，以时钟滴答计。
</p>
<pre>#include &lt;sys/times.h&gt;

struct tms {
	clock_t tms_utime; /* user time consumed */
	clock_t tms_stime; /* system time consumed */
	clock_t tms_cutime; /* user time consumed by children */
	clock_t tms_cstime; /* system time consumed by children */
};

clock_t times (struct tms *buf);
</pre>
<p>成功时，调用将发起进程及其子女消耗的进程时间写入到buf所指的tms结构中。报告的时间被分割成用户和系统时间。用户时间是在用户空间执行代码所用的时间。系统时间是在内核空间执行所用的时间——举例来说，在系统调用中，或者一个页错误。每个子女报告的时间只有在该子女已经终结，且父进程对其调用了waitpid()（或者相关函数）之后才被包含进来。调用返回时钟滴答数，从过去的某专门起点单调递增。这个参考点曾是系统启动——就是说，times()函数返回系统开机来的时间，以滴答计——但是参考点现在是系统启动前大约四亿两千九百万秒。内核开发者做出这个改动是为了捕捉那些无法处理接近或者为零的系统开机时间的内核代码。这个函数返回的绝对值是没什么用的；而两次发起的相对时间，则仍然有值。$$$
</p><p>失败时，调用返回-1，并设置errno为合适值。在Linux上，唯一可能的错误码是EFAULT，表示buf不是合法指针。
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../%E7%8E%8B/%E6%BE%8D/%E7%89%88/%E7%8E%8B%E6%BE%8D%E7%89%88.html" title="王澍版">编辑</a>]</div><a name=".E8.AE.BE.E7.BD.AE.E4.B8.80.E5.A4.A9.E7.9A.84.E5.BD.93.E5.89.8D.E6.97.B6.E9.97.B4"></a><h2>设置一天的当前时间</h2>
<p>前面的章节描述了如何取得时间，应用偶尔也需要将当前时间日期设置为一个给定值。大多数情况都有一个单独设计来处理该问题的东西，像date。
</p><p>time()在时间设置部分的反面是stime()：
</p>
<pre>#define _SVID_SOURCE
#include &lt;time.h&gt;

int stime (time_t *t);
</pre>
<p>一个成功的stime()调用设置系统时间为t所指向的值并返回0。调用需要发起者拥有CAP_SYS_TIME权限。一般的，只有root用户才有。
</p><p>失败时，调用返回-1，并设置errno为EFAULT，表示t不是合法指针，或者EPERM，表示发起者没有CAP_SYS_TIME权限。
</p><p>用法相当简单：
</p>
<pre>time_t t = 1;
int ret;

/* set time to one second after the epoch */
ret = stime (&amp;t);
if (ret)
	perror ("stime");
</pre>
<p>我们将在接下来一节看看能将人们习惯的时间格式方便的转换成time_t的函数。
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../%E7%8E%8B/%E6%BE%8D/%E7%89%88/%E7%8E%8B%E6%BE%8D%E7%89%88.html" title="王澍版">编辑</a>]</div><a name=".E9.AB.98.E7.B2.BE.E5.BA.A6.E5.AE.9A.E6.97.B6"></a><h3>高精度定时</h3>
<p>gettimeofday()的反面是settimeofday()：
</p>
<pre>#include &lt;sys/time.h&gt;

int settimeofday (const struct timeval *tv ,
const struct timezone *tz);
</pre>
<p>一个成功的settimeofday()调用将系统时间设定为tv给出的值并返回0。和gettimeofday()一样，让tz传递NULL是不错的选择。失败时，调用返回-1，并将errno设置为下列值之一：
</p><p>EFAULT
</p><p>tv或者tz在内存非法区域。
</p><p>EINVAL
</p><p>提供的结构体中某个字段非法。
</p><p>EPERM
</p><p>调用进程没有CAP_SYS_TIME权限。
</p><p>下面的例子将当前时间设置为1979年十二月中的一个周六。
</p>
<pre>struct timeval tv = { .tv_sec = 31415926,
			.tv_usec = 27182818 };
int ret;

ret = settimeofday (&amp;tv, NULL);
if (ret)
	perror ("settimeofday");
</pre>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../%E7%8E%8B/%E6%BE%8D/%E7%89%88/%E7%8E%8B%E6%BE%8D%E7%89%88.html" title="王澍版">编辑</a>]</div><a name=".E8.AE.BE.E7.BD.AE.E6.97.B6.E9.97.B4.E7.9A.84.E4.B8.80.E4.B8.AA.E9.AB.98.E7.BA.A7.E6.8E.A5.E5.8F.A3"></a><h3>设置时间的一个高级接口</h3>
<p>就像clock_gettime()改进了gettimeofday()那样，clock_settime()让settimeofday()过时了：
</p>
<pre>#include &lt;time.h&gt;

int clock_settime (clockid_t clock_id,
const struct timespec *ts);
</pre>
<p>成功时，调用返回0，而clock_id指定的时间源被设置为ts指定的时间。失败时，调用返回-1，并设置errno为下列值之一：
</p><p>EFAULT
</p><p>ts不是一个合法指针。
</p><p>EINVAL
</p><p>clock_id在该系统上不是合法时间源。
</p><p>EPERM
</p><p>进程没有设定该时间源的相关权限，或则该时间源不能被设置。
</p><p>在大多数系统上，唯一可以设置的时间源是CLOCK_REALTIME。就是说，这个函数比settimeofday()唯一优越之处在于提供了纳秒级精度（还有不用处理无聊的timezone结构体）。
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../%E7%8E%8B/%E6%BE%8D/%E7%89%88/%E7%8E%8B%E6%BE%8D%E7%89%88.html" title="王澍版">编辑</a>]</div><a name=".E7.8E.A9.E8.BD.AC.E6.97.B6.E9.97.B4"></a><h2>玩转时间</h2>
<p>Unix系统和C语言提供了一族函数来在分解了的时间（表示时间的ASCII字符串）和time_t之间转换。asctime()将tm结构体——分解了的时间——转换到一ASCII字符串：
</p>
<pre>#include &lt;time.h&gt;

char * asctime (const struct tm *tm);
char * asctime_r (const struct tm *tm, char *buf);
</pre>
<p>它返回一个指向静态分配字符串的指针。之后任何时间函数的调用都可能覆盖该字符串；asctime()不是线程安全的。
</p><p>这样，多线程程序（以及讨厌糟糕设计接口的开发者）应该使用asctime_r()。该函数不使用静态分配字符串的指针，而使用buf提供的，至少有26个字符长度的字符串。
</p><p>两个函数都在错误时都返回NULL。
</p><p>mktime()也转换tm结构体，但是转换到一个time_t。
</p>
<pre>#include &lt;time.h&gt;

time_t mktime (struct tm *tm);
</pre>
<p>mktime()也通过tm指定的tzset()设置时区。错误时返回-1（类型转换到一个time_t）。
</p><p>ctime()将一个time_t转换为ASCII表示：
</p>
<pre>#include &lt;time.h&gt;

char * ctime (const time_t *timep);
char * ctime_r (const time_t *timep, char *buf);
</pre>
<p>失败时，返回NULL。举例来说：
</p>
<pre>time_t t = time (NULL);

printf ("the time a mere line ago: %s", ctime (&amp;t));
</pre>
<p>注意到没有新的行出现。或许并不方便，ctime()在其返回字符串后追加了一空行。
</p><p>像asctime()，ctime()返回一个静态字符串的指针。由于这样不是线程安全的，基于线程的程序应该用ctime_r()来替代之，该函数在buf提供的缓冲区上工作。缓冲区最少应有26个字符长度。
</p><p>gmtime()将给出的time_t转换到tm结构体，用UTC时区格式表示：
</p>
<pre>#include &lt;time.h&gt;

struct tm * gmtime (const time_t *timep);
struct tm * gmtime_r (const time_t *timep, struct tm *result);
</pre>
<p>失败时，返回NULL。
</p><p>这个函数静态的分配返回结构体，而又一次，不是线程安全的。基于线程的程序应使用gmtime_r()，该函数在result指向的结构体上工作。
</p><p>localtime()和localtime_r()函数则分别类似于gmtime()和gmtime_r()，但他们将给出的time_t表示为用户时区:
</p>
<pre>#include &lt;time.h&gt;

struct tm * localtime (const time_t *timep);
struct tm * localtime_r (const time_t *timep, struct tm *result);
</pre>
<p>像mktime()那样，localtime()的调用也会调用tzset()，并初始化时区。localtime_r()是否执行此步骤是未定的。
</p><p>difftime()返回两个time_t值的差值，转换到双精度浮点表示的秒数。
</p>
<pre>#include &lt;time.h&gt;

double difftime (time_t time1, time_t time0);
</pre>
<p>在所有POSIX系统上，time_t是一个算术类型，而difftime()等价于以下值，忽略检测减法溢出：
</p>
<pre>(double) (time1 - time0)
</pre>
<p>在Linux上，由于time_t是一个整型，没有必要将其转换成双精度浮点。然而为了保持可移植性，还是用difftime()吧。
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../%E7%8E%8B/%E6%BE%8D/%E7%89%88/%E7%8E%8B%E6%BE%8D%E7%89%88.html" title="王澍版">编辑</a>]</div><a name=".E8.B0.83.E6.A0.A1.E7.B3.BB.E7.BB.9F.E6.97.B6.E9.92.9F"></a><h2>调校系统时钟</h2>
<p>真实时间的突然大变化会对操作依赖于绝对时间的应用造成严重破坏。考虑一个例子，make，由Makefile表示的用来建立软件项目的程序。每次执行该程序并不重建整个源代码树；如果这样做了，在大型软件项目中，一个文件的改动可能造成数个小时的重建。而make查询源文件（比如，wolf.c）改动的时间戳和目标文件（wolf.o）的。如果源文件——或者它的任何依赖文件，像wolf.h——比目标文件新，make将重建源文件到一个更新的目标文件。然而如果源文件不比目标文件新，什么都不发生。
</p><p>知道这些之后，考虑下如果用户知道了他的钟表晚了数个小时，并运行了date来更新系统时间后会发生什么事情。如果用户接下来更新并再次存储了wolf.c，我们就可能有麻烦了。如果用户把当前时间向前拨了，wolf.c可能会比wolf.o要旧——即使并非如此！——而且不会重建。
</p><p>为了防止这样的崩溃，Unix提供了adjtime()函数，用来逐渐调整当前时间增加一个指定的值。这样做的考量是为了一些后台工作的像网络时间协议（NTP）守护进程，来不断调整时间的差值，用adjtime()来最小化它们对系统的影响：
</p>
<pre>#define _BSD_SOURCE
#include &lt;sys/time.h&gt;

int adjtime (const struct timeval *delta,
		struct timeval *olddelta);
</pre>
<p>一个成功的adjtime()调用指示内核开始调整由delta指定的时间，然后返回0。如果delta指定的时间是正值，内核将加速系统时钟直到修正彻底完成。如果delta指定时间是负值，内核将减缓系统时钟直到修正完成。内核调整所有改动使得时钟总是单调递增并且不会有突然的跳变。即使有一个负值的delta，调整仍然不会使时钟反向；而是时钟减慢直到系统时间达到应调整到的时间。
</p><p>如果delta不是NULL，内核停止处理任何先前的改动。然而，如果有任何改动已经部分完成，仍将保留。如果olddelta不是NULL，任何先前未完成的改动将写入提供的timeval结构体。传递一个NULL的delta和一个合法的olddelta将回收任何正在进行的改动。
</p><p>adjtime()提供的改动应该不大——理想用途是NTP，像先前提到的那样，处理小的调整（数秒钟）。Linux在任一方向上保持最大和最小改动限度为数千秒。
</p><p>错误时，adjtime()返回-1，并设置errno为下列值之一：
</p><p>EFAULT
</p><p>delta或olddelta不是合法指针。
</p><p>EINVAL
</p><p>delta指定的调整过大或者过小。
</p><p>EPERM
</p><p>发起调用的用户没有CAP_SYS_TIME权限。
</p><p><a href='http://www.ietf.org/rfc/rfc1305.txt' class='external' title="http://www.ietf.org/rfc/rfc1305.txt">RFC 1305</a>定义了一个比adjtime()采用的渐进调整明显更加强大和更加复杂的时钟调整算法。Linux用adjtimex()系统调用实现了该算法。
</p>
<pre>#include &lt;sys/timex.h&gt;

int adjtimex (struct timex *adj);
</pre>
<p>一个adjtimex()调用读取内核时间相关的参数到adj指向的timex结构体中。可以选择的，依赖于该结构体的modes字段，系
统调用会额外设置某些参数。
</p><p>头文件&lt;sys/time.h&gt;如下定义了timex结构体：
</p>
<pre>struct timex {
	int modes; /* mode selector */
	long offset; /* time offset (usec) */
	long freq; /* frequency offset (scaled ppm) */
	long maxerror; /* maximum error (usec) */
	long esterror; /* estimated error (usec) */
	int status; /* clock status */
	constant; /* PLL time constant */
	long precision; /* clock precision (usec) */
	long tolerance; /* clock frequency tolerance (ppm) */
	struct timeval time; /* current time */
	long tick; /* usecs between clock ticks */
};
</pre>
<p>modes字段是由零或以下标志位按位或的结果：
</p><p>ADJ_OFFSET
</p><p>通过offset设置时间偏移量。
</p><p>ADJ_FREQUENCY
</p><p>通过freq设置频率偏移量。
</p><p>ADJ_MAXERROR
</p><p>通过maxerror设置最大错误值。
</p><p>ADJ_ESTERROR
</p><p>通过esterror设置估计错误值。
</p><p>ADJ_STATUS
</p><p>通过status设置时钟状态。
</p><p>ADJ_TIMECONST
</p><p>通过constant设置锁相环（PLL）时间常量。
</p><p>ADJ_TICK
</p><p>通过tick设置滴答值。
</p><p>ADJ_OFFSET_SINGLESHOT
</p><p>通过offset设置时间偏移量一次，使用简单算法，像adjtime()。
</p><p>如果modes是0，就没有设置值。只有拥有CAP_SYS_TIME权限的用户才能给modes赋非零值；任何提供0给modes的用户，将
取得所有参数，但不能设置任何值。
</p><p>成功时，adjtimex()返回当前时钟状态，是下列几个值之一：
</p><p>TIME_OK
</p><p>时钟被同步。
</p><p>TIME_INS
</p><p>将插入一闰秒。
</p><p>TIME_DEL
</p><p>将去除一秒。
</p><p>TIME_OOP
</p><p>正在处理一秒钟。$$$
</p><p>TIME_WAIT
</p><p>一闰秒刚刚出现。
</p><p>TIME_BAD
</p><p>时钟未同步。
</p><p>失败时，adjtimex()返回-1，并设置errno为下列错误码之一：
</p><p>EFAULT
</p><p>adj不是一个合法指针。
</p><p>EINVAL
</p><p>一个或更多的modes，offset或者tick非法。
</p><p>EPERM
</p><p>modes是非零值，但发起者没有CAP_SYS_TIME权限。
</p><p>adjtimex()系统调用是Linux特有的。关心可移植性的应用应该倾向于使用adjtime()。
</p><p><a href='http://www.ietf.org/rfc/rfc1305.txt' class='external' title="http://www.ietf.org/rfc/rfc1305.txt">RFC 1305</a>定义了一个复杂的算法，这样对adjtimex()的完整讨论超出了本书的范围。想知道更多信息，请看RFC。
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../%E7%8E%8B/%E6%BE%8D/%E7%89%88/%E7%8E%8B%E6%BE%8D%E7%89%88.html" title="王澍版">编辑</a>]</div><a name=".E7.9D.A1.E7.9C.A0.E5.92.8C.E7.AD.89.E5.BE.85"></a><h2>睡眠和等待</h2>
<p>有各种各样的函数能使进程睡眠（暂停执行）一段指定时间。第一个这样的函数，sleep()，让发起进程睡眠由seconds指定的秒数。
</p>
<pre>﻿#include &lt;unistd.h&gt;

unsigned int sleep (unsigned int seconds);
</pre>
<p>该调用返回不睡眠的秒数。就是说，成功的调用返回0，但该函数可能返回介于0到包括seconds之间的值（如果说，一个信号打断了这次小觉）。函数不会设置errno。大多数sleep()的用户不会关心进程实际上睡眠了多久，因而接下来就不检查返回值了。
</p>
<pre>sleep (7); /* sleep seven seconds */
</pre>
<p>如果真的关心睡眠整段指定时间的话，你可以用返回值来继续调用sleep()，直到为0。
</p>
<pre>unsigned int s = 5;

/* sleep five seconds: no ifs, ands, or buts about it */
while ((s = sleep (s)))
	;
</pre>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../%E7%8E%8B/%E6%BE%8D/%E7%89%88/%E7%8E%8B%E6%BE%8D%E7%89%88.html" title="王澍版">编辑</a>]</div><a name=".E5.BE.AE.E7.A7.92.E7.BA.A7.E7.B2.BE.E5.BA.A6.E7.9D.A1.E7.9C.A0"></a><h3>微秒级精度睡眠</h3>
<p>整秒整秒的睡眠实在是太死板了。在一个现代操作系统上一秒钟简直就是永恒，所以程序经常需要在更细层次的精度下睡眠。使用usleep()：
</p>
<pre>/* BSD version */
#include &lt;unistd.h&gt;

void usleep (unsigned long usec);
 
/* SUSv2 version */
#define _XOPEN_SOURCE 500
#include &lt;unistd.h&gt;
 
int usleep (useconds_t usec);
</pre>
<p>一个成功的usleep()调用使发起进程睡眠usec微秒。不幸的是，BSD和Single UNIX Specification（单一UNIX规范）在该原型上有不同意见。BSD版本接受一个无符号长整型，并且没有返回值。然而SUS版本定义usleep()接受一个useconds_t类型，并返回一个整型。如果XOPEN_SOURCE定义为500或者更大的值，Linux就和SUS一样。如果XOPEN_SOURCE未定义，或者设定值小于500，Linux就和BSD一样。
</p><p>SUS版本在成功时返回0，出错时返回-1。合法的errno值有表示睡眠被信号打断时的EINTR，或者由于usecs太大而导致的EINVAL（在Linux上，该类型的整个范围都是合法的，这样该错误就永不出现）。
</p><p>根据特定值，useconds_t类型是能满足最大值为1,000,000的无符号整型。
</p><p>由于不同原型之间的冲突，以及部分Unix系统可能只支持一种，而不是两者，不只在你的代码中包括useconds_t类型是明智的。为尽可能满足可移植性，最好假设参数是无符号整型，并且不要依赖于usleep()的返回值：
</p>
<pre>void usleep (unsigned int usec);
</pre>
<p>用法就是：
</p>
<pre>unsigned int usecs = 200;

usleep (usecs);
</pre>
<p>这样就可以满足任一版本的函数，如果可能的话检查错误：
</p>
<pre>errno = 0;
usleep (1000);
if (errno)
	perror ("usleep");
</pre>
<p>然而大多数程序不检查或者关心usleep()的错误。
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../%E7%8E%8B/%E6%BE%8D/%E7%89%88/%E7%8E%8B%E6%BE%8D%E7%89%88.html" title="王澍版">编辑</a>]</div><a name=".E7.BA.B3.E7.A7.92.E7.BA.A7.E7.B2.BE.E5.BA.A6.E7.9D.A1.E7.9C.A0"></a><h3>纳秒级精度睡眠</h3>
<p>Linux反对使用usllep()函数，取而代之以nanosleep()，一个更加聪明，提供纳秒级精度的接口：
</p>
<pre>#define _POSIX_C_SOURCE 199309
#include &lt;time.h&gt;

int nanosleep (const struct timespec *req,
		struct timespec *rem);
</pre>
<p>一个成功的nanosleep()调用使发起进程睡眠req指定的时间，并返回0。错误时，调用返回-1，并设置errno为相应值。如果一个信号打断了睡眠，调用可在指定时间消耗完之前返回。在这种情况下，nanosleep()返回-1，并设置errno为EINTR。如果rem不是NULL，函数把剩余睡眠时间（req中没有睡眠的值）放到rem中。程序然后将重起调用，将rem作参数传递给req（像本节之后所示）。
</p><p>下面是其他errno值：
</p><p>EFAULT
</p><p>req或者rem不是合法指针。
</p><p>EINVAL
</p><p>req中一个字段非法。
</p><p><br />
</p><p>在一般情况下，用法很简单：
</p><p><br />
</p>
<pre>struct timespec req = { .tv_sec = 0,
			.tv_nsec = 200 };

/* sleep for 200 ns */
ret = nanosleep (&amp;req, NULL);
if (ret)
	perror ("nanosleep");
</pre>
<p><br />
</p><p>下面是当睡眠被打断时使用第二个参数来继续的例子：
</p>
<pre>struct timespec req = { .tv_sec = 0,
			.tv_nsec = 1369 };
struct timespec rem;
int ret;
 
/* sleep for 1369 ns */
retry:
ret = nanosleep (&amp;req, &amp;rem);
if (ret) {
	if (errno == EINTR) {
		/* retry, with the provided time remaining */
		req.tv_sec = rem.tv_sec;
		req.tv_nsec = rem.tv_nsec;
		goto retry;
	}
	perror ("nanosleep");
}
</pre>
<p>最后，下面是另外一种方法（可能更加有效，但可读性较差）来实现同一个目标：
</p>
<pre>struct timespec req = { .tv_sec = 1,
			.tv_nsec = 0 };
struct timespec rem, *a = &amp;req, *b = &amp;rem;

/* sleep for 1s */
while (nanosleep (a, b) &amp;&amp; errno == EINTR) {
 	struct timespec *tmp = a;
 	a = b;
	b = tmp;
}
</pre>
<p>nanosleep()相比于sleep()和usleep()有几个优点：
</p><p>•纳秒级精度和秒或者微秒的对比。
</p><p>•由POSIX.1b标准化。
</p><p>•不是用信号来实现（该方法的缺陷将在之后讨论）
</p><p>尽管有反对之声，很多程序仍然倾向于使用usleep()而不是nanosleep()——还好，至少越来越少的程序在使用sleep()。因为nanosleep()是POSIX标准，并且不使用信号，新程序应该使用它（或者将在下一节讨论的接口）而不是sleep()或者usleep()。
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../%E7%8E%8B/%E6%BE%8D/%E7%89%88/%E7%8E%8B%E6%BE%8D%E7%89%88.html" title="王澍版">编辑</a>]</div><a name=".E4.B8.80.E4.B8.AA.E9.AB.98.E7.BA.A7.E7.9A.84.E7.9D.A1.E7.9C.A0.E6.96.B9.E6.B3.95"></a><h3>一个高级的睡眠方法</h3>
<p>我们已经见识过了所有的时间类函数，POSIX时钟类还提供了最高级的睡眠接口：
</p>
<pre>#include &lt;time.h&gt;

int clock_nanosleep (clockid_t clock_id,
			int flags,
			const struct timespec *req,
			struct timespec *rem);
</pre>
<p>clock_nanosleep()的行为类似于nanosleep()。实际上，这个调用：
</p>
<pre>ret = nanosleep (&amp;req, &amp;rem);
</pre>
<p>等价于这个调用：
</p>
<pre>ret = clock_nanosleep (CLOCK_REALTIME, 0, &amp;req, &amp;rem);
</pre>
<p>差别在于clock_id和flags参数。前者指定了用来衡量的时间源。大部分时间源都是合法的，尽管你不能指定发起进程的CPU时钟（e.g.，CLOCK_PROCESS_CPUTIME_ID）；这样做没有任何意义，因为调用将使进程搁置，这样进程时间将停止增长。
</p><p>你指定哪个时间源取决于你程序为什么要睡眠。如果你想要睡眠到某个绝对时间值，CLOCK_REALTIME大概是最好的选择。如果你准备睡眠某个相对值的时间，CLOCK_MONITONIC绝对是理想的时间源。
</p><p>flags参数是TIMER_ABSTIME或者0。如果是TIMER_ABSTIME，由req指定的值将被视为绝对的，而非相对的。这解决了一个潜在的竞争条件。为了解释该参数的值，假设一个进程，出于时间T0，想要睡眠到时间T1。在T0时，进程调用了clock_gettime()来取得当前时间（T0）。然后从T1中减去T0，得到Y，来传递给clock_nanosleep()。然而在取得时间和进程进入睡眠之间，已经有一些时间过去了。更糟糕的是，what if the process was scheduled off the processor，导致一个页错误，或者类似的事情怎么办？在取得当前时间，计算时间差，以及实际睡眠之间总是存在着竞争条件的。
</p><p><br />
TIMER_ABSTIME标志通过允许进程直接指定T1从而去除了该竞争。内核挂起该进程知道指定时间源到达T1。如果指定时间源的当前时间已经超过T1，调用立即返回&gt;。
</p><p>让我们看看相对和绝对睡眠二者。下面的例子是睡眠1.5秒钟：
</p>
<pre>struct timespec ts = { .tv_sec = 1, .tv_nsec = 500000000 };
int ret;

ret = clock_nanosleep (CLOCK_MONOTONIC, 0, &amp;ts, NULL);
if (ret)
	perror ("clock_nanosleep");
</pre>
<p>相反的，下面的例子睡眠直到某个绝对时间——这里是clock_gettime()调用返回CLOCK_MONOTONIC时间源之后精确的一秒钟——到来的时候。
</p>
<pre>struct timespec ts; 
int ret;

/* we want to sleep until one second from NOW */
ret = clock_gettime (CLOCK_MONOTONIC, &amp;ts);
if (ret) {
	perror ("clock_gettime");
	return;
}

ts.tv_sec += 1;
printf ("We want to sleep until sec=%ld nsec=%ld\n",
	ts.tv_sec, ts.tv_nsec);
ret = clock_nanosleep (CLOCK_MONOTONIC, TIMER_ABSTIME,
			&amp;ts, NULL);
if (ret)
	perror ("clock_nanosleep");
</pre>
<p>大多数程序只需要一个相对的睡眠，因为他们的睡眠并不十分严格。然而某些实时进程，对时间要求相当严格，并且需要绝对的睡眠来避免潜在具有破坏性的竞争
条件的危险。
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../%E7%8E%8B/%E6%BE%8D/%E7%89%88/%E7%8E%8B%E6%BE%8D%E7%89%88.html" title="王澍版">编辑</a>]</div><a name=".E5.8F.AF.E7.A7.BB.E6.A4.8D.E7.9D.A1.E7.9C.A0"></a><h3>可移植睡眠</h3> 
<p>回忆第二章中我们的朋友select()：
</p>
<pre>#include &lt;sys/select.h&gt;

int select (int n,
	     fd_set *readfds,
	     fd_set *writefds,
	     fd_set *exceptfds,
	     struct timeval *timeout);
</pre>
<p>像在那一章提到的那样，select()提供了一个亚秒级的可移植睡眠。在很长一段时间内，可移植的Unix程序总在短暂的睡眠需求上和sleep()纠缠不清：usleep()&gt;不是广泛可用的，而nanosleep()那时还不可写入。开发者发现给select()的n传递0，给所有三个fd_set指针传递NULL，以及把需要睡眠的时间给timeout，就产生
了一种可移植且有效的方法让进程睡眠：
</p>
<pre>struct timeval tv = { .tv_sec = 0,
			.tv_usec = 757 };
</pre>
<pre>/* sleep for 757 us */
select (0, NULL, NULL, NULL, &amp;tv);
</pre>
<p>如果需要考虑旧一些的Unix系统的可移植性，使用select()可能是你最好的办法。
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../%E7%8E%8B/%E6%BE%8D/%E7%89%88/%E7%8E%8B%E6%BE%8D%E7%89%88.html" title="王澍版">编辑</a>]</div><a name="overruns"></a><h3>overruns</h3>
<p>本节讨论的所有接口都保证能睡眠至少要求的那么长时间（否则返回错误来表示其他情况）。它们不到要求逝去的时间之前绝不返回。然而可能，会比所要求的更
长些。
</p><p>这种现象可以归咎于简单的调度行为——要求的时间可能已经过去了，而内核可能会及时唤醒进程，但调度器可能会选择另外一个人物来运行。
</p><p>然而这里有一个更加隐蔽的根源：timer overruns。当计时器的度量单位比要求的时间间隔大时就会发生。举例来说，假设系统计时器每10毫秒一次滴答，而进程
要求1毫秒的睡眠。系统只能在10毫秒的精度下测量并响应时间相关的事件（像把进程从睡眠中唤醒）。如果当进程发起睡眠请求时，计时器距离下次滴答还有1毫
秒，一切都将正常——在1毫秒内，请求的时间（1毫秒）将会逝去，而内核将唤醒进程。然而，如果计时器在进程请求睡眠时刚好到一个滴答，就没有下一个10毫秒
的滴答了。接下来，进程将会多睡眠9毫秒！就是说，会有九个1毫秒的overrun。平均来说，一个有X度量单位的计时器会有X/2的overrun比率。
</p><p>使用高精度的时间源，像POSIX时钟提供的那些，以及较高的HZ值，可以减少timer overrun。
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../%E7%8E%8B/%E6%BE%8D/%E7%89%88/%E7%8E%8B%E6%BE%8D%E7%89%88.html" title="王澍版">编辑</a>]</div><a name=".E6.9B.BF.E4.BB.A3.E7.9D.A1.E7.9C.A0"></a><h3>替代睡眠</h3>
<p>如果可能的话，你应该避免睡眠。通常来说你不能如此，但也问题不大——特别是当你的代码只睡少于一秒钟。然而充斥着睡眠的代码，为了“忙碌等待”事件，一般就成了糟糕的设计。能在文件描述符上阻塞的代码，允许内核来处理睡眠和唤醒进程，是比较好的。内核能够让进程从运行转到阻塞，并只在需要时唤醒它，而不是让进程为了等待事件触发而在循环中徘徊。
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../%E7%8E%8B/%E6%BE%8D/%E7%89%88/%E7%8E%8B%E6%BE%8D%E7%89%88.html" title="王澍版">编辑</a>]</div><a name=".E8.AE.A1.E6.97.B6.E5.99.A8"></a><h2>计时器</h2>
<p>计时器提供了当一定时间过去后通知进程的机制。计时器在expire前的时间叫做延迟（delay），或者expiration。内核如何通知进程计时器已经expire取决于该计时器。Linux内核提供了几种类型。我们将学习所有的。
</p><p>有一些理由表明计时器很有用。例子包括每秒60次刷新屏幕，或者当某个处理过程运行超过了500毫秒时取消它。
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../%E7%8E%8B/%E6%BE%8D/%E7%89%88/%E7%8E%8B%E6%BE%8D%E7%89%88.html" title="王澍版">编辑</a>]</div><a name=".E7.AE.80.E5.8D.95.E7.9A.84.E9.97.B9.E9.92.9F"></a><h3>简单的闹钟</h3>
<p>alarm()是最简单的计时器接口：
</p>
<pre>#include &lt;unistd.h&gt;

unsigned int alarm (unsigned int seconds);
</pre>
<p>一个该函数的调用计划在seconds秒的真实事件过去后将SIGALRM信号发给发起进程。如果先前预定的信号挂起了，调用就取消该闹钟，用新请求的取代，并返回先前闹钟剩余的秒数。如果seconds是0，如果有先前的闹钟，就取消掉，但不设置新的闹钟。
</p><p>此函数的成功使用也需要为SIGALRM信号注册一个信号处理程序。（信号和信号处理程序的内容在前一章。）下面的代码段注册了一个SIGALRM处理程序，alarm_handler()，并设置了一个五秒钟的闹钟：
</p>
<pre>void alarm_handler (int signum)
{
	printf ("Five seconds passed!\n");
}

void func (void)
{
	signal (SIGALRM, alarm_handler);
	alarm (5);

	pause ( );
}
</pre>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../%E7%8E%8B/%E6%BE%8D/%E7%89%88/%E7%8E%8B%E6%BE%8D%E7%89%88.html" title="王澍版">编辑</a>]</div><a name="Interval_Timers"></a><h3>Interval Timers</h3>
<p>interval timer系统调用，最早出现在4.2BSD中，已经由POSIX标准化，并且比alarm()提供更多的控制。
</p>
<pre>#include &lt;sys/time.h&gt;

int getitimer (int which,
struct itimerval *value);

int setitimer (int which,
		const struct itimerval *value,
		struct itimerval *ovalue);
</pre>
<p>interval timers像alarm()那样操作，但可选的，能够自动rearm它们自身，并在三个独有的模式之一下操作：
</p><p>ITIMER_REAL
</p><p>衡量真实事件。当指定量的真实时间过去后，内核将SIGALRM信号发给进程。
</p><p>ITIMER_VIRTUAL
</p><p>只在进程用户空间的代码执行时减少。当指定量的进程时间过去后，内核将SIGVTALRM发给进程。
</p><p>ITIMER_PROF
</p><p>在进程执行以及内核为该进程而运行时（像完成一个系统调用）都减少。当指定量的时间过去后，内核将SIGPROF信号发给进程。这个模式一般和ITIMER_VIRTUAL共用，这样程序就能衡量进程消耗的用户和内核时间。
</p><p>ITIMER_REAL衡量的时间和alarm()相同；另外两个模式对于测评很有用。
</p><p>ttimeval结构体允许用户指定时间的长度直到计时器expire，以及expiration.......
</p>
<pre>struct itimerval {
	struct timeval it_interval; /* next value */
	struct timeval it_value; /* current value */
};
</pre>
<p>回忆先前的timeval结构体提供微秒级精度：
</p>
<pre>struct timeval {
	long tv_sec; /* seconds */
	long tv_usec; /* microseconds */
};
</pre>
<p>settimer()......
</p><p>如果ovalue不是NULL......
</p><p>getitimer()返回......
</p><p>两个函数在成功时都返回0，并在出错时返回-1，设置errno为下列值之一：
</p><p>EFAULT
</p><p>value或者ovalue不是合法指针。
</p><p>EINVAL
</p><p>which不是合法的interval timer类型。
</p><p>下面的代码段创建了一个SIGALRM信号处理程序（又一次，参见第九章），......
</p>
<pre>void alarm_handler (int signo)
{
	printf ("Timer hit!\n");
}

void foo (void) {
	struct itimerval delay;
	int ret;

	signal (SIGALRM, alarm_handler);

	delay.it_value.tv_sec = 5;
	delay.it_value.tv_usec = 0;
	delay.it_interval.tv_sec = 1;
	delay.it_interval.tv_usec = 0;
	ret = setitimer (ITIMER_REAL, &amp;delay, NULL);
	if (ret) {
		perror ("setitimer");
		return;
	}

	pause ( );
}
</pre>
<p>一些Unix系统通过SIGALRM实现了sleep()和usleep()——而很明显的，alarm()和setitimer()使用了SIGALRM。因而，程序员必须十分小心不要重复调用这些函数；结果是未定义的。要是需要短暂的等待，程序员应该使用POSIX保证不会使用信号的nanosleep()。如果需要计时器，程序员应该使用setitimer()或者alarm()。
</p><p><br />
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../%E7%8E%8B/%E6%BE%8D/%E7%89%88/%E7%8E%8B%E6%BE%8D%E7%89%88.html" title="王澍版">编辑</a>]</div><a name=".E9.AB.98.E7.BA.A7.E8.AE.A1.E6.97.B6.E5.99.A8"></a><h3>高级计时器</h3>
<p>最强大的计时器接口，毫无疑问，来自于POSIX时钟家族。
</p><p>使用POSIX中基于时钟的计时器，建立一个实例，初始化以及最终删除计时器的动作被分隔成三个不同的函数：timer_create()建立计时器，timer_settime()初始化计时器，timer_delete()则销毁它。
</p><p>^^^^^^POSIX时钟家族的计时器接口毫无疑问是最先进的，但也是最新的（因而可移植性最差），同时是最不易使用的。如果简洁性或者可移植性是要优先考虑的，那么setitimer()大概是更好的选择。
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../%E7%8E%8B/%E6%BE%8D/%E7%89%88/%E7%8E%8B%E6%BE%8D%E7%89%88.html" title="王澍版">编辑</a>]</div><a name=".E5.BB.BA.E7.AB.8B.E4.B8.80.E4.B8.AA.E8.AE.A1.E6.97.B6.E5.99.A8"></a><h4>建立一个计时器</h4>
<p>使用timer_create()建立一个计时器：
</p>
<pre>#include &lt;signal.h&gt;
#include &lt;time.h&gt;

int timer_create (clockid_t clockid,
		   struct sigevent *evp,
		   timer_t *timerid);
</pre>
<p>一个成功的timer_create()调用建立一个与POSIX时钟clockid相关联的新计时器，在timerid中存储一个唯一的计时器标记，并返回0。该调用很少设置计时器运行的条件；在计时器设置之前实际上什么都没有发生，就像在下一节将要看到的那样。
</p><p>下面的例子建立了一个新的计时器来切断POSIX时钟CLOCK_PROCESS_CPUTIME_ID，并将计时器ID存储到timer中。
</p>
<pre>timer_t timer;
int ret;

ret = timer_create (CLOCK_PROCESS_CPUTIME_ID,
		     NULL,
		     &amp;timer);
if (ret)
	perror ("timer_create");
</pre>
<p>失败时，调用返回-1，timerid则未定义，调用设置errno为下列值之一：
</p><p>EAGAIN
</p><p>系统缺少足够的资源来完成请求。
</p><p>EINVAL
</p><p>clockid指定的POSIX时钟是非法的。
</p><p>ENOTSUP
</p><p>clockid指定的POSIX时钟合法，但是系统不支持使用该时钟作为计时器。POSIX保证所有实现支持CLOCK_REALTIME时钟作为计时器。其它的时钟能否支持依赖于实现。
</p><p>如果evp参数不是NULL，定义了当计时器expire时的异步通知。头文件&lt;signal.h&gt;定义了该结构体。它的内容对程序员来说是不可见的，但至少包含以下字段：
</p>
<pre>#include &lt;signal.h&gt;

struct sigevent {
	union sigval sigev_value;
	int sigev_signo;
		int sigev_notify;
	void (*sigev_notify_function)(union sigval);
	pthread_attr_t *sigev_notify_attributes;
};

union sigval {
	int sival_int;
	void *sival_ptr;
};
</pre>
<p>POSIX基于时钟的计时器在计时器expire时，关于内核如何通知进程上有更多的控制能力，允许进程指定内核将发送的是哪个信号，甚至让内核产生一个新线程，通过执行某个函数响应计时器的expiration。一个进程在计时器expiration时的行为通过sigev_notify来指定，必须是以下三个值之一：
</p><p>SIGEV_NONE
</p><p>一个“空的”通知。当计时器expiration时，什么都不发生。
</p><p>SIGEV_SIGNAL
</p><p>当计时器expiration时，内核给进程发送一个由sigev_signo指定的信号。在信号处理程序中，si_value被设置为sigev_value。
</p><p>SIGEV_THREAD
</p><p>当计时器expiration时，内核产生一个新线程（在该进程内），并让其执行sigev_notify_function，传递sigev_value为它唯一的参数。该线程在这个函数返回时终止。如果sigev_notify_attributes不是NULL，提供的pthread_attr_t结构体定义了新线程的行为。
</p><p>如果evp不是NULL，就像在我们先前的例子中那样，建立计时器的expiration通知就像sigev_notify是SIGEV_SIGNAL，sigev_signo是SIGALRM，sigev_value是计时器ID一样。就是说，默认状况下，这些计时器像POSIX interval timers那样通知。然而通过自定义方式，它们能做更多更多的工作！
</p><p>下面的例子建立了一个计时器切断CLOCK_REALTIME。当计时expire，内核发出SIGUSR1信号，并把si_value设置成计时器ID中存储的地址值：
</p>
<pre>struct sigevent evp;
timer_t timer;
int ret;

evp.sigev_value.sival_ptr = &amp;timer;
evp.sigev_notify = SIGEV_SIGNAL;
evp.sigev_signo = SIGUSR1;
ret = timer_create (CLOCK_REALTIME,
		     &amp;evp,
		     &amp;timer);
if (ret)
	perror ("timer_create");
</pre>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../%E7%8E%8B/%E6%BE%8D/%E7%89%88/%E7%8E%8B%E6%BE%8D%E7%89%88.html" title="王澍版">编辑</a>]</div><a name=".E8.AE.BE.E7.BD.AE.E8.AE.A1.E6.97.B6.E5.99.A8"></a><h4>设置计时器</h4>
<p>由timer_create()建立的计时器是未设置的。为了将其与一个expiration关联并开始时钟滴答，可以使用timer_settime()：
</p>
<pre>#include &lt;time.h&gt;

int timer_settime (timer_t timerid,
		    int flags,
		    const struct itimerspec *value,
		    struct itimerspec *ovalue);
</pre>
<p>一个成功的timer_settime()调用将设置timerid指定的计时器,采用itimerspec结构体的value expiration。
</p>
<pre>struct itimerspec {
	struct timespec it_interval; /* next value */
	struct timespec it_value; /* current value */
};
</pre>
<p>像setitimer()一样，it_value指定了当前计时器expiration。当计时器expire，将用it_interval的值更新it_value。如果it_interval是0，计时器就不是interval 计时器，并在it_value expire后废弃。
</p><p>回忆之前的timespec结构体能提供纳秒级精度：
</p>
<pre>struct timespec {
	time_t tv_sec; /* seconds */
	long tv_nsec; /* nanoseconds */
};
</pre>
<p>如果flags是TIMER_ABSTIME，value指定的时间就解释为绝对的（和相对于当前时间值的默认解释相反）。这个改正的行为可以阻止竞争条件，该竞争条件在取得当前时间，计算和预定时间的差值，确定一个未来时间点，以及设置计时器时产生。参见先前一节“一个高级的睡眠方法”中的讨论细节。
</p><p>如果ovalue不是NULL，先前计时器的expiration将存储在提供的itimerspec中。如果计时器之前是未设置的，结构体的成员将全部设置为0。
</p><p>使用timer值来初始化timer_create()先前的结果，下面的代码建立了一个每秒都expire的周期计时器：
</p>
<pre>struct itimerspec ts;
int ret;

ts.it_interval.tv_sec = 1;
ts.it_interval.tv_nsec = 0;
ts.it_value.tv_sec = 1;
ts.it_value.tv_nsec = 0;

ret = timer_settime (timer, 0, &amp;ts, NULL);
if (ret)
	perror ("timer_settime");
</pre>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../%E7%8E%8B/%E6%BE%8D/%E7%89%88/%E7%8E%8B%E6%BE%8D%E7%89%88.html" title="王澍版">编辑</a>]</div><a name=".E5.8F.96.E5.BE.97.E8.AE.A1.E6.97.B6.E5.99.A8.E7.9A.84expiration"></a><h4>取得计时器的expiration</h4>
<p>你可以在任何时刻取得一个计时器的expiration时间而不必重设置它，使用timer_gettime()：
</p>
<pre>#include &lt;time.h&gt;

int timer_gettime (timer_t timerid,
struct itimerspec *value);
</pre>
<p>一个成功的timer_gettime()调用将timerid指定的计时器expiration时间存储到value指向的结构体中，并返回0。失败时，调用返回-1，并设置errno为下列值之一：
</p><p>EFAULT
</p><p>value不是合法指针。
</p><p>EINVAL
</p><p>timerid不是合法计时器。
</p><p>看个例子：
</p>
<pre>struct itimerspec ts;
int ret;

ret = timer_gettime (timer, &amp;ts);
if (ret)
	perror ("timer_gettime");
else {
	printf ("current sec=%ld nsec=%ld\n",
	ts.it_value.tv_sec, ts.it_value.tv_nsec);
	printf ("next sec=%ld nsec=%ld\n",
	ts.it_interval.tv_sec, ts.it_interval.tv_nsec);
}
</pre>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../%E7%8E%8B/%E6%BE%8D/%E7%89%88/%E7%8E%8B%E6%BE%8D%E7%89%88.html" title="王澍版">编辑</a>]</div><a name=".E5.8F.96.E5.BE.97.E8.AE.A1.E6.97.B6.E5.99.A8.E7.9A.84overrun"></a><h4>取得计时器的overrun</h4>
<p>POSIX定义了一个接口来确定一个给定计时器有多少overrun，如果有的话：
</p>
<pre>#include &lt;time.h&gt;

int timer_getoverrun (timer_t timerid);
</pre>
<p>成功时，timer_getoverrun()返回在计时器预定的expiration和实际计时器expire后通知进程时——举个例子，通过信号——之间额外的expiration值，比方说，在我们先前的例子中，一个1毫秒的计时器跑了10毫秒，调用就会返回9。
</p><p>如果overrun的数量大于等于DELAYTIMER_MAX，调用就返回DELAYTIMER_MAX。
</p><p>失败时，该函数返回-1，并设置errno为EINVAL，这个唯一的错误表明由timerid指定的计时器不合法。
</p><p>看个例子：
</p>
<pre>int ret;

ret = timer_getoverrun (timer);
if (ret == -1)
	perror ("timer_getoverrun");
else if (ret == 0)
	printf ("no overrun\n");
else
	printf ("%d overrun(s)\n", ret);
</pre>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../%E7%8E%8B/%E6%BE%8D/%E7%89%88/%E7%8E%8B%E6%BE%8D%E7%89%88.html" title="王澍版">编辑</a>]</div><a name=".E5.88.A0.E9.99.A4.E8.AE.A1.E6.97.B6.E5.99.A8"></a><h4>删除计时器</h4>
<p>删除一个计时器很简单：
</p>
<pre>#include &lt;time.h&gt;

int timer_delete (timer_t timerid);
</pre>
<p>一个成功的timer_delete()调用销毁由timerid指定的计时器，并返回0。失败时，调用返回-1，并设置errno为EINVAL，这个唯一的错误表明timerid不是合法的计时器。
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../%E7%8E%8B/%E6%BE%8D/%E7%89%88/%E7%8E%8B%E6%BE%8D%E7%89%88.html" title="王澍版">编辑</a>]</div><a name=".E5.8E.9F.E6.B3.A8.EF.BC.9A"></a><h2>原注：</h2>
<ol><li>jiffies on 2.6 Kernel： Linux内核的未来版本可能会是“无滴答”的，或者会实现“动态滴答”，即内核不会记录一个显式的滴答值。这样所有基于时间的内核操作将伴随动态建立的计时器执行，而不是系统计时器
</li><li>Given the choice, interfaces prefer nanosecond to microsecond resolution.     而且，timespec结构抛弃了傻B的suseconds_t那一套，钟情于简单含蓄的长整型。
</li></ol>
<p><br />
†HZ现在是内核编译期的可选项，在x86架构上值可以是100、250和1000。与此无关的是，用户空间不能依赖于任何特定的HZ值。
</p>
<div class="printfooter">
<p>取自"<a href="http://dns.cs.hit.edu.cn../../../%E7%8E%8B/%E6%BE%8D/%E7%89%88/%E7%8E%8B%E6%BE%8D%E7%89%88.html">http://dns.cs.hit.edu.cn../../../%E7%8E%8B/%E6%BE%8D/%E7%89%88/%E7%8E%8B%E6%BE%8D%E7%89%88.html</a>"</p>

<p>本页面已经被浏览95次。 This page was last modified 04:50 2009年3月10日 by <a href="../../../h/a/l/User%7EHalfelf.html" title="User:Halfelf">王澍</a>.  </p>
</div>

</div><br style="clear:both" />

<div id='footer'><table border="0" cellspacing="0"><tr><td width='152' rowspan='1'>&nbsp;</td><td class='bottom' align='left' valign='top'><strong><a href="../../../%E7%8E%8B/%E6%BE%8D/%E7%89%88/%E7%8E%8B%E6%BE%8D%E7%89%88.html" title="王澍版">编辑本页</a></strong> |
<a href="../../../%E7%8E%8B/%E6%BE%8D/%E7%89%88/Talk%7E%E7%8E%8B%E6%BE%8D%E7%89%88.html" class="new" title="Talk:王澍版">讨论本页</a> |
<a href="../../../%E7%8E%8B/%E6%BE%8D/%E7%89%88/%E7%8E%8B%E6%BE%8D%E7%89%88.html" title="王澍版">较早版本</a> |
<a href="../../../w/h/a/Special%7EWhatlinkshere.html" title="Special:Whatlinkshere">链入页面</a> |
<a href="../../../r/e/c/Special%7ERecentchangeslinked.html" title="Special:Recentchangeslinked">链出更改</a>
<br /><br />

<br /><a href="../../../index.html" title="首页">首页</a> | <a href="../../../w/i/k/Wikipedia%7E%E5%85%B3%E4%BA%8E.html" title="Wikipedia:关于">关于Wikipedia</a> | <a href="../../../r/e/c/Special%7ERecentchanges.html" title="Special:Recentchanges">最近更改</a> | <form name="search" class="inline" method="post" action="../../../s/e/a/Special%7ESearch.html">
<input type="text" name="search" size="19" value="" />
<input type="submit" name="go" value="进入" />&nbsp;<input type="submit" name="fulltext" value="搜索" />
</form><br /><span id="pagestats">本页面已经被浏览95次。 This page was last modified 04:50 2009年3月10日 by <a href="../../../h/a/l/User%7EHalfelf.html" title="User:Halfelf">王澍</a>.  </span></td></tr></table>
</div>
</div>

<div id='quickbar'>
<a href='../../../index.html'><img src='../../../../skins/common/images/wiki.jpg' alt='[首页]' /></a>
<hr class='sep' /><a href="../../../index.html">首页</a>
<br /><a href="../../../c/o/m/WIKI-HIT_IBM_CLUB%7ECommunity_Portal_9150.html">社区</a>
<br /><a href="../../../c/u/r/Current_events.html">新闻动态</a>
<br /><a href="../../../r/e/c/Special%7ERecentchanges.html">最近更改</a>
<br /><a href="../../../r/a/n/Special%7ERandom.html">随机页面</a>
<br /><a href="../../../w/i/k/Wikipedia%7E%E5%B8%AE%E5%8A%A9.html">帮助</a>
<br /><a href="../../../s/i/t/WIKI-HIT_IBM_CLUB%7ESite_support.html">Donations</a>
<br />
<hr class='sep' /><strong><a href="../../../%E7%8E%8B/%E6%BE%8D/%E7%89%88/%E7%8E%8B%E6%BE%8D%E7%89%88.html" title="王澍版">编辑本页</a></strong>
<br /><a href="../../../%E7%8E%8B/%E6%BE%8D/%E7%89%88/Talk%7E%E7%8E%8B%E6%BE%8D%E7%89%88.html" class="new" title="Talk:王澍版">讨论本页</a>
<br /><a href="../../../%E7%8E%8B/%E6%BE%8D/%E7%89%88/%E7%8E%8B%E6%BE%8D%E7%89%88.html" title="王澍版">较早版本</a>
<br /><a href="../../../w/h/a/Special%7EWhatlinkshere.html" title="Special:Whatlinkshere">链入页面</a>
<br /><a href="../../../r/e/c/Special%7ERecentchangeslinked.html" title="Special:Recentchangeslinked">链出更改</a>
<br /><hr class='sep' /><a href="../../../s/p/e/Special%7ESpecialpages.html" title="Special:Specialpages">特殊页面</a>
<br /><a href="../../../w/i/k/Wikipedia%7E%E9%94%99%E8%AF%AF%E6%8A%A5%E5%91%8A.html" title="Wikipedia:错误报告">错误报告</a>
<br /></div>
<!-- Served by dns.cs.hit.edu.cn in 1351393283.78 secs. -->
</body></html>