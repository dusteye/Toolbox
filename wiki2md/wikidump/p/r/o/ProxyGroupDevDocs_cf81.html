<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh-cn" lang="zh-cn" >
<head>
<title>ProxyGroupDevDocs - WIKI-HIT IBM CLUB</title>
<meta name="KEYWORDS" content="首页,ALP,Address,Android,Android Newbie Guide,Android Project Development,Android Research Field,Android Third Party Lib And Tool,BoardGame,CSAPP" />
<meta http-equiv="Content-type" content="text/html; charset=UTF-8" />
<meta name="robots" content="index,follow" />
<link rel="shortcut icon" href="/favicon.ico" />
<link rel='stylesheet' type='text/css' media='print' href='../../../../skins/common/wikiprintable.css' />
<script type="text/javascript" src="../../../../skins/common/wikibits.js"></script>
<style type='text/css'>
/*/*/ /*<![CDATA[*/
@import "../../../../skins/common/wikistandard.css";
@import "../../../s/t/a/MediaWiki%7EStandard.css.html";
a.new, #quickbar a.new { color: #CC2200; }
.editsection { display: none; }
#quickbar { position: absolute; top: 4px; left: 4px; border-right: 1px solid gray; }
#article { margin-left: 152px; margin-right: 4px; }

/*]]>*/ /* */
</style>
</head>

<body bgcolor='#FFFFFF' onload=''>

<div id='content'>
<div id='topbar'>
<table border='0' cellspacing='0' width='98%'>
<tr>
<td width='152' rowspan='1'>&nbsp;</td><td class="top" align='left' valign='top'>
<a href="../../../index.html" title="首页">首页</a> |
<a href="../../../r/e/c/Special%7ERecentchanges.html" title="Special:Recentchanges">最近更改</a> |
<a href="../../../p/r/o/ProxyGroupDevDocs_cf81.html" title="ProxyGroupDevDocs">编辑本页</a> |
<a href="../../../p/r/o/ProxyGroupDevDocs_cf81.html" title="ProxyGroupDevDocs">较早版本</a><p class='subtitle'><a href="../../../p/r/o/ProxyGroupDevDocs_cf81.html">可打印版</a> | <a href="../../../g/e/n/WIKI-HIT_IBM_CLUB%7EGeneral_disclaimer.html" title="WIKI-HIT IBM CLUB:General disclaimer">Disclaimers</a></p>
</td>
<td class="top" valign='top' align='right' nowrap='nowrap'>Not logged in
<br /><a href="../../../u/s/e/Special%7EUserlogin.html" title="Special:Userlogin">登录</a> | <a href="../../../w/i/k/Wikipedia%7E%E5%B8%AE%E5%8A%A9.html" title="Wikipedia:帮助">帮助</a>
<br /><form name="search" class="inline" method="post" action="../../../s/e/a/Special%7ESearch.html">
<input type="text" name="search" size="19" value="" />
<input type="submit" name="go" value="进入" />&nbsp;<input type="submit" name="fulltext" value="搜索" />
</form></td></tr>
</table>
</div>

<div id='article'>
<h1 class="pagetitle">ProxyGroupDevDocs</h1><p class='subtitle'>Wikipedia，自由的百科全书</p>
<table id='toc' class='toc'><tr><td><div id='toctitle'><h2>目录</h2></div>
<ul>
<li class='toclevel-1'><a href="#To_Do_List"><span class="tocnumber">1</span> <span class="toctext">To Do List</span></a></li>
<li class='toclevel-1'><a href="#.E6.96.87.E6.A1.A3.E5.8C.BA"><span class="tocnumber">2</span> <span class="toctext">文档区</span></a></li>
<li class='toclevel-1'><a href="#The_way_we_reconnect_the_world.21"><span class="tocnumber">3</span> <span class="toctext">The way we reconnect the world!</span></a></li>
<li class='toclevel-1'><a href="#.E9.A1.B9.E7.9B.AE.E7.AE.80.E4.BB.8B_Introduction"><span class="tocnumber">4</span> <span class="toctext">项目简介 Introduction</span></a>
<ul>
<li class='toclevel-2'><a href="#.E9.A1.B9.E7.9B.AE.E8.83.8C.E6.99.AF"><span class="tocnumber">4.1</span> <span class="toctext">项目背景</span></a></li>
<li class='toclevel-2'><a href="#.E9.A1.B9.E7.9B.AE.E7.9B.AE.E6.A0.87"><span class="tocnumber">4.2</span> <span class="toctext">项目目标</span></a></li>
</ul>
</li>
<li class='toclevel-1'><a href="#.E5.85.B3.E4.BA.8E.E6.9C.AC.E6.96.87.E6.A1.A3_About_the_document"><span class="tocnumber">5</span> <span class="toctext">关于本文档 About the document</span></a></li>
<li class='toclevel-1'><a href="#.E4.BB.A3.E7.90.86.E6.9C.8D.E5.8A.A1.E5.99.A8.E5.B7.A5.E4.BD.9C.E6.9C.BA.E5.88.B6_Proxy_Mechanism"><span class="tocnumber">6</span> <span class="toctext">代理服务器工作机制 Proxy Mechanism</span></a>
<ul>
<li class='toclevel-2'><a href="#.E4.B8.BB.E6.A1.86.E6.9E.B6"><span class="tocnumber">6.1</span> <span class="toctext">主框架</span></a>
<ul>
<li class='toclevel-3'><a href="#.E5.8E.9F.E7.90.86_Principle"><span class="tocnumber">6.1.1</span> <span class="toctext">原理 Principle</span></a></li>
<li class='toclevel-3'><a href="#.E5.AE.9E.E7.8E.B0_Implement"><span class="tocnumber">6.1.2</span> <span class="toctext">实现 Implement</span></a></li>
</ul>
</li>
<li class='toclevel-2'><a href="#.E6.9C.8D.E5.8A.A1.E5.99.A8.E5.A4.9A.E7.BA.BF.E7.A8.8B.E9.80.9A.E4.BF.A1"><span class="tocnumber">6.2</span> <span class="toctext">服务器多线程通信</span></a>
<ul>
<li class='toclevel-3'><a href="#.E5.8E.9F.E7.90.86_Principle_2"><span class="tocnumber">6.2.1</span> <span class="toctext">原理 Principle</span></a></li>
<li class='toclevel-3'><a href="#.E5.AE.9E.E7.8E.B0_Implement_2"><span class="tocnumber">6.2.2</span> <span class="toctext">实现 Implement</span></a></li>
<li class='toclevel-3'><a href="#.E5.85.B3.E4.BA.8E.E7.BC.93.E5.86.B2.E5.8C.BA.E9.98.9F.E5.88.97"><span class="tocnumber">6.2.3</span> <span class="toctext">关于缓冲区队列</span></a></li>
<li class='toclevel-3'><a href="#.E5.85.B3.E4.BA.8E.E4.BA.92.E6.96.A5.E8.B5.84.E6.BA.90"><span class="tocnumber">6.2.4</span> <span class="toctext">关于互斥资源</span></a></li>
</ul>
</li>
<li class='toclevel-2'><a href="#.E4.BB.A3.E7.90.86.E8.BA.AB.E4.BB.BD.E8.AE.A4.E8.AF.81"><span class="tocnumber">6.3</span> <span class="toctext">代理身份认证</span></a>
<ul>
<li class='toclevel-3'><a href="#.E5.8E.9F.E7.90.86_Principle_3"><span class="tocnumber">6.3.1</span> <span class="toctext">原理 Principle</span></a></li>
<li class='toclevel-3'><a href="#.E5.AE.9E.E7.8E.B0_Implement_3"><span class="tocnumber">6.3.2</span> <span class="toctext">实现 Implement</span></a></li>
</ul>
</li>
<li class='toclevel-2'><a href="#.E4.BA.8C.E7.BA.A7.E4.BB.A3.E7.90.86.E5.88.97.E8.A1.A8"><span class="tocnumber">6.4</span> <span class="toctext">二级代理列表</span></a>
<ul>
<li class='toclevel-3'><a href="#.E5.8E.9F.E7.90.86_Principle_4"><span class="tocnumber">6.4.1</span> <span class="toctext">原理 Principle</span></a></li>
<li class='toclevel-3'><a href="#.E5.AE.9E.E7.8E.B0_Implement_4"><span class="tocnumber">6.4.2</span> <span class="toctext">实现 Implement</span></a>
<ul>
<li class='toclevel-4'><a href="#.E4.BA.8C.E7.BA.A7.E4.BB.A3.E7.90.86.E5.88.97.E8.A1.A8.E7.9A.84.E7.94.9F.E6.88.90"><span class="tocnumber">6.4.2.1</span> <span class="toctext">二级代理列表的生成</span></a></li>
<li class='toclevel-4'><a href="#.E7.B3.BB.E7.BB.9F.E8.87.AA.E5.8A.A8.E6.8E.A2.E6.B5.8B"><span class="tocnumber">6.4.2.2</span> <span class="toctext">系统自动探测</span></a></li>
<li class='toclevel-4'><a href="#.E6.89.8B.E5.8A.A8.E6.B7.BB.E5.8A.A0"><span class="tocnumber">6.4.2.3</span> <span class="toctext">手动添加</span></a></li>
</ul>
</li>
<li class='toclevel-3'><a href="#.E4.BB.A3.E7.90.86.E6.9C.8D.E5.8A.A1.E5.99.A8.E5.8F.AF.E7.94.A8.E5.88.97.E8.A1.A8.E6.96.87.E4.BB.B6.E6.A0.BC.E5.BC.8F"><span class="tocnumber">6.4.3</span> <span class="toctext">代理服务器可用列表文件格式</span></a></li>
<li class='toclevel-3'><a href="#.E9.AA.8C.E8.AF.81.E4.BA.8C.E7.BA.A7.E4.BB.A3.E7.90.86.E5.88.97.E8.A1.A8"><span class="tocnumber">6.4.4</span> <span class="toctext">验证二级代理列表</span></a></li>
<li class='toclevel-3'><a href="#.E5.8A.A0.E8.BD.BD.E4.BA.8C.E7.BA.A7.E4.BB.A3.E7.90.86.E5.88.97.E8.A1.A8"><span class="tocnumber">6.4.5</span> <span class="toctext">加载二级代理列表</span></a></li>
</ul>
</li>
<li class='toclevel-2'><a href="#.E4.BA.8C.E7.BA.A7.E4.BB.A3.E7.90.86.E5.AE.A2.E6.88.B7.E7.AB.AF"><span class="tocnumber">6.5</span> <span class="toctext">二级代理客户端</span></a>
<ul>
<li class='toclevel-3'><a href="#.E5.8E.9F.E7.90.86_Principle_5"><span class="tocnumber">6.5.1</span> <span class="toctext">原理 Principle</span></a></li>
<li class='toclevel-3'><a href="#.E5.AE.9E.E7.8E.B0_Implement_5"><span class="tocnumber">6.5.2</span> <span class="toctext">实现 Implement</span></a></li>
<li class='toclevel-3'><a href="#.E4.BB.A3.E7.90.86.E6.B5.8B.E8.AF.95.E6.A8.A1.E5.9D.97"><span class="tocnumber">6.5.3</span> <span class="toctext">代理测试模块</span></a>
<ul>
<li class='toclevel-4'><a href="#Sock5.E9.83.A8.E5.88.86"><span class="tocnumber">6.5.3.1</span> <span class="toctext">Sock5部分</span></a>
<ul>
<li class='toclevel-5'><a href="#.E8.8E.B7.E5.8F.96.E4.BB.A3.E7.90.86"><span class="tocnumber">6.5.3.1.1</span> <span class="toctext">获取代理</span></a></li>
<li class='toclevel-5'><a href="#.E8.BF.9E.E6.8E.A5.E4.BB.A3.E7.90.86"><span class="tocnumber">6.5.3.1.2</span> <span class="toctext">连接代理</span></a></li>
</ul>
</li>
<li class='toclevel-4'><a href="#Sock4.E9.83.A8.E5.88.86"><span class="tocnumber">6.5.3.2</span> <span class="toctext">Sock4部分</span></a>
<ul>
<li class='toclevel-5'><a href="#.E5.8E.9F.E7.90.86"><span class="tocnumber">6.5.3.2.1</span> <span class="toctext">原理</span></a></li>
<li class='toclevel-5'><a href="#.E5.AE.9E.E7.8E.B0"><span class="tocnumber">6.5.3.2.2</span> <span class="toctext">实现</span></a></li>
</ul>
</li>
<li class='toclevel-4'><a href="#HTTP.E9.83.A8.E5.88.86"><span class="tocnumber">6.5.3.3</span> <span class="toctext">HTTP部分</span></a>
<ul>
<li class='toclevel-5'><a href="#.E5.AE.9E.E7.8E.B0_2"><span class="tocnumber">6.5.3.3.1</span> <span class="toctext">实现</span></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class='toclevel-2'><a href="#.E7.BC.93.E5.AD.98.E6.9C.BA.E5.88.B6_Cache_Mechanism"><span class="tocnumber">6.6</span> <span class="toctext">缓存机制 Cache Mechanism</span></a></li>
<li class='toclevel-2'><a href="#.E8.87.AA.E5.8A.A8.E4.BB.A3.E7.90.86.E8.84.9A.E6.9C.AC"><span class="tocnumber">6.7</span> <span class="toctext">自动代理脚本</span></a>
<ul>
<li class='toclevel-3'><a href="#.E5.8E.9F.E7.90.86_2"><span class="tocnumber">6.7.1</span> <span class="toctext">原理</span></a>
<ul>
<li class='toclevel-4'><a href="#.E8.87.AA.E5.8A.A8.E4.BB.A3.E7.90.86.E7.AE.80.E4.BB.8B"><span class="tocnumber">6.7.1.1</span> <span class="toctext">自动代理简介</span></a></li>
<li class='toclevel-4'><a href="#.E4.BB.A3.E7.90.86.E9.85.8D.E7.BD.AE.E8.84.9A.E6.9C.AC.E6.A0.BC.E5.BC.8F"><span class="tocnumber">6.7.1.2</span> <span class="toctext">代理配置脚本格式</span></a></li>
<li class='toclevel-4'><a href="#.E4.BB.A3.E7.90.86.E8.84.9A.E6.9C.AC.E7.9A.84.E5.87.BD.E6.95.B0"><span class="tocnumber">6.7.1.3</span> <span class="toctext">代理脚本的函数</span></a></li>
</ul>
</li>
<li class='toclevel-3'><a href="#.E5.AE.9E.E7.8E.B0_3"><span class="tocnumber">6.7.2</span> <span class="toctext">实现</span></a></li>
</ul>
</li>
<li class='toclevel-2'><a href="#.E4.BC.9A.E8.AF.9D.E6.8E.A7.E5.88.B6_Session_Control"><span class="tocnumber">6.8</span> <span class="toctext">会话控制 Session Control</span></a>
<ul>
<li class='toclevel-3'><a href="#.E5.8E.9F.E7.90.86_3"><span class="tocnumber">6.8.1</span> <span class="toctext">原理</span></a></li>
<li class='toclevel-3'><a href="#.E5.AE.9E.E7.8E.B0_4"><span class="tocnumber">6.8.2</span> <span class="toctext">实现</span></a></li>
</ul>
</li>
</ul>
</li>
<li class='toclevel-1'><a href="#.E5.8D.8F.E8.AE.AE.E5.88.86.E6.9E.90"><span class="tocnumber">7</span> <span class="toctext">协议分析</span></a>
<ul>
<li class='toclevel-2'><a href="#Socks4_.E5.8D.8F.E8.AE.AE.E5.88.86.E6.9E.90"><span class="tocnumber">7.1</span> <span class="toctext">Socks4 协议分析</span></a></li>
<li class='toclevel-2'><a href="#Socks5_.E5.8D.8F.E8.AE.AE.E5.88.86.E6.9E.90"><span class="tocnumber">7.2</span> <span class="toctext">Socks5 协议分析</span></a></li>
<li class='toclevel-2'><a href="#HTTP_.E5.8D.8F.E8.AE.AE.E5.88.86.E6.9E.90"><span class="tocnumber">7.3</span> <span class="toctext">HTTP 协议分析</span></a></li>
</ul>
</li>
<li class='toclevel-1'><a href="#.E6.8E.A5.E5.8F.A3Interface"><span class="tocnumber">8</span> <span class="toctext">接口Interface</span></a></li>
<li class='toclevel-1'><a href="#.E5.87.BD.E6.95.B0.E7.B4.A2.E5.BC.95_Function_Index_A-Z"><span class="tocnumber">9</span> <span class="toctext">函数索引 Function Index A-Z</span></a></li>
</ul>
</td></tr></table>
<p><script type="text/javascript"> if (window.showTocToggle) { var tocShowText = "显示"; var tocHideText = "隐藏"; showTocToggle(); } </script>
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../p/r/o/ProxyGroupDevDocs_cf81.html" title="ProxyGroupDevDocs">编辑</a>]</div><a name="To_Do_List"></a><h1>To Do List</h1>
<p>PA接下来的工作
</p><p>1.PA系统的稳定性
</p><p>　　BUG 1：当PA同时处理的进程超过一定数目时，会出现进程死锁，PA再也无法接受其他的客户端连接。甚至可能会造成操作系统死机。
</p><p>　　当前首要任务是解决该问题。实现更好的进程调度。
</p><p>2.代理服务器对于无法访问的页面的处理
</p><p>　　BUG 2：某些代理服务器禁止了对某些站点的访问。比如说proxy1无法访问微软首页，而刚好proxy1又是PA在测试中速度最快的站点，那么用户在访问微软首页的时候，就很有可能北分配到proxy1。这样用户就不能对微软的站点进行正常的访问。
</p><p>　　这个问题主要取决于被测代理服务器本身的特性。
</p><p>3.对网段的测试
</p><p>　　中国的网络环境是分网段的，目前PA还不支持对网段的处理功能。例如对于电信的站点使用对电信速度快的proxy访问。
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../p/r/o/ProxyGroupDevDocs_cf81.html" title="ProxyGroupDevDocs">编辑</a>]</div><a name=".E6.96.87.E6.A1.A3.E5.8C.BA"></a><h1>文档区</h1>
<ol><li><a href="http://wiki.cs.hit.edu.cn/index.php/ProxyProject" class='external text' title="http://wiki.cs.hit.edu.cn/index.php/ProxyProject" rel="nofollow">主页</a>
</li><li><a href="http://wiki.cs.hit.edu.cn/index.php/Talk:ProxyProject" class='external text' title="http://wiki.cs.hit.edu.cn/index.php/Talk:ProxyProject" rel="nofollow">主页讨论区</a>
</li><li><a href="http://wiki.cs.hit.edu.cn/index.php/ProxyGroupDevDocs" class='external text' title="http://wiki.cs.hit.edu.cn/index.php/ProxyGroupDevDocs" rel="nofollow">开发人员文档</a>
</li><li><a href="http://wiki.cs.hit.edu.cn/index.php/ProxyGroupAdminDocs" class='external text' title="http://wiki.cs.hit.edu.cn/index.php/ProxyGroupAdminDocs" rel="nofollow">管理员文档</a>
</li><li><a href="http://wiki.cs.hit.edu.cn/index.php/ProxyGroupUserDocs" class='external text' title="http://wiki.cs.hit.edu.cn/index.php/ProxyGroupUserDocs" rel="nofollow">用户文档</a>
</li></ol>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../p/r/o/ProxyGroupDevDocs_cf81.html" title="ProxyGroupDevDocs">编辑</a>]</div><a name="The_way_we_reconnect_the_world.21"></a><h1><i>The way we reconnect the world!</i></h1>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../p/r/o/ProxyGroupDevDocs_cf81.html" title="ProxyGroupDevDocs">编辑</a>]</div><a name=".E9.A1.B9.E7.9B.AE.E7.AE.80.E4.BB.8B_Introduction"></a><h1>项目简介 Introduction</h1>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../p/r/o/ProxyGroupDevDocs_cf81.html" title="ProxyGroupDevDocs">编辑</a>]</div><a name=".E9.A1.B9.E7.9B.AE.E8.83.8C.E6.99.AF"></a><h2>项目背景</h2>
<p>随着Internet的不断发展，网络逐渐被大部分的事业单位接受，但是由于网络安全的研究并没有跟上网络发展的速度，以致网络中出现了各种各样的问题。
</p><p>由于涉及到网络安全的问题，目前很多高校和事业单位建立了电路级的防火墙，对Internet的访问都只提供电路级的代理服务。所以，现在这些内部网络中的主机访问外部网络时需要相应的代理支持，最常用的是Socks代理。
</p><p>但现实是，
1 Linux下的代理服务器功能比较单一。
</p><p>现在很多代理服务器都是使用了Linux的系统，它有效率高、负载大、系统要求低、安全性高等特点。但是往往一台服务器只开启某一个代理服务。例如，只运行Squid服务[HTTP代理]，或者只运行Danted服务[Socks服务]。
我们经常使用很多软件由于功能上的限制，并没有提供完整的代理功能。例如，有的软件只提供了Socks4代理功能，而有的只支持Socks，或只支持HTTP代理。
</p><p>如果Linux服务器上的代理服务器只开启Squid的或者只开启Socks5、Danted等代理，那么有很多客户端的程序是就无法连接外部网络中的服务器，以致我们无法使用这些软件部分或全部功能。
</p><p>Linux下缺乏类似CCProxy这种比较综合的代理服务器系统。
</p><p>2 现有代理服务器系统对选择二级代理支持不够。
</p><p>现有的代理服务器大部分只能静态的选择二级代理服务器，而且只支持一个二级代理服务器。不能对二级代理服务器资源进行评价,并通过某种算法选出一个最优的服务器。
</p><p>类似的软件曾经出现过<a href="http://proxyexpert.bbinn.3322.org/proxy/" class='external text' title="http://proxyexpert.bbinn.3322.org/proxy/" rel="nofollow">ProxyExpert</a>，但是首先该软件是基于Windows的，并没有Linux版本；其次作者的文档并不完备，无法对其进行优化。而且，作者已经停止了对这个软件的开发和更新，无法适应网络世界的发展。
</p><p>针对上述Linux以及其它平台代理服务器出现的各种不足，我们提出了一个基于网络自适应的代理服务器系统解决方案。
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../p/r/o/ProxyGroupDevDocs_cf81.html" title="ProxyGroupDevDocs">编辑</a>]</div><a name=".E9.A1.B9.E7.9B.AE.E7.9B.AE.E6.A0.87"></a><h2>项目目标</h2>
<p>从总体来说，我们的系统首先是一个代理服务器，能够接收客户端的数据，并将其发往目的地。
</p><p>其次，本系统是一个一级代理服务器，能将客户端的数据中继到二级代理服务器。它能完全支持主流的通信协议，例如HTTP和Socks（FTP和MMS协议正在完善中）；以及中继时协议之间的转换，例如，Socks2HTTP，Socks2Socks，HTTP2HTTP，HTTP2Socks等。
</p><p>同时，本系统又是一个代理服务器性能的评价系统，它对于能够对二级代理服务器群进行全面的评测。对代理服务器的性能做一个综合的评价，并将其排序。在必要的时候，通过某种算法选出一台合适的二级代理服务器供主系统使用。
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../p/r/o/ProxyGroupDevDocs_cf81.html" title="ProxyGroupDevDocs">编辑</a>]</div><a name=".E5.85.B3.E4.BA.8E.E6.9C.AC.E6.96.87.E6.A1.A3_About_the_document"></a><h1>关于本文档 About the document</h1>
<p>本文档是用于设计和开发Flying Bear项目，包含了项目的设计思想、原理、系统接口和函数索引。可以作为开发人员了解和从事Flying Bear项目的参考文档。
</p><p><br />
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../p/r/o/ProxyGroupDevDocs_cf81.html" title="ProxyGroupDevDocs">编辑</a>]</div><a name=".E4.BB.A3.E7.90.86.E6.9C.8D.E5.8A.A1.E5.99.A8.E5.B7.A5.E4.BD.9C.E6.9C.BA.E5.88.B6_Proxy_Mechanism"></a><h1>代理服务器工作机制 Proxy Mechanism</h1>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../p/r/o/ProxyGroupDevDocs_cf81.html" title="ProxyGroupDevDocs">编辑</a>]</div><a name=".E4.B8.BB.E6.A1.86.E6.9E.B6"></a><h2>主框架</h2>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../p/r/o/ProxyGroupDevDocs_cf81.html" title="ProxyGroupDevDocs">编辑</a>]</div><a name=".E5.8E.9F.E7.90.86_Principle"></a><h3>原理 Principle</h3>
<p>　　采取“预先产生子进程，传送套接字描述符”的方案。
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../p/r/o/ProxyGroupDevDocs_cf81.html" title="ProxyGroupDevDocs">编辑</a>]</div><a name=".E5.AE.9E.E7.8E.B0_Implement"></a><h3>实现 Implement</h3>
<p>　　在程序启动时，由fork()函数产生指定数目的子进程。父进程负责监听和接受新的连接请求，并且将已建立连接的连接套接字述符分配给子进程。所以子进程负责处理所有的请求。
</p><p>父进程和子进程的关系如图：
</p><p><a href="../../../m/a/i/Image%7EMainframe.jpg.html" class="image" title="Image:Mainframe.jpg"><img src="../../../../upload/9/95/Mainframe.jpg" alt="Image:Mainframe.jpg" width="441" height="451" longdesc="../../../m/a/i/Image%7EMainframe.jpg.html" /></a>
</p><p>　　父进程用于中记录子进程信息的结构如下：
</p>
<pre> typedef struct {
   pid_t   child_pid;         /* process ID */
   int     child_pipefd;      /* parent's stream pipe to/from child */
   int     child_status;      /* 0 = ready */
   long    child_used;        /* 1 = used */
} child;
</pre>
<p>　　child_pid记录子进程的进程号，在父进程退出时用来终止子进程；child_pipefd是通信的管道；child_status表示子进程是否处于繁忙状态。
</p><p>　　父进程和子进程之间通过sockfd[0]、STDERR_FILENO建立的管道通信。父进程接受到连接请求后，通过查询是否有可用的子进程。即通过查看child_status一项的值。如果有可用的子进程，就把接套接字述符传送给子进程，繁忙。如果没有可用子进程，这创建新的子进程来满足需求。
</p><p>　　为了不使子进程无限增长，父进程还负责终止多余的空闲子进程。当子进程超出常驻进程数量后，父进程开始查询是否有空闲的子进程，并终止它们，以维持一定的常驻进程数量。
</p><p>　　此外父进程还通过管道查看子进程是否是非正常退出了。对于非正常退出的子进程，父进程需要把它重新补充上。
</p><p>　　子进程在每完成一个请求后，通过管道STDERR_FILENO发送信息，告诉父进程自己完成了任务。父进程读取管道的内容来得知子进程
的状态，达到回收利用子进程的目的。
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../p/r/o/ProxyGroupDevDocs_cf81.html" title="ProxyGroupDevDocs">编辑</a>]</div><a name=".E6.9C.8D.E5.8A.A1.E5.99.A8.E5.A4.9A.E7.BA.BF.E7.A8.8B.E9.80.9A.E4.BF.A1"></a><h2>服务器多线程通信</h2>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../p/r/o/ProxyGroupDevDocs_cf81.html" title="ProxyGroupDevDocs">编辑</a>]</div><a name=".E5.8E.9F.E7.90.86_Principle_2"></a><h3>原理 Principle</h3>
<p>　　代理服务器的工作需要建立四个通道，分别为：
</p><p>　　1.从客户端接收数据
</p><p>　　2.向远程服务器转发从客户端接收到的数据
</p><p>　　3.从远程服务器接收数据
</p><p>　　4.向客户端转发从远程服务器接收到的数据
</p><p>　　为了保证这四个通道的工作不会互相冲突，因此需要建立四个并发执行的作业来分别执行这四个通道的工作。在操作系统中，建立并发执行的作业有两种方法，一是多进程，二是多线程。这里采用更加节约资源的线程。
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../p/r/o/ProxyGroupDevDocs_cf81.html" title="ProxyGroupDevDocs">编辑</a>]</div><a name=".E5.AE.9E.E7.8E.B0_Implement_2"></a><h3>实现 Implement</h3>
<p>　　因为服务器通信过程中，客户端与远程服务器端都有可能向代理服务器发送数据。为了保证代理服务器能够及时的响应客户端或服务器端的要求，且解决接收和发送时间差的冲突，因此服务器通信采用了如下方案：
</p><p>　　系统运行四个并发的线程，分别为：Client Receving, Server Sending, Server Receiving, Client Sending　(下面分别用1,2,3,4号线程来表示)。
</p><p>　　1号和2号线程共享一个缓冲区Buffer。1号线程从客户端接受数据，并把数据写入缓冲队列中；2号线程从缓冲队列中取出数据，将数据发送到远程服务器Remove Server。
</p><p>　　1号和2号线程也共享一个缓冲区。3号线程从远程服务器端接受数据，并把数据写入缓冲队列中；2号线程从缓冲队列中取出数据，将数据发送到客户端。
</p><p>　　如下图：
</p><p><a href="../../../t/h/r/Image%7EThread.JPG_6fbe.html" class="image" title="Image:Thread.JPG"><img src="../../../../upload/f/ff/Thread.JPG" alt="Image:Thread.JPG" width="750" height="379" longdesc="../../../t/h/r/Image%7EThread.JPG_6fbe.html" /></a>
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../p/r/o/ProxyGroupDevDocs_cf81.html" title="ProxyGroupDevDocs">编辑</a>]</div><a name=".E5.85.B3.E4.BA.8E.E7.BC.93.E5.86.B2.E5.8C.BA.E9.98.9F.E5.88.97"></a><h3>关于缓冲区队列</h3>
<p>　　以Client-&gt;Proxy-&gt;Server为例。
</p><p>　　每个缓冲区中有20个小缓冲区。1号线程每从客户端接收满一个小缓冲区，就把该小缓冲区加入缓冲区队列的末尾，并标记该小缓冲区为可发送。缓冲区队列中有数据时，唤醒2号线程，2号线程从缓冲区队列中取出队列首部的小缓冲区的数据，发送到远程服务器端，并将该小缓冲区标记为可接收。当缓冲区队列为空是，2号线程睡眠，1号线程接收阻塞。
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../p/r/o/ProxyGroupDevDocs_cf81.html" title="ProxyGroupDevDocs">编辑</a>]</div><a name=".E5.85.B3.E4.BA.8E.E4.BA.92.E6.96.A5.E8.B5.84.E6.BA.90"></a><h3>关于互斥资源</h3>
<p>　　1号线程和2号线程共享一个互斥的缓冲区队列；同理，3号线程和4号线程共享一个互斥的缓冲区队列。因此对于互斥变量，不允许两个或两个以上线程同时访问。
</p><p>　　因此在对缓冲区队列进行操作时，要通过加锁的方式，控制对该队列的访问。
</p><p>　　使用pthread_mutex_lock和pthread_mutex_unlock函数。
</p><p>　　其中queue_put为把缓冲区加入队列，queue_get为取出队列首部的缓冲区。
</p><p>1号线程
</p>
<pre>pthread_mutex_lock( &amp;(WqCliToServ.mutex));
queue_put( &amp;(WqCliToServ.bufQue), j);
pthread_mutex_unlock( &amp;(WqCliToServ.mutex));
</pre>
<p>2号线程
</p>
<pre>pthread_mutex_lock( &amp;(WqCliToServ.mutex));
bindex = queue_get( &amp;WqCliToServ.bufQue);
pthread_mutex_unlock(&amp;WqCliToServ.mutex);
</pre>
<p>　　函数解析：pthead_mutex_lock(&amp;mutex)的作用是对mutex上锁。如果mutex已经被锁上，则阻塞等待。pthread_mutex_unlock(&amp;mutex)的作用是对mutex解锁。如果mutex没有被锁上，则无任何变化。
</p><p>　　设1号线程对缓冲区队列进行操作时，对WqCliToServ.mutex上锁；这时如果2号线程也要对WqCliToServ.mutex上锁，则该线程发现WqCliToServ.mutex已经被锁上，该线程阻塞等待。1号线程对缓冲区队列的操作结束时解锁，这时等待的2号线程知道该锁已解，就把该锁锁上，执行2号线程的操作。
</p><p>　　通过上锁和解锁，实现了对互斥变量的保护，避免两个线程同时访问同一个互斥变量。
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../p/r/o/ProxyGroupDevDocs_cf81.html" title="ProxyGroupDevDocs">编辑</a>]</div><a name=".E4.BB.A3.E7.90.86.E8.BA.AB.E4.BB.BD.E8.AE.A4.E8.AF.81"></a><h2>代理身份认证</h2>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../p/r/o/ProxyGroupDevDocs_cf81.html" title="ProxyGroupDevDocs">编辑</a>]</div><a name=".E5.8E.9F.E7.90.86_Principle_3"></a><h3>原理 Principle</h3>
<p>代理认证模块代理服务器中一个十分重要的模块，是实现代理服务器在应用层上可控性的一个重要表现。
例如在RFC文档1928中规定了Socks5的身份认证部分。但是Socks4由于自身的设计问题，并没有加入身份认证部分，而HTTP也尚无认证功能。所以这部分的认证模块，我们特指Socks5部分，当然随着代理协议的不断发展和人们对安全的要求日益增加，认证模块很可能将会出现各种其他的协议支持。
Socks认证原理参见<a href="http://wiki.cs.hit.edu.cn/index.php/SocksV5" class='external text' title="http://wiki.cs.hit.edu.cn/index.php/SocksV5" rel="nofollow">Socks5原理</a>。
</p><p>本代理服务器处理Socks4和Socks5的原理过程见下图DFA:
</p><p><a href="../../../d/f/a/Image%7EDfa.jpg.html" class="image" title=" Socks DFA"><img src="../../../../upload/a/ad/Dfa.jpg" alt=" Socks DFA" width="663" height="304" longdesc="../../../d/f/a/Image%7EDfa.jpg.html" /></a>
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../p/r/o/ProxyGroupDevDocs_cf81.html" title="ProxyGroupDevDocs">编辑</a>]</div><a name=".E5.AE.9E.E7.8E.B0_Implement_3"></a><h3>实现 Implement</h3>
<p>本系统中的认证模块现在可以实现Socks5身份认证的功能。模块化的设计使得Flying Bear可以在将来支持更多的协议族。
认证
</p><p>首先服务器会接收到客户端发送的请求。
</p><p>请求数据报中包括客户端能够支持的认证种类,其中认证种类按照RFC1928种的规定，参见$FBEAR_HOME/include/auth.h：
</p>
<pre>#define NOAUTH 			0x00 
#define GSSAPI				0x01
#define USER_PASSWORD			0x02
#define IANA_ASSIGNED 			0x03
...
#define NO_ACCEPTABLE_METHODS		0xff
</pre>
<p>代理服务器检查身份认证列表，例如：
</p>
<pre>#Sample&nbsp;: net/netmask:user:passwd:authtype
173.26.100.0/24:marvel:liuwenmao:pass
202.118.250.0/24:::none
0.0.0.0/0:liuwenmao:liu:pass
</pre>
<p>从中匹配与客户端地址相符合的项，返回给客户端相应的认证方式。
</p><p>第一行为格式说明。例如，第二行表示173.26.100.0/24网络的主机通行的时候需要使用用户名marvel、密码liuwenmao的用户名/密码认证方式。
</p><p>由于考虑到服务器端的列表中可能会出现一些重复的项(如上图的 202.118.250.0/24:::none 和 0.0.0.0/0:liuwenmao:liu:pass 两项)，那么系统则选出一个最简单的认证方式。
</p><p>例如，假定系统匹配到一项，但是该项的认证方式是用户名/密码，那么系统继续寻找，如果找到了一个不需要身份认证的项，那么返回无需认证的方式（NOAUTH 0x00），否则返回用户名/密码认证方式（NO_ACCEPTABLE_METHODS 0x02）。
</p><p>如果在列表中没有任何项匹配，那么返回出错标志(NO_ACCEPTABLE_METHODS 0xFF)
</p><p>注：如果是认证方式是用户明/密码，则需要添加一步认证的过程。客户端将用户名、密码发到服务器端，这两个都是非加密的字符串，服务器端将对其进行验证，如果成功则进入DFA的下一步，否则关闭连接。
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../p/r/o/ProxyGroupDevDocs_cf81.html" title="ProxyGroupDevDocs">编辑</a>]</div><a name=".E4.BA.8C.E7.BA.A7.E4.BB.A3.E7.90.86.E5.88.97.E8.A1.A8"></a><h2>二级代理列表</h2>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../p/r/o/ProxyGroupDevDocs_cf81.html" title="ProxyGroupDevDocs">编辑</a>]</div><a name=".E5.8E.9F.E7.90.86_Principle_4"></a><h3>原理 Principle</h3>
<p>系统对一个原始的的二级代理列表进行探测，该列表是从某网站中获得，有的二级代理可能不可用，所以需要进行验证。同时，系统管理员也可以手动添加二级代理，但这些二级代理服务器同样可能会是不可用的，所以同样需要进行验证。
</p><p>系统对这两部分的二级代理服务器进行验证之后，生成一个真正可用的二级代理列表，并将其写入可用列表资源文件($FBEAR_HOME/conf/availproxy.list)。
</p><p>系统启动之后，加载这两部分生成的列表。之后，系统定期更新原始列表，所以也需要定时验证，并更新内存中的二级代理服务器列表。
</p><p>同时，系统需要定时地去除内存中不可用的二级代理服务器项。
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../p/r/o/ProxyGroupDevDocs_cf81.html" title="ProxyGroupDevDocs">编辑</a>]</div><a name=".E5.AE.9E.E7.8E.B0_Implement_4"></a><h3>实现 Implement</h3>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../p/r/o/ProxyGroupDevDocs_cf81.html" title="ProxyGroupDevDocs">编辑</a>]</div><a name=".E4.BA.8C.E7.BA.A7.E4.BB.A3.E7.90.86.E5.88.97.E8.A1.A8.E7.9A.84.E7.94.9F.E6.88.90"></a><h4>二级代理列表的生成</h4>
<p>首先系统需要生成一个可能可用的二级代理服务器列表。分别自动和手动添加。
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../p/r/o/ProxyGroupDevDocs_cf81.html" title="ProxyGroupDevDocs">编辑</a>]</div><a name=".E7.B3.BB.E7.BB.9F.E8.87.AA.E5.8A.A8.E6.8E.A2.E6.B5.8B"></a><h4>系统自动探测</h4>
<p>系统对特定发布代理服务器资源的站点进行探测，例如我们的二级代理列表来源是<a href="http://www.xjtushare.com/proxy.aspx" class='external free' title="http://www.xjtushare.com/proxy.aspx" rel="nofollow">http://www.xjtushare.com/proxy.aspx</a> ，在此对该网站表示感谢！
</p><p>在获得相应的网页之后，系统对网页的内容进行解析。获得一个代理列表的集合，将其存放到临时文件中（默认为($FBEAR_HOME/cache/rawlist)）。
</p><p>例如：
</p><p><br />
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../p/r/o/ProxyGroupDevDocs_cf81.html" title="ProxyGroupDevDocs">编辑</a>]</div><a name=".E6.89.8B.E5.8A.A8.E6.B7.BB.E5.8A.A0"></a><h4>手动添加</h4>
<p>系统管理人员可以手动编辑添加二级代理（系统默认为$FBEAR_HOME/conf/serverlist）。
格式参见“代理服务器可用列表文件格式”
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../p/r/o/ProxyGroupDevDocs_cf81.html" title="ProxyGroupDevDocs">编辑</a>]</div><a name=".E4.BB.A3.E7.90.86.E6.9C.8D.E5.8A.A1.E5.99.A8.E5.8F.AF.E7.94.A8.E5.88.97.E8.A1.A8.E6.96.87.E4.BB.B6.E6.A0.BC.E5.BC.8F"></a><h3>代理服务器可用列表文件格式</h3>
<p>文件每一行是一个代理服务器的列表，如果一行的第一个字符是“＃”，则系统解析时忽略该行。
</p><p>格式如下：(方括号表示可选)<br />
协议类型://主机地址:端口[@用户名/密码]<br />
例如:<br />
socks5://202.118.250.18:1080@ibmtc/ibmtest <br />
socks4://202.118.250.18:1080@ibmtc/ibmtest <br />
http://202.118.250.18:8080@ibmtc/ibmtest
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../p/r/o/ProxyGroupDevDocs_cf81.html" title="ProxyGroupDevDocs">编辑</a>]</div><a name=".E9.AA.8C.E8.AF.81.E4.BA.8C.E7.BA.A7.E4.BB.A3.E7.90.86.E5.88.97.E8.A1.A8"></a><h3>验证二级代理列表</h3>
<p>接下来，系统需要对上一步生成的原始列表和用户的列表进行验证。获得一个可用的列表。
系统读入按行读入原始列表和用户列表，读入协议类型、地址、端口、用户名和密码，并通过相应的协议调用相应的函数，连接该代理服务器下载某一个特定页面，如果下载过程中没有出现任何问题，则将其写入一个可用文件($FBEAR_HOME/conf/availproxy.list)
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../p/r/o/ProxyGroupDevDocs_cf81.html" title="ProxyGroupDevDocs">编辑</a>]</div><a name=".E5.8A.A0.E8.BD.BD.E4.BA.8C.E7.BA.A7.E4.BB.A3.E7.90.86.E5.88.97.E8.A1.A8"></a><h3>加载二级代理列表</h3>
<p>系统加载可用文件($FBEAR_HOME/conf/availproxy.list)，将其读入内存。为下一步的评价代理服务器作准备。
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../p/r/o/ProxyGroupDevDocs_cf81.html" title="ProxyGroupDevDocs">编辑</a>]</div><a name=".E4.BA.8C.E7.BA.A7.E4.BB.A3.E7.90.86.E5.AE.A2.E6.88.B7.E7.AB.AF"></a><h2>二级代理客户端</h2>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../p/r/o/ProxyGroupDevDocs_cf81.html" title="ProxyGroupDevDocs">编辑</a>]</div><a name=".E5.8E.9F.E7.90.86_Principle_5"></a><h3>原理 Principle</h3>
<p>见各协议分析。 
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../p/r/o/ProxyGroupDevDocs_cf81.html" title="ProxyGroupDevDocs">编辑</a>]</div><a name=".E5.AE.9E.E7.8E.B0_Implement_5"></a><h3>实现 Implement</h3>
<p>简介：首先读取代理列表，然后测试代理列表中的代理是否可用，获得代理的速度，然后根据速度进行排序。获得各个网段的排序后，
根据接收到的请求，返回给请求者最优的ip。
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../p/r/o/ProxyGroupDevDocs_cf81.html" title="ProxyGroupDevDocs">编辑</a>]</div><a name=".E4.BB.A3.E7.90.86.E6.B5.8B.E8.AF.95.E6.A8.A1.E5.9D.97"></a><h3> 代理测试模块 </h3>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../p/r/o/ProxyGroupDevDocs_cf81.html" title="ProxyGroupDevDocs">编辑</a>]</div><a name="Sock5.E9.83.A8.E5.88.86"></a><h4> Sock5部分 </h4>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../p/r/o/ProxyGroupDevDocs_cf81.html" title="ProxyGroupDevDocs">编辑</a>]</div><a name=".E8.8E.B7.E5.8F.96.E4.BB.A3.E7.90.86"></a><h5> 获取代理 </h5>
<p>本模块的功能:初始化代理内容，测试代理性能，代理排序优化，代理算法实现，对外提供代理。
</p><p>初始化代理：读取conf目录下的文件serverlist，将读取到的内容初始化到代理列表中。
</p><p>--initial_serv_list();
文件格式：
</p>
<pre>   #协议类型://主机地址:端口[@用户名/密码]
   #socks://173.26.100.148:1080@/
   socks://173.26.100.31:1080@gaoce/gaoce
   “#”表示此行被注释掉。
</pre>
<p>数据结构：
</p>
<pre>   struct serv_struct
   {
         unsigned long  ipaddr;
         unsigned short port;
         float    newtime[SER_CLASS];//SER_CLASS, 网段数量
         float    time[SER_CLASS];
         float    newspeed[SER_CLASS];
         float    speed[SER_CLASS];
         char   protocol[10];
         char   id      [16];
         char   pwd      [16];
     };
</pre>
<p>--cpyProxyList()
</p><p>将数据列表初始化后，将结构指针的地址拷贝到一个横向长度为远程服务器站点类型数量（网段数量）－－教育网，网通，电信，国外网等。
网段数量的两倍，纵向为代理服务器个数的二维列表中。以备下一步服务器初始化代理服务器的速度和时间，从而进行排序。
</p><p>--connect_proxy()
</p><p>采用socks5协议，与代理服务器建立连接，首先初始化ip地址，端口号，发送请求，建立连接。
</p><p>--connect_remote_site()
</p><p>当与代理服务器建立连接后，则通过代理服务器，访问各个网段的代表站点。首先在本地初始化信息，然后发送请求，请求中包括访问的远程
站点的信息。代理服务器将和远程站点建立连接，然后返回本地相应的信息，通过信息认证，如果建立成功，发送取页面的信息。如果建立连
接不成功，则直接退出。
</p><p>在以上的各部分中，初始化完代理服务器的列表后，当发信息时，开始计时，如果建立连接不成功，那么计时停止，该代理的时间设为最
大值，速度为零，如果连接成功，那么从最开始的认证开始，记录所有收到的字节数，然后将其除以收得的字节数，求得最终的速度。
</p><p>--speed_optimize(int offset,int orgoffset)
</p><p>然后进行速度优化，将历史速度和最新的速度进行计算，两个速度分别占不同的比例，取计算的结果为最终的结果。
</p><p>--sort_serv_list_by_speed(int offset,int orgoffset)
</p><p>按照速度的大小进行排序，这样得到最终的结果。
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../p/r/o/ProxyGroupDevDocs_cf81.html" title="ProxyGroupDevDocs">编辑</a>]</div><a name=".E8.BF.9E.E6.8E.A5.E4.BB.A3.E7.90.86"></a><h5> 连接代理 </h5>
<p>　　本模块主要功能：从二级代理列表中获取一个可用的二级代理，连接二级代理里，建立客户端&lt;---&gt;一级代理&lt;---&gt;二级代理通道。
</p><p>　　获得可用的二级代理：通过自定义的UDP协议，向代理测试进程获得可用的二级代理的代理地址和端口。
</p><p>--Getsubproxy()
</p>
<pre>void GetSubProxy(sruct socksaddr_in *subProxy);
通过向代理测试进程发送自定义的UDP报文，获得二级代理的IP地址和端口，保存在结构subProxy中
    
</pre>
<p>自定义的协议格式如下：
</p>
<pre>    设需要传送的字符串为buf[6]
    strncpy(buf,"GET",3);
    buf[3] = 1; //server_type 
    buf[4] = 1; //algo_num
    buf[5] = '\0';
 即：buf = "GET11"
</pre>
<p><br />
　　连接Socks5二级代理：分为TCP请求和UDP请求两种形式。
</p><p>--SocksCli
</p>
<pre>int SocksCli(TCI* connec,in_addr_t dstIP,uint16_t dstPort,UCI* udpConnec, 
       struct sockaddr_in *subProxy)；

如果是TCP请求，则UCI* connec处为NULL; 如果是UDP请求，则UCI* connec处为UDP连接通道。
dstIP,dstPort:表示所要连接的远程服务器的IP地址和端口。
struct sockaddr_in *subProxy&nbsp;:表示代理服务器的信息。

return value: 如果连接成功返回1，连接失败返回0。
连接成功后，TCP请求的通道信息保存在TCI* connec中，UDP请求的通道信息保存在UCI* connec中
</pre>
<p>　　TCI与UCI的数据结构
</p>
<pre>typedef struct TcpConnectInfo {
   int dstfd;                    //目的地址套接字描述符，可以是远程服务器也可以是二级代理
   struct sockaddr_in dstaddr;   //目的地址的IP地址和端口信息
   int clifd;                    //客户端套接字描述符
   struct sockaddr_in cliaddr;   //客户端信息
   socklen_t clilen; 
}TCI;

typedef struct UdpConnectInfo {
   int dstfd;                    //目的地址套接字描述符，可以是远程服务器也可以是二级代理
   struct sockaddr_in dstaddr;   //目的地址的IP地址和端口信息
   int clifd;                    //客户端套接字描述符
   struct sockaddr_in cliaddr;   //客户端信息
   socklen_t clilen; 
}UCI;
</pre>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../p/r/o/ProxyGroupDevDocs_cf81.html" title="ProxyGroupDevDocs">编辑</a>]</div><a name="Sock4.E9.83.A8.E5.88.86"></a><h4> Sock4部分 </h4>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../p/r/o/ProxyGroupDevDocs_cf81.html" title="ProxyGroupDevDocs">编辑</a>]</div><a name=".E5.8E.9F.E7.90.86"></a><h5>原理</h5>
<p>它是socks5的前身，简化了第一步一级代理到二级代理建立连接的确认过程，一级代理建立套接字后，向二级代理发送访问远程服务器的相关内容，协议格式与socks5稍有差别，这样直接获得远程服务器的界面。
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../p/r/o/ProxyGroupDevDocs_cf81.html" title="ProxyGroupDevDocs">编辑</a>]</div><a name=".E5.AE.9E.E7.8E.B0"></a><h5> 实现 </h5>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../p/r/o/ProxyGroupDevDocs_cf81.html" title="ProxyGroupDevDocs">编辑</a>]</div><a name="HTTP.E9.83.A8.E5.88.86"></a><h4> HTTP部分 </h4>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../p/r/o/ProxyGroupDevDocs_cf81.html" title="ProxyGroupDevDocs">编辑</a>]</div><a name=".E5.AE.9E.E7.8E.B0_2"></a><h5> 实现 </h5>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../p/r/o/ProxyGroupDevDocs_cf81.html" title="ProxyGroupDevDocs">编辑</a>]</div><a name=".E7.BC.93.E5.AD.98.E6.9C.BA.E5.88.B6_Cache_Mechanism"></a><h2>缓存机制 Cache Mechanism</h2>
<p>由于代理服务器提高性能的关系，需要将一些常用的页面存在本地，这就是代理服务器的缓存机制。
如果客户端在该数据未失效之前，请求该数据，代理服务器则从缓存中读出数据，发向客户端。从而提高了效率。
我们将需要存放的文件存放在cache文件夹中，这个文件夹可以在fbear.conf配置文件中定义。
我们采用的存放结构为：
</p>
<pre>-根目录cache
 --子目录 www.cs.hit.edu.cn_8080
   ---index.html
   ---logo.jpg
   ---...
--子目录 202.118.250.18
--子目录 www.baidu.com
   ---index.php
   ---...
</pre>
<p>其中子目录为站点名，格式为：主机［_端口］，如果 _端口 没有，则默认为80端口。
该目录下存放本站点的文件
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../p/r/o/ProxyGroupDevDocs_cf81.html" title="ProxyGroupDevDocs">编辑</a>]</div><a name=".E8.87.AA.E5.8A.A8.E4.BB.A3.E7.90.86.E8.84.9A.E6.9C.AC"></a><h2>自动代理脚本</h2>
<p>代理服务器的自动配置脚本是动态选择代理的一种实现方式。它能够通过在浏览器的客户端中设置，有客户端浏览器每次连接的时候调用，每次选择不同的可用代理，实现动态代理决策的功能。
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../p/r/o/ProxyGroupDevDocs_cf81.html" title="ProxyGroupDevDocs">编辑</a>]</div><a name=".E5.8E.9F.E7.90.86_2"></a><h3>原理</h3>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../p/r/o/ProxyGroupDevDocs_cf81.html" title="ProxyGroupDevDocs">编辑</a>]</div><a name=".E8.87.AA.E5.8A.A8.E4.BB.A3.E7.90.86.E7.AE.80.E4.BB.8B"></a><h4>自动代理简介</h4>
<p>配置脚本是存放在代理服务器上的，客户端获得脚本，并选择具体使用哪个代理。其过程如下：
</p>
<ol><li> 客户端配置，选择使用代理自动配置方式
</li><li> 客户端连接服务器的时候，会下载这个脚本
</li><li> 客户端运行这个脚本，会返回一个字符串，这个字符串就是客户端具体选择的代理。例如"PROXY 192.168.0.1:808"
</li><li> 客户端使用步骤3中得到的代理服务器，进行通信
</li></ol>
<p>在下图,我们详细描述出了自动代理配置脚本的原理
<a href="../../../p/r/i/Image%7EPrinciple.JPG_abce.html" class="image" title="Image:Principle.JPG"><img src="../../../../upload/6/6f/Principle.JPG" alt="Image:Principle.JPG" width="555" height="431" longdesc="../../../p/r/i/Image%7EPrinciple.JPG_abce.html" /></a>
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../p/r/o/ProxyGroupDevDocs_cf81.html" title="ProxyGroupDevDocs">编辑</a>]</div><a name=".E4.BB.A3.E7.90.86.E9.85.8D.E7.BD.AE.E8.84.9A.E6.9C.AC.E6.A0.BC.E5.BC.8F"></a><h4>代理配置脚本格式</h4>
<p>代理配置脚本实质上是一段JavaScript的脚本。但是这段JavaScript是独立的，而不是内嵌在HTML文件中。这个文件应该以pac结尾，例如：proxy.pac。代理配置脚本除了需要符合JavaScript的格式外，还有一些自己特点的格式。代理脚本中必须包含一个函数：
</p>
<pre>ret = function FindProxyForURL(fullurl, host)
</pre>
<p>因为客户端每次都会调用这个函数，获得一个代理服务器的地址。其中，
</p>
<ol><li> fullurl 客户端（浏览器）需要访问的站点的完整路径；
</li><li> host 客户端（浏览器）需要访问的站点的主机名；
</li><li> ret 返回值，选择要连接的代理地址。
</li></ol>
<p>返回值有三种类型：
</p>
<ol><li> DIRECT 选用直接连接，不使用代理服务器。
</li><li> PROXY host:port 使用特点的代理主机：端口
</li><li> SOCKS host:port 使用特定的Socks代理主机：端口
</li></ol>
<p>返回值可以是由分号隔开的多个上述块（例如：PROXY 202.118.238.76:1201;SOCKS 202.118.224.29:1080;
DIRECT）。如果是这种情况，那么浏览器（Navigator）会从左向后一次尝试每个代理。一般Navigator每30分
钟尝试一个上一次失败的代理，如果不成功，则隔一段时间重试。每次重试的时间是上一次重试的时
间再加上30分钟。
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../p/r/o/ProxyGroupDevDocs_cf81.html" title="ProxyGroupDevDocs">编辑</a>]</div><a name=".E4.BB.A3.E7.90.86.E8.84.9A.E6.9C.AC.E7.9A.84.E5.87.BD.E6.95.B0"></a><h4>代理脚本的函数</h4>
<p>由于自动配置脚本使用JavaScript编写的，所以可以利用JS中的一些预先定义的函数。
</p>
<ol><li>主函数
</li></ol>
<p>如上所说，FindProxyForURL为客户端调用的主函数。现在讨论以下情况：假设除了本地地址都通过
代理192.168.0.1:808
</p><p>autorpxoy脚本的编写
</p>
<pre>function FindProxyforURL(theurl, host)){
    if (isPlainHostName(host))
        return "DIRECT";
    else
        return "PROXY 192.168.0.1:808";
}
</pre>
<p>假设除了本地地址都通过代理，并且现有两个代理: 192.168.0.1:808和192.168.0.2:808。选择代理
是随机的。autorpxoy脚本的编写：
</p>
<pre>function FindProxyForURL(theurl, host){
    if (isPlainHostName(host))
        return "DIRECT";
    else
        return randomProxy();
}
function randomProxy(){
    if (Math.floor( Math.random() n% 2 ) ==0)
        return "PROXY 192.168.0.1:808";
    else
        return "PROXY 192.168.0.1:808";
}
</pre>
<p>假设除了本地地址都通过代理，所有的com站点都通过192.168.0.2:808，所有到www.tsinghua.edu.cn的
都通过proxy.edu.cn:808，其余的通过192.168.0.1:808。
</p>
<pre>function FindProxyForURL(url, host) {
    if (isPlainHostName(host))
         return "DIRECT";
    else if (shExpMatch(host, "¤.com"))
         return "PROXY 192.168.0.2:808";
    else if (shExpMatch(host, "www.tsinghua.edu.cn"))
         return "PROXY proxy.edu.cn:808";
    else
         return "PROXY 192.168.0.1:808";
}
</pre>
<p>可以看出自动代理设置脚本可以控制连接站点所使用的代理，而且改变这些配置只需在服务器上修
改pac脚本就可，对客户端并没有影响。
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../p/r/o/ProxyGroupDevDocs_cf81.html" title="ProxyGroupDevDocs">编辑</a>]</div><a name=".E5.AE.9E.E7.8E.B0_3"></a><h3>实现</h3>
<p>系统始终有一个评测二级代理的守护进程在运行,现在实现自动代理设置,只需从这个守护进程中获得可用代理服务器的信息,将其写入自动配置脚本即可。
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../p/r/o/ProxyGroupDevDocs_cf81.html" title="ProxyGroupDevDocs">编辑</a>]</div><a name=".E4.BC.9A.E8.AF.9D.E6.8E.A7.E5.88.B6_Session_Control"></a><h2>会话控制 Session Control</h2>
<p>由于代理服务器系统工作在电路级和应用级，所以可以对其转发的信息和服务器、客户端所进行的会话进行比较全面的控制。
</p><p>系统依据TCP协议的定义对出入防火墙的数据包进行了完整的重组，重组后的数据流交给应用层过滤逻辑进行过滤，从而可以有效的识别并拦截应用层的攻击企图。
</p><p>会话控制可以实现网络中信息过滤、防止下载网页病毒、邮件病毒等功能。
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../p/r/o/ProxyGroupDevDocs_cf81.html" title="ProxyGroupDevDocs">编辑</a>]</div><a name=".E5.8E.9F.E7.90.86_3"></a><h3>原理</h3>
<p>当客户端请求与服务器端建立连接的时候，代理服务器接受该连接，同时连接远程服务器。当一个连接对建立之后，一个会话正式建立。
</p><p>这个时候，系统将该会话分配给一个现有的进程或一个新建进程，该进程将接管这个会话。
</p><p>每次代理服务器接收到数据的时候，都会检查整个会话。即将本次以及以前的所有内容连接起来，对整个会话的内容进行处理。
</p><p>当处理完毕之后，根据具体情况选择所应该采取的行动。例如正常发送给客户端，或者想客户端发送出错信息，或者关闭与客户端的连接，等等。
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../p/r/o/ProxyGroupDevDocs_cf81.html" title="ProxyGroupDevDocs">编辑</a>]</div><a name=".E5.AE.9E.E7.8E.B0_4"></a><h3>实现</h3>
<p>以客户端发送一个HTTP请求为例，Web服务器向代理服务器持续的发送网页信息。
</p><p>当代理服务器接收到网页信息的时候，将其缓存在本地一个文件中。
</p><p>接着，对该文件进行检查，当遇到&lt;Script Language=……的时候进行标记。
</p><p>之后当遇到&lt;/Script&gt;的时候，对整个脚本进行检查，察看时候有修改注册表、写文件等具有病毒特征的代码。
当查到有相应的特征的时候，转入相应的处理。
</p><p>根据系统的设计以及危险的程度，代理服务器做出决策。最严厉的手段是关闭连接，最温和的是忽略该异常情况。
</p><p>而其他TCP或UDP连接则简单一些，只需要匹配关键字即可。关键字的种类可以由系统管理员设定。
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../p/r/o/ProxyGroupDevDocs_cf81.html" title="ProxyGroupDevDocs">编辑</a>]</div><a name=".E5.8D.8F.E8.AE.AE.E5.88.86.E6.9E.90"></a><h1>协议分析</h1>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../p/r/o/ProxyGroupDevDocs_cf81.html" title="ProxyGroupDevDocs">编辑</a>]</div><a name="Socks4_.E5.8D.8F.E8.AE.AE.E5.88.86.E6.9E.90"></a><h2>Socks4 协议分析</h2>
<p>SOCKS4 是一种让应用层用户能够基于TCP之上进行通讯的协议。由于此协议是基于应用
层之上的，所以被很多不同的服务器所采纳，如telnet，ftp，finger，whois，gopher，
WWW等等。在每一次的TCP会话之前进行通路控制，然后服务器就在客户端和应用服务器
之间进行简单的数据传输，这种通讯降低了系统资源的消耗。而且,SOCKS协议在使用时
不需要知道其具体的应用协议是什么，同时，它也可以很方便的使用加密保护来保护通
讯的信息。
</p><p>也就是说，Socks4协议只需简单的建立连接，就可以实现通讯，它与后来的Socks5相比，
减少了认证的过程，协议也有所不同。
</p><p>对于Socks4协议，它有两种不同的操作：作为客户端应用，只需建立连接就可以进行通
讯；作为服务器使用，需要绑定操作。
</p><p>本部分实现的是客户端，下面介绍客户端的应用。
</p><p>1) 连接：CONNECT
</p><p>与正常的网络连接相似，客户端首先建立一个数据流套接字，然后初始化，填入访问的
代理，就绪后建立连接，形成客户端到代理服务器的通道。当和代理服务器建立连接后，
便可向服务器发送相关的信息，以此建立与远程服务器的通道。
客户端向代理服务器发生的请求包括：远程服务器IP地址，端口等，具体的格式如下：
</p>
<pre>         +----+----+----+----+----+----+----+----+----+----+....+----+
         | VN | CD | DSTPORT |      DSTIP        | USERID       |NULL|
         +----+----+----+----+----+----+----+----+----+----+....+----+
# 字节数:   1    1      2              4           variable       1
</pre>
<p>VN 是SOCKS 的版本，这里填写4，CD 是SOCKS的命令保留字，在请求中必须写1。最后的NULL
是8位全零的bit。
</p><p>SOCKS 服务器将检测这个请求是否被承认是基于任何綁定的源地址，目的地址，源端口和目的
端口，还有用户id等认证信息。如果认证信息被承认，则SOCKS代理服务器将建立和远程服务主
机一个通道，这样远程服务主机就和客户端建立起完整的通道。否则服务器将返回错误的信息，
返回的数据信息如下：
</p>
<pre>               +----+----+----+----+----+----+----+----+
               | VN | CD | DSTPORT |      DSTIP        |
               +----+----+----+----+----+----+----+----+
       # 字节书:  1    1      2              4
</pre>
<p>VN 是返回版本号，为0。 CD 通道的建立结果其值和对应的信息如下:
</p>
<pre>   90: 请求得到确定
   91: 情求被拒绝或者失败
   92: 请求被拒绝，因为SOCKS 服务器无法连接而客户端的认证失败
   93: 请求被拒绝因为客户程序和认证报告的用户id不同
</pre>
<p>其他的信息将可以被忽略。
在发回拒绝请求的相关信息后，SOCKS服务器将关闭连接。如果连接成功，则用户便可以在此同道上
进行各种通讯了。
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../p/r/o/ProxyGroupDevDocs_cf81.html" title="ProxyGroupDevDocs">编辑</a>]</div><a name="Socks5_.E5.8D.8F.E8.AE.AE.E5.88.86.E6.9E.90"></a><h2>Socks5 协议分析</h2>
<p>参见 <a href="http://wiki.cs.hit.edu.cn/index.php/SocksV5" class='external free' title="http://wiki.cs.hit.edu.cn/index.php/SocksV5" rel="nofollow">http://wiki.cs.hit.edu.cn/index.php/SocksV5</a>
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../p/r/o/ProxyGroupDevDocs_cf81.html" title="ProxyGroupDevDocs">编辑</a>]</div><a name="HTTP_.E5.8D.8F.E8.AE.AE.E5.88.86.E6.9E.90"></a><h2>HTTP 协议分析</h2>
<p>HTTP：Hypertext Transfer Protocol
</p><p>　　超文本传输协议（HTTP）是应用层协议，由于其简捷、快速的方式，适用于分布式和合作式超媒体信息系统。
　　HTTP 允许使用自由答复的方法表明请求目的，它建立在统一资源识别器（URI）提供的参考原则下，作为一个地址（URL）或名字（URN），用以标志采用哪种方法，它用类似于网络邮件和多用途网际邮件扩充协议（MIME）的格式传递消息。
　　HTTP 也可用作普通协议，实现用户代理与连接其它 Internet 服务（如 SMTP 、 NNTP 、 FTP 、 GOPHER 及 WAIS ）的代理服务器或网关之间的通信，允许基本的超媒体访问各种应用提供的资源，同时简化了用户代理系统的实施。
　　HTTP 是一种请求 / 响应式的协议。一个客户机与服务器建立连接后，发送一个请求给服务器，请求的格式是：统一资源标识符（URI）、协议版本号，后面是类似 MIME 的信息，包括请求修饰符、客户机信息和可能的内容。服务器接到请求后，给予相应的响应信息，其格式是：一个状态行包括信息的协议版本号、一个成功或错误的代码，后面也是类似 MIME 的信息，包括服务器信息、实体信息和可能的内容。
　　HTTP到现在有三个版本，0.9，1.0 ，1.1，1.1要求更加严格以确保服务的可靠性。以下是HTTP的报文格式：
</p><p>	协议结构
</p><p>　　 HTTP报文由从客户机到服务器的请求和从服务器到客户机的响应构成。 请求报文格式如下：
</p><p>请求行 	通用信息头 	请求头 	实体头 	报文主体
</p><p>　　请求行以方法字段开始，后面分别是 URL 字段和 HTTP 协议版本字段，并以 CRLF 结尾。SP 是分隔符。除了在最后的 CRLF 序列中 CF 和 LF 是必需的之外(“\r\n")，其他都可以不要。有关通用信息头，请求头和实体头方面的具体内容可以参照相关文件。
</p><p>　　应报文格式如下：
</p><p>状态行 	通用信息头 	响应头 	实体头 	报文主体
</p><p>　　状态码元由3位数字组成，表示请求是否被理解或被满足。原因分析是对原文的状态码作简短的描述，状态码用来支持自动操作，而原因分析用来供用户使用。客户机无需用来检查或显示语法。有关通用信息头，响应头和实体头方面的具体内容可以参照相关文件。
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../p/r/o/ProxyGroupDevDocs_cf81.html" title="ProxyGroupDevDocs">编辑</a>]</div><a name=".E6.8E.A5.E5.8F.A3Interface"></a><h1> 接口Interface </h1>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../p/r/o/ProxyGroupDevDocs_cf81.html" title="ProxyGroupDevDocs">编辑</a>]</div><a name=".E5.87.BD.E6.95.B0.E7.B4.A2.E5.BC.95_Function_Index_A-Z"></a><h1>函数索引 Function Index A-Z</h1>

<div class="printfooter">
<p>取自"<a href="http://dns.cs.hit.edu.cn../../../p/r/o/ProxyGroupDevDocs_cf81.html">http://dns.cs.hit.edu.cn../../../p/r/o/ProxyGroupDevDocs_cf81.html</a>"</p>

<p>本页面已经被浏览2,701次。 This page was last modified 12:00 2006年3月30日 by 匿名用户. Based on work by <a href="../../../l/i/u/User%7ELiuwenmao.html" class="new" title="User:Liuwenmao">刘文懋</a>, <a href="../../../x/i/o/User%7EXiongfei.html" class="new" title="User:Xiongfei">xiongfei</a> 和 <a href="../../../%E5%88%98/%E5%BE%B7/%E8%B6%85/User%7E%E5%88%98%E5%BE%B7%E8%B6%85.html" class="new" title="User:刘德超">刘德超</a>. </p>
</div>

</div><br style="clear:both" />

<div id='footer'><table border="0" cellspacing="0"><tr><td width='152' rowspan='1'>&nbsp;</td><td class='bottom' align='left' valign='top'><strong><a href="../../../p/r/o/ProxyGroupDevDocs_cf81.html" title="ProxyGroupDevDocs">编辑本页</a></strong> |
<a href="../../../p/r/o/Talk%7EProxyGroupDevDocs_0dd0.html" class="new" title="Talk:ProxyGroupDevDocs">讨论本页</a> |
<a href="../../../p/r/o/ProxyGroupDevDocs_cf81.html" title="ProxyGroupDevDocs">较早版本</a> |
<a href="../../../w/h/a/Special%7EWhatlinkshere.html" title="Special:Whatlinkshere">链入页面</a> |
<a href="../../../r/e/c/Special%7ERecentchangeslinked.html" title="Special:Recentchangeslinked">链出更改</a>
<br /><br />

<br /><a href="../../../index.html" title="首页">首页</a> | <a href="../../../w/i/k/Wikipedia%7E%E5%85%B3%E4%BA%8E.html" title="Wikipedia:关于">关于Wikipedia</a> | <a href="../../../r/e/c/Special%7ERecentchanges.html" title="Special:Recentchanges">最近更改</a> | <form name="search" class="inline" method="post" action="../../../s/e/a/Special%7ESearch.html">
<input type="text" name="search" size="19" value="" />
<input type="submit" name="go" value="进入" />&nbsp;<input type="submit" name="fulltext" value="搜索" />
</form><br /><span id="pagestats">本页面已经被浏览2,701次。 This page was last modified 12:00 2006年3月30日 by 匿名用户. Based on work by <a href="../../../l/i/u/User%7ELiuwenmao.html" class="new" title="User:Liuwenmao">刘文懋</a>, <a href="../../../x/i/o/User%7EXiongfei.html" class="new" title="User:Xiongfei">xiongfei</a> 和 <a href="../../../%E5%88%98/%E5%BE%B7/%E8%B6%85/User%7E%E5%88%98%E5%BE%B7%E8%B6%85.html" class="new" title="User:刘德超">刘德超</a>. </span></td></tr></table>
</div>
</div>

<div id='quickbar'>
<a href='../../../index.html'><img src='../../../../skins/common/images/wiki.jpg' alt='[首页]' /></a>
<hr class='sep' /><a href="../../../index.html">首页</a>
<br /><a href="../../../c/o/m/WIKI-HIT_IBM_CLUB%7ECommunity_Portal_9150.html">社区</a>
<br /><a href="../../../c/u/r/Current_events.html">新闻动态</a>
<br /><a href="../../../r/e/c/Special%7ERecentchanges.html">最近更改</a>
<br /><a href="../../../r/a/n/Special%7ERandom.html">随机页面</a>
<br /><a href="../../../w/i/k/Wikipedia%7E%E5%B8%AE%E5%8A%A9.html">帮助</a>
<br /><a href="../../../s/i/t/WIKI-HIT_IBM_CLUB%7ESite_support.html">Donations</a>
<br />
<hr class='sep' /><strong><a href="../../../p/r/o/ProxyGroupDevDocs_cf81.html" title="ProxyGroupDevDocs">编辑本页</a></strong>
<br /><a href="../../../p/r/o/Talk%7EProxyGroupDevDocs_0dd0.html" class="new" title="Talk:ProxyGroupDevDocs">讨论本页</a>
<br /><a href="../../../p/r/o/ProxyGroupDevDocs_cf81.html" title="ProxyGroupDevDocs">较早版本</a>
<br /><a href="../../../w/h/a/Special%7EWhatlinkshere.html" title="Special:Whatlinkshere">链入页面</a>
<br /><a href="../../../r/e/c/Special%7ERecentchangeslinked.html" title="Special:Recentchangeslinked">链出更改</a>
<br /><hr class='sep' /><a href="../../../s/p/e/Special%7ESpecialpages.html" title="Special:Specialpages">特殊页面</a>
<br /><a href="../../../w/i/k/Wikipedia%7E%E9%94%99%E8%AF%AF%E6%8A%A5%E5%91%8A.html" title="Wikipedia:错误报告">错误报告</a>
<br /></div>
<!-- Served by dns.cs.hit.edu.cn in 1351392626.48 secs. -->
</body></html>