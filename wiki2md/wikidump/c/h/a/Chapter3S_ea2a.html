<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh-cn" lang="zh-cn" >
<head>
<title>Chapter3S - WIKI-HIT IBM CLUB</title>
<meta name="KEYWORDS" content="首页,ALP,Address,Android,Android Newbie Guide,Android Project Development,Android Research Field,Android Third Party Lib And Tool,BoardGame,CSAPP" />
<meta http-equiv="Content-type" content="text/html; charset=UTF-8" />
<meta name="robots" content="index,follow" />
<link rel="shortcut icon" href="/favicon.ico" />
<link rel='stylesheet' type='text/css' media='print' href='../../../../skins/common/wikiprintable.css' />
<script type="text/javascript" src="../../../../skins/common/wikibits.js"></script>
<style type='text/css'>
/*/*/ /*<![CDATA[*/
@import "../../../../skins/common/wikistandard.css";
@import "../../../s/t/a/MediaWiki%7EStandard.css.html";
a.new, #quickbar a.new { color: #CC2200; }
.editsection { display: none; }
#quickbar { position: absolute; top: 4px; left: 4px; border-right: 1px solid gray; }
#article { margin-left: 152px; margin-right: 4px; }

/*]]>*/ /* */
</style>
</head>

<body bgcolor='#FFFFFF' onload=''>

<div id='content'>
<div id='topbar'>
<table border='0' cellspacing='0' width='98%'>
<tr>
<td width='152' rowspan='1'>&nbsp;</td><td class="top" align='left' valign='top'>
<a href="../../../index.html" title="首页">首页</a> |
<a href="../../../r/e/c/Special%7ERecentchanges.html" title="Special:Recentchanges">最近更改</a> |
<a href="../../../c/h/a/Chapter3S_ea2a.html" title="Chapter3S">编辑本页</a> |
<a href="../../../c/h/a/Chapter3S_ea2a.html" title="Chapter3S">较早版本</a><p class='subtitle'><a href="../../../c/h/a/Chapter3S_ea2a.html">可打印版</a> | <a href="../../../g/e/n/WIKI-HIT_IBM_CLUB%7EGeneral_disclaimer.html" title="WIKI-HIT IBM CLUB:General disclaimer">Disclaimers</a></p>
</td>
<td class="top" valign='top' align='right' nowrap='nowrap'>Not logged in
<br /><a href="../../../u/s/e/Special%7EUserlogin.html" title="Special:Userlogin">登录</a> | <a href="../../../w/i/k/Wikipedia%7E%E5%B8%AE%E5%8A%A9.html" title="Wikipedia:帮助">帮助</a>
<br /><form name="search" class="inline" method="post" action="../../../s/e/a/Special%7ESearch.html">
<input type="text" name="search" size="19" value="" />
<input type="submit" name="go" value="进入" />&nbsp;<input type="submit" name="fulltext" value="搜索" />
</form></td></tr>
</table>
</div>

<div id='article'>
<h1 class="pagetitle">Chapter3S</h1><p class='subtitle'>Wikipedia，自由的百科全书</p>
<table id='toc' class='toc'><tr><td><div id='toctitle'><h2>目录</h2></div>
<ul>
<li class='toclevel-1'><a href="#.E7.BC.93.E5.86.B2.E8.BE.93.E5.85.A5.E8.BE.93.E5.87.BA"><span class="tocnumber">1</span> <span class="toctext">缓冲输入输出</span></a>
<ul>
<li class='toclevel-2'><a href="#.E7.94.A8.E6.88.B7.EF.BC.8D.E7.BC.93.E5.86.B2I.2FO"><span class="tocnumber">1.1</span> <span class="toctext">用户－缓冲I/O</span></a>
<ul>
<li class='toclevel-3'><a href="#.E5.9D.97.E5.A4.A7.E5.B0.8F"><span class="tocnumber">1.1.1</span> <span class="toctext">块大小</span></a></li>
<li class='toclevel-3'><a href="#.E6.96.87.E4.BB.B6.E6.8C.87.E9.92.88"><span class="tocnumber">1.1.2</span> <span class="toctext">文件指针</span></a></li>
</ul>
</li>
<li class='toclevel-2'><a href="#.E6.89.93.E5.BC.80.E6.96.87.E4.BB.B6"><span class="tocnumber">1.2</span> <span class="toctext">打开文件</span></a>
<ul>
<li class='toclevel-3'><a href="#.E6.A8.A1.E5.BC.8F"><span class="tocnumber">1.2.1</span> <span class="toctext">模式</span></a></li>
</ul>
</li>
<li class='toclevel-2'><a href="#.E9.80.9A.E8.BF.87.E6.96.87.E4.BB.B6.E6.8F.8F.E8.BF.B0.E7.AC.A6.E6.89.93.E5.BC.80.E6.96.87.E4.BB.B6"><span class="tocnumber">1.3</span> <span class="toctext">通过文件描述符打开文件</span></a></li>
<li class='toclevel-2'><a href="#.E5.85.B3.E9.97.AD.E6.B5.81"><span class="tocnumber">1.4</span> <span class="toctext">关闭流</span></a>
<ul>
<li class='toclevel-3'><a href="#.E5.85.B3.E9.97.AD.E6.89.80.E6.9C.89.E7.9A.84.E6.B5.81"><span class="tocnumber">1.4.1</span> <span class="toctext">关闭所有的流</span></a></li>
</ul>
</li>
<li class='toclevel-2'><a href="#.E4.BB.8E.E6.B5.81.E4.B8.AD.E8.AF.BB.E5.8F.96.E6.95.B0.E6.8D.AE"><span class="tocnumber">1.5</span> <span class="toctext">从流中读取数据</span></a>
<ul>
<li class='toclevel-3'><a href="#.E5.8D.95.E5.AD.97.E8.8A.82.E8.AF.BB.E5.8F.96"><span class="tocnumber">1.5.1</span> <span class="toctext">单字节读取</span></a>
<ul>
<li class='toclevel-4'><a href="#.E6.8A.8A.E5.AD.97.E7.AC.A6.E5.9B.9E.E6.94.BE.E5.85.A5.E6.B5.81.E4.B8.AD"><span class="tocnumber">1.5.1.1</span> <span class="toctext">把字符回放入流中</span></a></li>
</ul>
</li>
<li class='toclevel-3'><a href="#.E6.8C.89.E8.A1.8C.E7.9A.84.E8.AF.BB.E5.8F.96"><span class="tocnumber">1.5.2</span> <span class="toctext">按行的读取</span></a>
<ul>
<li class='toclevel-4'><a href="#.E8.AF.BB.E5.8F.96.E4.BB.BB.E6.84.8F.E5.AD.97.E7.AC.A6.E4.B8.B2"><span class="tocnumber">1.5.2.1</span> <span class="toctext">读取任意字符串</span></a></li>
</ul>
</li>
<li class='toclevel-3'><a href="#.E8.AF.BB.E5.8F.96.E4.BA.8C.E8.BF.9B.E5.88.B6.E6.96.87.E4.BB.B6"><span class="tocnumber">1.5.3</span> <span class="toctext">读取二进制文件</span></a></li>
</ul>
</li>
<li class='toclevel-2'><a href="#.E5.90.91.E6.B5.81.E4.B8.AD.E5.86.99.E6.95.B0.E6.8D.AE"><span class="tocnumber">1.6</span> <span class="toctext">向流中写数据</span></a>
<ul>
<li class='toclevel-3'><a href="#.E5.86.99.E5.85.A5.E5.8D.95.E4.B8.AA.E5.AD.97.E7.AC.A6"><span class="tocnumber">1.6.1</span> <span class="toctext">写入单个字符</span></a></li>
<li class='toclevel-3'><a href="#.E5.86.99.E5.85.A5.E5.AD.97.E7.AC.A6.E4.B8.B2"><span class="tocnumber">1.6.2</span> <span class="toctext">写入字符串</span></a></li>
<li class='toclevel-3'><a href="#.E5.86.99.E5.85.A5.E4.BA.8C.E8.BF.9B.E5.88.B6.E6.95.B0.E6.8D.AE"><span class="tocnumber">1.6.3</span> <span class="toctext">写入二进制数据</span></a></li>
</ul>
</li>
<li class='toclevel-2'><a href="#.E7.BC.93.E5.86.B2.E8.BE.93.E5.85.A5.E8.BE.93.E5.87.BA.E7.A4.BA.E4.BE.8B.E7.A8.8B.E5.BA.8F"><span class="tocnumber">1.7</span> <span class="toctext">缓冲输入输出示例程序</span></a></li>
<li class='toclevel-2'><a href="#.E5.9C.A8.E6.B5.81.E4.B8.AD.E6.90.9C.E7.B4.A2"><span class="tocnumber">1.8</span> <span class="toctext">在流中搜索</span></a>
<ul>
<li class='toclevel-3'><a href="#.E8.8E.B7.E5.BE.97.E5.BD.93.E5.89.8D.E6.B5.81.E4.BD.8D.E7.BD.AE"><span class="tocnumber">1.8.1</span> <span class="toctext">获得当前流位置</span></a></li>
</ul>
</li>
<li class='toclevel-2'><a href="#.E6.B8.85.E9.99.A4.E6.B5.81"><span class="tocnumber">1.9</span> <span class="toctext">清除流</span></a></li>
<li class='toclevel-2'><a href="#.E9.94.99.E8.AF.AF.E5.92.8C.E6.96.87.E4.BB.B6.E7.BB.93.E6.9D.9F"><span class="tocnumber">1.10</span> <span class="toctext">错误和文件结束</span></a></li>
<li class='toclevel-2'><a href="#.E8.8E.B7.E5.BE.97.E5.85.B3.E8.81.94.E7.9A.84.E6.96.87.E4.BB.B6.E6.8F.8F.E8.BF.B0.E7.AC.A6"><span class="tocnumber">1.11</span> <span class="toctext">获得关联的文件描述符</span></a></li>
<li class='toclevel-2'><a href="#.E6.8E.A7.E5.88.B6.E7.BC.93.E5.86.B2"><span class="tocnumber">1.12</span> <span class="toctext">控制缓冲</span></a></li>
<li class='toclevel-2'><a href="#.E7.BA.BF.E7.A8.8B.E5.AE.89.E5.85.A8"><span class="tocnumber">1.13</span> <span class="toctext">线程安全</span></a>
<ul>
<li class='toclevel-3'><a href="#.E6.89.8B.E5.8A.A8.E6.96.87.E4.BB.B6.E5.8A.A0.E9.94.81"><span class="tocnumber">1.13.1</span> <span class="toctext">手动文件加锁</span></a></li>
<li class='toclevel-3'><a href="#.E6.9C.AA.E5.8A.A0.E9.94.81.E6.B5.81.E6.93.8D.E4.BD.9C"><span class="tocnumber">1.13.2</span> <span class="toctext">未加锁流操作</span></a></li>
</ul>
</li>
<li class='toclevel-2'><a href="#.E5.AF.B9.E6.A0.87.E5.87.86.E8.BE.93.E5.85.A5.E8.BE.93.E5.87.BA.E7.9A.84.E6.89.B9.E8.AF.84"><span class="tocnumber">1.14</span> <span class="toctext">对标准输入输出的批评</span></a></li>
<li class='toclevel-2'><a href="#.E7.BB.93.E8.AE.BA"><span class="tocnumber">1.15</span> <span class="toctext">结论</span></a></li>
</ul>
</li>
</ul>
</td></tr></table>
<p><script type="text/javascript"> if (window.showTocToggle) { var tocShowText = "显示"; var tocHideText = "隐藏"; showTocToggle(); } </script>
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../c/h/a/Chapter3S_ea2a.html" title="Chapter3S">编辑</a>]</div><a name=".E7.BC.93.E5.86.B2.E8.BE.93.E5.85.A5.E8.BE.93.E5.87.BA"></a><h1>缓冲输入输出</h1>
<p>回忆第一章，块，一种文件抽象，是输入输出的通用语——所有的磁盘操作都是通过块实现的。因此，如果请求是执行在块大小整数倍的对齐地址处，此时的输入输出操作是最理想的。
</p><p>操作效率随着要求读写的系统调用次数的增多而不同，例如，读1024次，每次读一字节跟一次读1024字节相比，显然后者效率更优。如果空间大小不是bolck的整数倍， 即使一系列的操作执行在比块更大的空间上也不会是最优的。例如，如果块的大小是1K, 执行在1130B的块上的操作可能比1024B操作要慢。
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../c/h/a/Chapter3S_ea2a.html" title="Chapter3S">编辑</a>]</div><a name=".E7.94.A8.E6.88.B7.EF.BC.8D.E7.BC.93.E5.86.B2I.2FO"></a><h2>用户－缓冲I/O</h2>
<p>需要对文件执行许多小规模I/O请求的程序通常使用用户缓冲I/O.这指的是缓冲执行在空间下，由应用程序自动执行，或是由标准库显式的执行， 而不是在内核下的缓冲。正如第二章中讨论的，因为执行的原因，内核通过延迟写操作，联合相邻的I/O请求和预读等操作来缓冲数据。通过不同的方式，用户缓冲也可以达到提高操作效率的目的。
</p><p>举一个使用用户空间的程序dd的例子：
</p>
<pre> dd bs=1 count=2097152 if=/dev/zero of=pirate
</pre>
<p>因为参数bs=1,这个命令会用2，097，152次但字节操作从文件/dev/zero(一个提供无限的0文件流的抽象文件)中拷贝2M到file pirate中。就是说，这个命令会通过大约2百万次的读写操作——每次一个字节。
</p><p>现在考虑相同的2M 字节拷贝，但是使用1024字节的块:
</p>
<pre> dd bs=1024 count=2048 if=/dev/zero of=pirate
</pre>
<p>这个操作复制相同的2M 字节内容到相同的文件中，但是只执行1024次读写操作。正如你在表3－1中看到的，效率提高是很显著的。这儿，我记录了用四个只在块大小上有区别的dd命令耗费的时间（用三种不同的测量）。实际时间是总消耗的时钟时间，用户时间是在用户空间中执行程序代码的时间，而系统时间指的是在内核空间中从进程的角度看执行系统调用花费的时间。
</p><p>表3-1.　块大小对性能的影响
</p>
<pre>Block size 　　　Real time 　　　　User time 　　　 System time
1 byte 　　　　  18.707 seconds 　1.118 seconds 　17.549 seconds
1,024 bytes　 　0.025 seconds 　　0.002 seconds 　0.023 seconds
1,130 bytes 　　0.035 seconds 　　0.002 seconds 　0.027 seconds
</pre>
<p>用1024B大小操作和1B相比产生了巨大的改善。但是，这个表也显示用一个更大的块大小——这隐含较少的系统调用——会导致效率变差，如果块大小不是磁盘块大小的整数倍。即使需要更少的调用，1130B的请求导致产生不对齐的操作，因此比1024B的请求要低效。
</p><p>利用这种特性要求先知道可能的物理块大小。表中显式的结果表明快大小最可能是1024，1024的整数倍，或者1024的约数。在/dev/zero的例子中，块大小实际上是4096B。
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../c/h/a/Chapter3S_ea2a.html" title="Chapter3S">编辑</a>]</div><a name=".E5.9D.97.E5.A4.A7.E5.B0.8F"></a><h3>块大小</h3>
<p>实际应用中，块大小一般是512B， 1024B， 2048B， 或4096B. 如表3－1中显示，一个很大的效率提高只是通过在一个是块大小整数倍或约数的块上执行。这是因为内核和硬件之间是通过块交互的。所以，使用块大小或者一个能够恰好能放入一个块中的值保证请求是块对齐的，而且防止了无关的内核操作。
</p><p>通过用系统调用stat()或stat(1)可以轻松获得块大小(第七章). 但通常不需要知道确切的块大小.
</p><p>为你的I/O操作选择一个大小的主要目标是不要选择一个奇怪的大小例如1130。Unix的历史上没有块是1130B的， 而且选择这样的大小会导致第一次操作后不对齐的I/O。但是使用块大小的整数倍或约数就可以防止不对齐的请求。只要你选择的大小保持所有操作块对齐, 效率就会好。大的整数倍只是减少了系统调用。
/*******
</p><p>然而,最简单的方法是用一个大小为标准块大小整数倍的缓冲区来执行I/O. 4096和8192B都可以很好的运作.
</p><p>当然,问题是程序很少以块为单位执行.程序以区域,行,和单个字符而不是抽象的块之类的.如早先描述的,为了改善这种情况,程序调用用户缓冲I/O. 当数据被写入时,它会被存储在程序执行空间的缓冲区中.当缓冲区规模达到一个给定的值--缓冲区大小时--整个缓冲区会在一次操作中被写出。同理，数据用缓冲大小的，块对齐的区域来读取。当应用程序执行不对齐的读请求时，缓冲区一块一块的给出数据。最后，当缓冲区为空时，另一个大的块对齐的区域又被读进。如果缓冲区的大小合适，可以实现很大的效率改善。
</p><p>手工在你的程序中实现用户缓冲是可能的。事实上很多执行很复杂任务的程序就是这么做的。然而大部分程序利用通用的标准输入输出库(C标准库的一部分)，这个库可以提供健壮而且功能强大的用户缓冲方案。
标准输入输出
</p><p>C标准库提供了能够实现跨平台用户缓冲的标准输入输出库(通常简单称作stdio)。这个标准输入输出库使用简单，而且功能强大。
</p><p>不像编程语言FORTRAN, C语言并没有引入任何内嵌支持，和提供比流控制，算术运算等等--当然也没有输入输出的继承支持。随着C语言的发展，用户形成了一些关键功能的例程，例如字符串控制，数学例程，时间日期功能，和I/O。随着时间的推移，这些例程成熟了，在ANSI C委员会的许可下(C89) 最终形成了C语言标准库。虽然C95和C99都加入了一些新的接口，标准输入输出和1989年创造的时候相比改变不大。本章余下的部分讨论用户缓冲输入输出因为它属于文件输入输出，而且在C标准库中实现了-就是说，通过C标准库打开，关闭，读写文件。一个程序是否需要使用标准输入输出，用户缓冲方法，或是直接系统调用是由设计者仔细权衡程序的需要和行为后决定的。C标准库通常会给每个实现留些细节的地方， 而且实现通常加入扩充的特征。这章，和本书的其它章节一样，证明了一个现代Linux系统的实现和行为是用glibc实现的。在Linux偏离基本标准的时候这会指明。
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../c/h/a/Chapter3S_ea2a.html" title="Chapter3S">编辑</a>]</div><a name=".E6.96.87.E4.BB.B6.E6.8C.87.E9.92.88"></a><h3>文件指针</h3>
<p>标准输入输出例程并不直接在文件描述符上执行。取而代之，它们用自己唯一的标志符，大家知道的文件指针。在C标准库里，文件指针映射到一个文件描述符。文件指针表示一个指向定义在&lt;stdio.h&gt;中的文件别名的指针。
</p><p>在标准输入输出说法中,一个打开的文件叫做流. 流可以被打开用来读(输入流), 写(输出流),或者二者都有(输入输出流).
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../c/h/a/Chapter3S_ea2a.html" title="Chapter3S">编辑</a>]</div><a name=".E6.89.93.E5.BC.80.E6.96.87.E4.BB.B6"></a><h2>打开文件</h2>
<p>文件通过fopen()打开用来读写:
</p>
<pre>#include &lt;stdio.h&gt;
FILE* fopen (const char * path, const char * mode);
</pre>
<p>这个函数根据给定的模式打开文件路径,并为它联提供一个新的流.
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../c/h/a/Chapter3S_ea2a.html" title="Chapter3S">编辑</a>]</div><a name=".E6.A8.A1.E5.BC.8F"></a><h3>模式</h3>
<p>这个模式参数描述怎样打开指定的文件. 它是以下几个字符串中的一个:
</p><p>r 
</p>
<pre>   打开文件用来读出.流被设置在文件的开始处.
</pre>
<p>r+ 
</p>
<pre>   打开文件用来读写.流被设置在文的开始.
</pre>
<p>w
</p>
<pre>   打开文件用来写入,如果文件存在, 文件会被清空. 如果文件不存在,它会被创建.流被设置在文件的开始处.\
</pre>
<p>w+
</p>
<pre>   打开文件用来读写.如果文件存在,文件会被清空.如果文件不存在,它会被创建.流被设置在文件的开始.
</pre>
<p>a
</p>
<pre>   打开文件用来添加模式的写入.如果文件不存在它会被创建.流被设置在文件的末尾.所有的写入都会接在文件后.
</pre>
<p>a+
</p>
<pre>   打开文件用来添加模式的读写.如果文件不存在 它会被创建.流被设置在文件的末尾. 所有的写入都会接在文件后.
</pre>
<p>给定的模式可能还有字符b,虽然这个值在Linux下通常会被忽略. 一些操作系统用不同的方式对待文本和二进制文件, 并且b模式指示文件用二进制打开.Linux, 和所有的符合可移植性的操作系统,以相同的方式对待文本和二进制文件.
</p><p>成功时,fopen()返回一个合理的文件指针. 失败时,它返回NULL,而且相应的设置errno.
</p><p>例如,下面的代码打开etc/manifest用来读出,而且为它提供一个流:
</p>
<pre>FILE *stream;
stream = fopen ("/etc/manifest", "r");
if (!stream)
    /* error */
</pre>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../c/h/a/Chapter3S_ea2a.html" title="Chapter3S">编辑</a>]</div><a name=".E9.80.9A.E8.BF.87.E6.96.87.E4.BB.B6.E6.8F.8F.E8.BF.B0.E7.AC.A6.E6.89.93.E5.BC.80.E6.96.87.E4.BB.B6"></a><h2>通过文件描述符打开文件</h2>
<p>	函数fdopen()把一个已经打开的文件描述符(fd)转成一个流:
	#include &lt;stdio.h&gt;
FILE * fdopen (int fd, const char *mode);
	可能的模式和fopen()一样,而且必许和原来打开文件描述符的模式匹配. 模式w和w+可以匹配,但是它们不会导致切断.流被设置在文件的开始处加上文件的描述符.
	一旦一个文件描述符被转换为一个流, 输入输出不应再直接在文件描述符上操作. 然而,这是合法的.注意文件描述符不是被复制,而只是联合了一个新的流.关闭流也会关闭相应的文件描述符.
成功时,fdoepn()返回一个合法的文件指针;失败时,返回NULL. 
	例如, 下面的代码通过open()系统调用打开/home/kidd/map.txt,然后用已有的文件描述符创建一个关联的流:
FILE *stream;
int fd;
fd = open ("/home/kidd/map.txt", O_RDONLY);
if (fd == &#8722;1)
/* error */
stream = fdopen (fd, "r");
if (!stream)
/* error */
</p><p>/******
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../c/h/a/Chapter3S_ea2a.html" title="Chapter3S">编辑</a>]</div><a name=".E5.85.B3.E9.97.AD.E6.B5.81"></a><h2>关闭流</h2>
<p>fclose()函数关闭一个给定的流：
	#include &lt;stdio.h&gt;
	int fclose (FILE *stream);
所有缓冲但还没有被写出的数据会被先写出。成功时，fclose()返回0。失败时返回EOF并且相应的设置errno。
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../c/h/a/Chapter3S_ea2a.html" title="Chapter3S">编辑</a>]</div><a name=".E5.85.B3.E9.97.AD.E6.89.80.E6.9C.89.E7.9A.84.E6.B5.81"></a><h3>关闭所有的流</h3>
<p>fcloseall()函数关闭所有的和当前相关的流，包括标准输入，标准输出，标准异常：
</p>
<pre>#define _GNU_SOURCE
#include &lt;stdio.h&gt;
int fcloseall (void);
</pre>
<p>关闭之前，所有的的流会被清空。这个函数始终返回0；这是Linux特有的。
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../c/h/a/Chapter3S_ea2a.html" title="Chapter3S">编辑</a>]</div><a name=".E4.BB.8E.E6.B5.81.E4.B8.AD.E8.AF.BB.E5.8F.96.E6.95.B0.E6.8D.AE"></a><h2>从流中读取数据</h2>
<p>C标准库实现了多种从各种各样的流中读取数据的方法。这部分会考察三种最常用的读取方法：单个字节的读取，单行的读取，和二进制读取。为了从流中读取，流必须以输入流的相关方式打开；就是说，任何除了w或a的合理模式。
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../c/h/a/Chapter3S_ea2a.html" title="Chapter3S">编辑</a>]</div><a name=".E5.8D.95.E5.AD.97.E8.8A.82.E8.AF.BB.E5.8F.96"></a><h3>单字节读取</h3>
<p>通常，理想的输入输出模式是每次简单的读取一个字符。函数fgetc()可以用来从流中读取单个字符：
</p>
<pre>#include &lt;stdio.h&gt;
int fgetc (FILE *stream);
</pre>
<p>这个函数从流中读取下一个字符并把该无符号字符强转为int返回。强转是为了有足够的范围来表示文件结尾符和错误:在这种情况下EOF会被返回。fgetc()的返回值必须以int型存。把返回值用char存是一个很常见但也很危险的错误。
下面的例子从流中读取单个字符，检查错误，然后以字符方式打印结果：
</p>
<pre>int c;
c = fgetc (stream);
if (c == EOF)
/* error */
else
printf ("c=%c\n", (char) c);
</pre>
<p>stream指向的流必须被打开用来读取。 
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../c/h/a/Chapter3S_ea2a.html" title="Chapter3S">编辑</a>]</div><a name=".E6.8A.8A.E5.AD.97.E7.AC.A6.E5.9B.9E.E6.94.BE.E5.85.A5.E6.B5.81.E4.B8.AD"></a><h4>把字符回放入流中</h4>
<p>标准输入输出提供了一个将字符推回流中的函数。这个函数允许你“偷窥”流，如果你不需要该字符的话，可以把它放回。
</p>
<pre>#include &lt;stdio.h&gt;
int ungetc (int c, FILE *stream);
</pre>
<p>每次调用把c强转成一个无符号字符推回流中。成功时，返回c;失败时返回EOF。随后读取流会返回c.如果多个字符被推入流中，它们会以倒序的方式返回－就是说，最后推入的先返回。POSIX 指出中间没有读入请求时只有一次推回能够保证成功。 然而有些实现之允许一次推回。Linux允许无限次数的推回，只要有足够的内存。一次推回当然总会成功。
</p><p>如果你如果你在调用ungetc()之后，但在执行下一个读入请求之前执行了一次查找函数(见本章后半部分'查找流')的调用，会导致所有推回的字符被丢弃。在一个进程的多个线程中确实是这样的，因为所有的线程共享一个缓冲区。
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../c/h/a/Chapter3S_ea2a.html" title="Chapter3S">编辑</a>]</div><a name=".E6.8C.89.E8.A1.8C.E7.9A.84.E8.AF.BB.E5.8F.96"></a><h3>按行的读取</h3>
<p>函数fgets()从一个给定的流中读取一个字符串:
</p>
<pre>#include &lt;stdio.h&gt;
char * fgets (char *str, int size, FILE *stream);
</pre>
<p>这个函数从流中读取比size小一个字节的数据，并把数据存入str中。 当所有字节读入时，空字符被存入字符串末尾。当读到EOF或换行符时读入结束。如果读到了一个换行符，'\n'被存入str。
</p><p>成功时返回str；失败时，返回NULL。
例如：
</p>
<pre>char buf[LINE_MAX];
if (!fgets (buf, LINE_MAX, stream))
      /* error */
</pre>
<p>POSIX 在&lt;limits.h&gt;中定义了宏LINE_MAX： 它是POSIX行控制接口能够处理的输入行的最大长度。linux的C函数库没有提供这样的限制－行可以是任意长度－但是没有办法和宏LINE_MAX通信。可移植程序可以用LINE_MAX来保证安全；在linux系统中，它被设置的相对较高。针对linux的程序无需担心行大小的限制。
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../c/h/a/Chapter3S_ea2a.html" title="Chapter3S">编辑</a>]</div><a name=".E8.AF.BB.E5.8F.96.E4.BB.BB.E6.84.8F.E5.AD.97.E7.AC.A6.E4.B8.B2"></a><h4>读取任意字符串</h4>
<p>通常，fgets()基于行的读取是有用的。但很多时候它又很麻烦。有时后开发者想用一个分隔符而不是换行符。有时候开发者根本不需要一个分隔符－而且极少数情况下开发者希望分隔符留在缓冲区。相比之下，在返回的缓冲区中存入换行符很少是正确的。
</p><p>用fgetc()写一个fgets()并不难。例如，下面的小片段从流中读取n-1个字节到str中，然后加上一个'\0'：
</p>
<pre>char *s; 
int c;
s = str;
while (--n &gt; 0 &amp;&amp; (c = fgetc (stream))&nbsp;!= EOF)
   *s++ = c;
*s = '\0';
</pre>
<p>这段程序一也可以扩展为在任意一个分隔符处停止，假如是d(在这个例子中不能是空字符)：
</p>
<pre>char *s;
int c = 0;
s = str;
while (--n &gt; 0 &amp;&amp; (c = fgetc (stream))&nbsp;!= EOF &amp;&amp; (*s++ = c)&nbsp;!= d)
  &nbsp;;
if (c == d)
   *--s = '\0';
else
    *s = '\0';、
</pre>
<p>d设置为'\n'可以提供和fgets()类似的功能，除了在缓冲区中存入换行符。
</p><p>根据fgets()的实现，这个函数可能要慢些，因为它重复调用了很多此fgetc(). 然而，这和我们一开始的dd例子不是一个问题。虽然这端代码出现了过多的函数掉用，它没有出现过多的系统调用和dd程序中bs＝1引起的不对齐输入输出负担。后者是更大的问题。
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../c/h/a/Chapter3S_ea2a.html" title="Chapter3S">编辑</a>]</div><a name=".E8.AF.BB.E5.8F.96.E4.BA.8C.E8.BF.9B.E5.88.B6.E6.96.87.E4.BB.B6"></a><h3>读取二进制文件</h3>
<p>对一些应用程序，只有字符读取是不够的。有时候开发者想读写复杂的二进制数据，例如C中的结构。
因此，标准输入输出库提供了函数fread():
</p>
<pre>#include &lt;stdio.h&gt;
size_t fread (void *buf, size_t size, size_t nr, FILE *stream);
</pre>
<p>调用fread()会从输入流中读取nr个数据，每个数据size个字节，到buf所指向的缓冲区。文件指针向前移动读出数据的长度。
</p><p>读入元素的个数（不是读入字节的个数!）被返回。这个函通过返回一个比nr小的数表明读取失败或文件结束。不幸的是，在没有使用ferror()和feof()（见后面"错误和文件结束"）的情况下，不可能知道发生了这两种情况的哪一个。
</p><p>因为变量大小，对齐，连接，字节顺序的不同，一个程序写的二进制文件可能对另一个文件是不可读的，或者即使是在不同机器上的相同程序。
</p><p>fread()最简单的例子是从给定流中读取一个线性大小的元素：
</p>
<pre>char buf[64];
size_t nr;
nr = fread (buf, sizeof(buf), 1, stream);
if (nr == 0)
     /* error */
</pre>
<p>当我们学习和fread()相对应的fwrite()时，我们会看一些更复杂的例子。
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../c/h/a/Chapter3S_ea2a.html" title="Chapter3S">编辑</a>]</div><a name=".E5.90.91.E6.B5.81.E4.B8.AD.E5.86.99.E6.95.B0.E6.8D.AE"></a><h2>向流中写数据</h2>
<p>和读取相同，C标准库定义了许多用来将数据写入流中的函数。这一部分会看三个最常用的最写数据的方法：单个字节的写入，字符串写入，和二进制写入。这些不同的写入方法很好地符合了缓冲输入输出。为了向流中些数据，流必须以输出流相应的模式打开；就是说，除了r的所有合法的模式。
</p><p>对齐的讨论
</p><p>所有的机器设计都有数据对齐的要求。程序员倾向于把内存想成一个简单的数组。但是处理器并不以字符大小对内存进行读写。相反，处理器以特定的间隔例如2，4，8或16字节访问内存。因为每个处理的地址空间都从0地址开始，处理必须从一个特定间隔的整数倍处开始。
</p><p>因此，C变量的存储和访问都要是地址对齐的。总的来说，变量是自动对齐的，这指的是和C数据类型大小相关的对齐。例如，一个32位整数以4个字节边界对齐。用另一种说法就是一个int需要被存储在能被4整除的地址。
</p><p>访问不对齐的数据会有不同程度的惩罚，这取决于机器的设计。一些处理器能够访问不对齐的数据，但是会有一个大的效率惩罚。其它的处理器根本不能够访问非对齐的数据，而且企图这么做会导致硬件异常。更糟的是，一些处理器为了强制地址对齐自动跳过了低位的数据，几乎总会导致不可预料的行为。
</p><p>通常，编译器自动对齐数据，而且对齐是程序员不可见的。处理结构体，手动执行内存管理，向磁盘存储二进制数据，和通过网络通信会使得对齐变得很重要。因此系统程序员应当熟练掌握这些方法。
</p><p>第八章会更深入的讨论对齐的内容。
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../c/h/a/Chapter3S_ea2a.html" title="Chapter3S">编辑</a>]</div><a name=".E5.86.99.E5.85.A5.E5.8D.95.E4.B8.AA.E5.AD.97.E7.AC.A6"></a><h3>写入单个字符</h3>
<p>与fgetc()相对应的函数是fputc():
</p>
<pre>#include &lt;stdio.h&gt;
int fputc (int c, FILE *stream);
</pre>
<p>fputc()函数将c表示的字节(强转为了一个无符号字符串)写入stream指向的流中。成功完成时，函数返回c。否则返回EOF，并且相应的设置errno。
</p><p>应用很简单
</p>
<pre>if (fputc ('p', stream) == EOF)
    /* error */
</pre>
<p>这个例子将p写入流中，这个流必须打开用于写入。
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../c/h/a/Chapter3S_ea2a.html" title="Chapter3S">编辑</a>]</div><a name=".E5.86.99.E5.85.A5.E5.AD.97.E7.AC.A6.E4.B8.B2"></a><h3>写入字符串</h3>
<p>函数fputs()用来用给定的流中写入一个完整的字符串：
</p>
<pre>#include &lt;stdio.h&gt;
int fputs (const char *str, FILE *stream);
</pre>
<p>fputs()的调用将str指向的字符串的所有非分隔符部分写入stream指向的流中。成功时，fputs()返回一个非负整数。失败时，返回EOF。
</p><p>下面的例子用增加模式打开文件用来写入，将给定的字符串写入相关的流中，然后关闭流：
</p>
<pre>stream = fopen ("journal.txt", "a");
if (!stream)
    /* error */
if (fputs ("The ship is made of wood.\n", stream) == EOF)
    /* error */
if (fclose (stream) == EOF)
    /* error */
</pre>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../c/h/a/Chapter3S_ea2a.html" title="Chapter3S">编辑</a>]</div><a name=".E5.86.99.E5.85.A5.E4.BA.8C.E8.BF.9B.E5.88.B6.E6.95.B0.E6.8D.AE"></a><h3>写入二进制数据</h3>
<p>单独字符和行并不能满足需要如果程序需要写入二进制数据。为了直接存储二进制数据例如C变量，标准输入书出提供了fwrite()函数:
</p>
<pre>#include &lt;stdio.h&gt;
size_t fwrite (void *buf,
size_t size,
size_t nr,
FILE *stream);
</pre>
<p>调用fwrite()会把buf指向的nr个元素写入到stream中，每个元素长为size。文件指针会前进写入的所有字节的长度。
</p><p>成功写入元素的个数(不是字节的个数!)会被返回。返回小于nr的数表明发生了错误。
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../c/h/a/Chapter3S_ea2a.html" title="Chapter3S">编辑</a>]</div><a name=".E7.BC.93.E5.86.B2.E8.BE.93.E5.85.A5.E8.BE.93.E5.87.BA.E7.A4.BA.E4.BE.8B.E7.A8.8B.E5.BA.8F"></a><h2>缓冲输入输出示例程序</h2>
<p>现在让我们看一个例子－实际上是一个完整的程序－它综合了本章之前涉及到的许多接口。这个程序首先定义了一个结构pirate，然后声明了两个这个类型的变量。程序初始化了其中的一个变量，随后通过一个指向文件dada的输出流将它写入磁盘中。
通过一个不同的流，程序直接从data中读取数据存储到pirate结构的另一个实例中。最后程序把这个结构的内容输出到标准输出:
</p>
<pre>#include &lt;stdio.h&gt;
int main (void)
{
   FILE *in, *out;
   struct pirate
   {
       char name[100]; /* real name */
       unsigned long booty; /* in pounds sterling */
       unsigned int beard_len; /* in inches */
   } p, blackbeard = { "Edward Teach", 950, 48 };
   out = fopen ("data", "w");
   if (!out)
   {
       perror ("fopen");
       return 1;
   }
   if (!fwrite (&amp;blackbeard, sizeof (struct pirate), 1, out))
   {
       perror ("fwrite");
       return 1;
   }
   if (fclose (out))
   {
       perror ("fclose");
       return 1;
   }
   in = fopen ("data", "r");
   if (!in)
   {
       perror ("fopen");
       return 1;
   }
   if (!fread (&amp;p, sizeof (struct pirate), 1, in))
   {
       perror ("fread");
       return 1;
   }
   if (fclose (in))
   {
       perror ("fclose");
       return 1;
   }
   printf ("name=\"%s\" booty=%lu beard_len=%u\n",
           p.name, p.booty, p.beard_len);
   return 0;
}
</pre>
<p>输出结果当然是原来的值:
</p>
<pre>name="Edward Teach" booty=950 beard_len=48
</pre>
<p>再一次强调，牢记因为变量长度，对齐等等的不同，一个程序写出的二进制数据对另外一个程序可能是不可读的。就是说，不同的程序－即使是不同机器上的相同程序－可能不能正确地读取fwrite()写入的数据。在我们的例子中，考虑交错的情况如果无符号长整型的大小改变了，或者填充的数量改变了。这些东西只能在拥有特定ABI的特定机型上才能保证相同。
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../c/h/a/Chapter3S_ea2a.html" title="Chapter3S">编辑</a>]</div><a name=".E5.9C.A8.E6.B5.81.E4.B8.AD.E6.90.9C.E7.B4.A2"></a><h2>在流中搜索</h2>
<p>通常，控制当前流的位置是很有用的。可能程序正在读取一个复杂的以记录为基础的文件，而且需要跳转。必要的时候，流可能需要被设置为文件的初始位置。不管什么情况，标准输入输出提供了一系列功能等价于系统调用lseek()的接口(第二章中讨论过)。fseek()函数，标准输入输出最常用的查找接口，操纵流指向文件中由offset和whence指定的位置:
</p>
<pre>#include &lt;stdio.h&gt;
int fseek (FILE *stream, long offset, int whence);
</pre>
<p>如果whence被设置为SEEK_SET,文件的位置被设置到offset处。如果whence被设置为SEEK_CUR,文件位置被设置到当前位置加上offset.如果whence被设置为SEEK_END,文件位置被设置到文件末尾加上offset.
</p><p>成功时,fseek()返回0，清空文件结束标志，并且取消ungetc()操作。错误时，它返回－1，并且相应的设置errno.最常见的错误有非法流(EBADF)和非法whence参数(EINVAL).可选择的，标准输入输出提供了fsetpos()函数:
</p>
<pre>#include &lt;stdio.h&gt;
int fsetpos (FILE *stream, fpos_t *pos);
</pre>
<p>这个函数将流的位置设置到pos处。它也有和fseek()函数相同的值为SEEK_SET的whence参数。成功时它返回0。否则，返回-1,并且相应地设置errno的值。这个函数(和将要学到的对应的fgetpos()函数)只在其它(非UNIX)能够用复杂数据类型表示流的位置的平台上提供。在这些平台上，这个函数是唯一的能够将流位置设置为任意值　的方法，因为Ｃ的长整型可能不够大。针对linux的程序尽管可以但不需要使用这个接口，如果它们希望能够被移植到所有的平台上。
</p><p>标准输入输出也提供了rewind()函数，下面是一个片段：
</p>
<pre>#include &lt;stdio.h&gt;
void rewind (FILE *stream);、
</pre>
<p>这个调用：
</p>
<pre>rewind(stream);
</pre>
<p>将位置重置到流的初始位置。它等价于:
</p>
<pre>fseek (stream, 0, SEEK_SET);
</pre>
<p>除了它还清空错误标记。
注意rewind()没有返回值，因此不能够直接提供错误信息。调用函数希望确认特定错误的存在需要在调用之前清空errno，并且检查这个变量之后是否非零。例如：
</p>
<pre>errno = 0;
rewind (stream);
if (errno)
    /* error */
</pre>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../c/h/a/Chapter3S_ea2a.html" title="Chapter3S">编辑</a>]</div><a name=".E8.8E.B7.E5.BE.97.E5.BD.93.E5.89.8D.E6.B5.81.E4.BD.8D.E7.BD.AE"></a><h3>获得当前流位置</h3>
<p>和lseek()不同，fseek()不返回更新的位置。一个单独的接口提供了这个功能。ftell()函数返回当前流的位置:
</p>
<pre>#include &lt;stdio.h&gt;
long ftell (FILE *stream);
</pre>
<p>错误时，它返回-1，并且相应的设置errno。选择性的，标准输入输出提供了fgetpos()函数：
</p>
<pre>#include &lt;stdioh.h&gt;
int fgetpos (FILE *stream, fpos_t *pos);
</pre>
<p>成功时，fgetpos()返回０，并且将当前流的位置设置为pos.失败时，返回-1,并且相应的设置errno。和fsetpos()一样，fgetpos()只在有复杂文件位置类型的非linux平台上提供。
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../c/h/a/Chapter3S_ea2a.html" title="Chapter3S">编辑</a>]</div><a name=".E6.B8.85.E9.99.A4.E6.B5.81"></a><h2>清除流</h2>
<p>标准输入输出库提供了一个用来把缓冲区写到内核，并且保证所有的数据都是通过write()函数写出的接口。fflush()函数提供了这一功能：
</p>
<pre>#include &lt;stdio.h&gt;
int fflush (FILE *stream);
</pre>
<p>调用该函数时，stream指向的流中的所有未写入的数据会被冲洗到内核中。如果stream是空的，所有进程打开的流会被冲洗掉。成功时fflush()返回0。失败时，它返回EOF，并且相应的设置errno。
</p><p>为了理解fflush()函数的作用，你必须理解C函数库维持的缓冲区和内核自己拥有的缓冲区的区别。所有的本章描述的调用都是通过C函数库来维护的，它们保留在用户空间中，而不是内核空间。这就是效率提高的原因－程序保留在用户空间中，并且运行用户的代码，不执行系统调用。只有当磁盘或其它介质必须被访问时系统调用才会被执行。
fflush() 只是把用户缓冲的数据写入到内核缓冲区。效果和没有用户缓冲区一样，而且write()是被直接调用的。这并不保证数据物理上委托于任何介质－如果需要那种功能的话，用fsync（）这一类函数(见第二章同时I/O).更可能的是你希望调用fflush(), 然后立即调用fsync(): 就是说先保证用户缓冲区被写入到内核，然后保证内核缓冲区被写入到磁盘。
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../c/h/a/Chapter3S_ea2a.html" title="Chapter3S">编辑</a>]</div><a name=".E9.94.99.E8.AF.AF.E5.92.8C.E6.96.87.E4.BB.B6.E7.BB.93.E6.9D.9F"></a><h2>错误和文件结束</h2>
<p>一些标准I/O接口，例如fread(), 向调用者传递失败的能力很差，因为它们没有提供区分错误和EOF的原理。 执行这些调用时而其它一些场合，检查给定的流确定是否已经出现错误或是到文件结尾很有用。标准输入输出为结束提供了两个接口。函数ferror()测试错误标志是否是在流上设置了：
</p>
<pre>include &lt;stdio.h&gt;
int ferror (FILE *stream);
</pre>
<p>错误标志由其它能够响应错误条件的标准输入输出接口设置。如果标志被设置，函数返回非零值，否则返回0。
函数feof()测试文件结尾标志是否被设置：
</p>
<pre>include &lt;stdio.h&gt;
int feof (FILE *stream);
</pre>
<p>当到达文件的结尾时，EOF标志会被其它标准输入输出接口设置。如果标志被设置了，函数返回非零值，否则返回0。
clearerr()函数为流清空错误和文件结尾标志：
</p>
<pre>#include &lt;stdio.h&gt;
void clearerr (FILE *stream);
</pre>
<p>它没有返回值，而且不会失败(没有方法知道是否提供了一个非法的流)。只有在检查error和EOF标志之后，你才可以调用clearerr()，因为它们之后将不可恢复。例如：
</p>
<pre>/* 'f' is a valid stream */
if (ferror (f))
    printf ("Error on f!\n"); 
if (feof (f))
    printf ("EOF on f!\n");
clearerr (f);
</pre>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../c/h/a/Chapter3S_ea2a.html" title="Chapter3S">编辑</a>]</div><a name=".E8.8E.B7.E5.BE.97.E5.85.B3.E8.81.94.E7.9A.84.E6.96.87.E4.BB.B6.E6.8F.8F.E8.BF.B0.E7.AC.A6"></a><h2>获得关联的文件描述符</h2>
<p>有时候，从流中获得文件描述符有些冒险。例如，当一个关联的标准I/O函数不存在时，通过流的文件描述符对一个流执行系统调用可能有用。为了获得从流中反获得文件描述符，用fileno():
</p>
<pre>#include &lt;stdio.h&gt;
int fileno (FILE *stream);
</pre>
<p>成功时，fileno()返回文件和流相关联的文件描述符。失败时，它返回－1。只有当给定的流非法时才可能发生这种清况，这时候函数会将errno设置为EBADF.
混合使用标准输入输出调用和系统调用通常不被建议。使用fileno()时程序员为了保证正确的操作必须非常谨慎。特别地，在执行获取文件描述符之前将流冲洗掉是可能明智的。你几乎永远不应该混合使用实际的I/O操作。
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../c/h/a/Chapter3S_ea2a.html" title="Chapter3S">编辑</a>]</div><a name=".E6.8E.A7.E5.88.B6.E7.BC.93.E5.86.B2"></a><h2>控制缓冲</h2>
<p>标准I/O实现了三种用户缓冲，而且为开发者提供了一个用来控制缓冲区大小和类型的接口。不公的用户缓冲提供不同的目的，而且适用于不同的场合。下面是一些选项：
</p><p>不缓冲
</p><p>没有执行用户缓冲。数据直接提交到内核。因为这和用户缓冲对立，这个选项通常不被使用。标准错误，默认的是不缓冲的。
</p><p>行缓冲
</p><p>缓冲以行为单位执行。每当遇到换行符，缓冲区被提交到内核。行缓冲对输出到屏幕的流有用。因此，它是终端的默认缓冲方式(标准输出默认为行缓冲)。
</p><p>块缓冲
</p><p>缓冲以块为单位执行。这是本章一开始讨论的缓冲类型，而且它适用于文件。默认的所有和文件相关的流都是块缓冲的。标准输入输出称块缓冲为全缓冲。
</p><p>大部分情况下，默认的缓冲类型是正确并且最优的。然而，标准I/O确实提供了一个用来控制使用的缓冲类型的接口：
</p>
<pre>#include &lt;stdio.h&gt;
int setvbuf (FILE *stream, char *buf, int mode, size_t size);
</pre>
<p>setbuf()函数设置流的缓冲类型模式，模式必须是一下的一种：
_IONBF
</p><p>无缓冲
</p><p>_IOLBF
</p><p>行缓冲
</p><p>_IOFBF
</p><p>块缓冲
</p><p>除了_IONBF情况下buf和size被忽略了，buf可以指向一个size字节大小的缓冲空间，标准I/O会用它来执行对给定流的缓冲。如果buf为空， 一个缓冲区会自动由glibc分配。
</p><p>打开流后，但在执行任何操作之前，setvbuf（）函数必须被调用。 成功时它返回0，否则返回一个非零值。
提供的缓冲区，如果有，在流关闭时必须存在。一个常见的错误是把缓冲区定义成作用域中的自动变量，并且作用域结束之前没有关闭流。特别地，注意不要提供一个main()函数本地的缓冲区，而且没有显式地关闭流。例如，下面是一个错误：
</p>
<pre>#include &lt;stdio.h&gt;
int main (void)
{
    char buf[BUFSIZ];
    /* set stdin to block-buffered with a BUFSIZ buffer */
    setvbuf (stdout, buf, _IOFBF, BUFSIZ);
    printf ("Arrr!\n");
    return 0;
}
</pre>
<p>这个错误可以通过在离开作用域之前显式地关闭流或将流作为全局变量来改正。
</p><p>总的来说，开发者不用操心在流上的缓冲。有了标准错误的一场，终端是行缓冲的，而且这样就够了。文件是快缓冲的，这样也就可以了。默认的块缓冲区大小是在&lt;stdio.h&gt;中定义的BUFSIZ，而且通常情况下这是最优的选择(一个标准块大小的大整数倍).
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../c/h/a/Chapter3S_ea2a.html" title="Chapter3S">编辑</a>]</div><a name=".E7.BA.BF.E7.A8.8B.E5.AE.89.E5.85.A8"></a><h2>线程安全</h2>
<p>线程就是在一个程序中许多连续的执行任务。一种对线程的定义是许多共享一个地址空间的过程。线程可以在任何时间运行，而且可以重写共享的数据。
</p><p>除非同时有起它线程访问这些数据或者把它定义为本地线程。 支持线程的操作系统提供加锁机制（保证相互排斥的程序结构）来保证线程不会干扰其它线程。标准I/O使用这些机制。而且，它们通常还不够。例如，有时候你想给一组调用加锁，从一个I/O操作扩大关键区域（一个没有使用其它线程运行的一段代码）到几个。其它情况时，你可能想一起解锁来提高效率。这一部分，我们会讨论怎样做到这两点。
</p><p>标准I/O函数线程安全的。它们内部联合了一个锁，一个锁数量，和给每个打开的流的一个支配线程。任何给定的线程要想执行任何I/O请求必须获得锁而且成为支配线程。两个或多个执行在同一流上的线程交错的执行标准I/O操作，因此，在一个函数调用的环境中，标准I/O操作是原子的。
</p><p>当然，应用中，许多应用程序和单独的函数调用相比需要更多原子操作。例如，如果多个线程正在执行写入请求，应用程序可能希望这些读写请求没有间断地完成。为了允许这种情况，标准I/O为个别地操纵和流关联的锁提供了一系列的函数。
</p><p>/** 
通常，销毁锁会导致各种各样的问题。但一些程序可能显式地实现它们的线程用法来用一个线程代替所有的I/O。在这种情况下，没有必要增加加锁的开销。
</p>
<ul><li>/
</li></ul>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../c/h/a/Chapter3S_ea2a.html" title="Chapter3S">编辑</a>]</div><a name=".E6.89.8B.E5.8A.A8.E6.96.87.E4.BB.B6.E5.8A.A0.E9.94.81"></a><h3>手动文件加锁</h3>
<p>函数flockfile()等待流不再加锁，然后获得锁，增加锁数量，成为流的支配线程，然后返回:
</p>
<pre>#include &lt;stdio.h&gt;
void flockfile (FILE *stream);
</pre>
<p>函数funlockfile() 减少与流相关的锁数量：
</p>
<pre>#include &lt;stdio.h&gt;
void funlockfile (FILE *stream);
</pre>
<p>如果锁数量达到了0，当前的线程放弃流的支配权。另一个线程现在能够获得锁。
这些调用可以嵌套。就是说，一个线程可以执行多个flockfile()调用，而流不会解锁直到程序执行相同数量的funlockfile()调用。
ftrylockfile()函数是一个flockfile()的非模块版本:
</p>
<pre>#include &lt;stdio.h&gt;
int ftrylockfile (FILE *stream);
</pre>
<p>如果流当前加了锁，ftrylockfile()什么都不做，并且立即返回一个非零值。如果流当前是没有加锁的，它需要锁，增加锁数量，成为流的支配线程，并且返回0。
让我们考虑一个例子：
</p>
<pre>flockfile (stream);
fputs ("List of treasure:\n", stream);
fputs (" (1) 500 gold coins\n", stream);
fputs (" (2) Wonderfully ornate dishware\n", stream);
funlockfile (stream);
</pre>
<p>尽管单独的fputs()操作不会冲突－例如，我们永远不会有内容和"List oftreasure"交错－从另一个线程到这个相同的流的另一个标准I/O操作可以插入在两个fputs()调用之间。理想地，一个应用程序被设计成不同的线程不向相同的流提交。然而如果你的程序不需要这么做，并且你需要一个比单独函数大的底层区域，flockfile()和它的类似函数可以解决这个问题。
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../c/h/a/Chapter3S_ea2a.html" title="Chapter3S">编辑</a>]</div><a name=".E6.9C.AA.E5.8A.A0.E9.94.81.E6.B5.81.E6.93.8D.E4.BD.9C"></a><h3>未加锁流操作</h3>
<p>执行手动给流加锁还有另外一个原因。有着只有应用程序员才能提供的更小，更精确的锁控制，有可能将加锁的代价降到最小，并且提高执行的效率。为此，Linux提供了一系列的函数，类似于通常的标准I/O接口，但是不执行任何锁操作。它们，效果上是和标准I/O的相关的。
</p>
<pre>#define _GNU_SOURCE
#include &lt;stdio.h&gt;
int fgetc_unlocked (FILE *stream);
char *fgets_unlocked (char *str, int size, FILE *stream);
size_t fread_unlocked (void *buf, size_t size, size_t nr,
FILE *stream);
int fputc_unlocked (int c, FILE *stream);
int fputs_unlocked (const char *str, FILE *stream);
size_t fwrite_unlocked (void *buf, size_t size, size_t nr,
FILE *stream);
int fflush_unlocked (FILE *stream);
int feof_unlocked (FILE *stream);
int ferror_unlocked (FILE *stream);
int fileno_unlocked (FILE *stream);
void clearerr_unlocked (FILE *stream);
</pre>
<p>这些函数和它们加锁的关联函数执行相同操作，除了它们不检查或获得给定流关联的锁。如果加锁是必须，保证手工获得并且释放锁是程序员的责任。
尽管POSIX定义了一些不加锁的标准I/O函数变量，上面的函数没有一个是POSIX定义的。它们都是Linux特有的，尽管许多其它Unix系统支持这些函数。
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../c/h/a/Chapter3S_ea2a.html" title="Chapter3S">编辑</a>]</div><a name=".E5.AF.B9.E6.A0.87.E5.87.86.E8.BE.93.E5.85.A5.E8.BE.93.E5.87.BA.E7.9A.84.E6.89.B9.E8.AF.84"></a><h2>对标准输入输出的批评</h2>
<p>尽管标准I/O广泛使用，一些专家指出它的一些缺点。一些函数，例如fgets(), 有时候不能够满足要求。其它函数，例如gets（），太不安全了以致于除了没有被从标准I/O消除便一无是处了。对标准I/O最大的抱怨是double的拷贝引起的冲突。当读取数据时，标准I/O对内核执行read()系统调用，从内核中复制数据到标准I/O缓冲区。然后当一个程序通过标准I/O执行一个读请求时－例如，用fgetc(）－数据又被复制，这一次从标准I/O的缓冲区到提供的缓冲内存。写入请求用相反的方式运行：数据从给定的缓冲空间向标准I/O缓冲区，然后有从标准I/O缓冲区通过write()向内核写入。
</p><p>一个可以选择的实现可以通过让每个读请求返回指向标准I/O缓冲区的指针来避免double数据的复制。数据然后可以被直接从标准I/O缓冲区中读取，不需要无关的复制。当程序不需要自己本地缓冲区的数据时－可能向其中写数据－总可以手动地执行复制。这个实现提供了一个"免费"的接口，允许程序当它们完成缓冲区的一块读取时发出信号。
写入会更复杂些，但是double复制仍然能够被避免。当执行一个写入请求时，这个实现会记录指针。最终当准备好将数据冲洗到内核时，写出数据。这些可以通过writev()函数用scatter-gather I/O来实现，并且这样只需要一个系统调用。(我们会在下一章讨论scatter-gather I/O).
</p><p>高度优化的用户缓冲库存在，用类似我们刚刚讨论的实现解决double的复制问题。选择性的，一些开发者选择实现他们自己的用户缓冲方案。但是尽管有这些不同，标准I/O仍然很流行。
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../c/h/a/Chapter3S_ea2a.html" title="Chapter3S">编辑</a>]</div><a name=".E7.BB.93.E8.AE.BA"></a><h2>结论</h2>
<p>标准I/O是C标准库提供的一个用户缓冲库。除掉一些不完善的地方，它是一个很强大而且非常流行的方法。许多C程序员，实际上，对标准I/O一无所知。当然，对于中断I/O，行缓冲是最理想的，标准I/O是不适用的。又有谁用write（）向标准输出中打印过呢？
标准I/O－广义上的用户缓冲，某种意义上－当下面任意一个正确时都是有用的：
</p><p>.你可能执行许多系统调用，而你希望通过合并这些调用最小化代价。
</p><p>.操作非常关键，而你希望保证所有的I/O以块大小并且块对齐的方式出现。
</p><p>.你的访问模式是基于字符或行的，而你希望接口是这些访问简单而且没有无关的系统调用。
</p><p>.相比低级的Linux系统调用你更喜欢高级的接口。然而最大的灵活在于你能够直接的使用Linux系统调用。下一章，我们将学习高级形式的I/O和相关的系统调用。
</p>
<div class="printfooter">
<p>取自"<a href="http://dns.cs.hit.edu.cn../../../c/h/a/Chapter3S_ea2a.html">http://dns.cs.hit.edu.cn../../../c/h/a/Chapter3S_ea2a.html</a>"</p>

<p>本页面已经被浏览243次。 This page was last modified 12:58 2009年3月29日 by <a href="../../../j/i/f/User%7EJifeifei1989.html" class="new" title="User:Jifeifei1989">吉飞飞</a>.  </p>
</div>

</div><br style="clear:both" />

<div id='footer'><table border="0" cellspacing="0"><tr><td width='152' rowspan='1'>&nbsp;</td><td class='bottom' align='left' valign='top'><strong><a href="../../../c/h/a/Chapter3S_ea2a.html" title="Chapter3S">编辑本页</a></strong> |
<a href="../../../c/h/a/Talk%7EChapter3S_2916.html" class="new" title="Talk:Chapter3S">讨论本页</a> |
<a href="../../../c/h/a/Chapter3S_ea2a.html" title="Chapter3S">较早版本</a> |
<a href="../../../w/h/a/Special%7EWhatlinkshere.html" title="Special:Whatlinkshere">链入页面</a> |
<a href="../../../r/e/c/Special%7ERecentchangeslinked.html" title="Special:Recentchangeslinked">链出更改</a>
<br /><br />

<br /><a href="../../../index.html" title="首页">首页</a> | <a href="../../../w/i/k/Wikipedia%7E%E5%85%B3%E4%BA%8E.html" title="Wikipedia:关于">关于Wikipedia</a> | <a href="../../../r/e/c/Special%7ERecentchanges.html" title="Special:Recentchanges">最近更改</a> | <form name="search" class="inline" method="post" action="../../../s/e/a/Special%7ESearch.html">
<input type="text" name="search" size="19" value="" />
<input type="submit" name="go" value="进入" />&nbsp;<input type="submit" name="fulltext" value="搜索" />
</form><br /><span id="pagestats">本页面已经被浏览243次。 This page was last modified 12:58 2009年3月29日 by <a href="../../../j/i/f/User%7EJifeifei1989.html" class="new" title="User:Jifeifei1989">吉飞飞</a>.  </span></td></tr></table>
</div>
</div>

<div id='quickbar'>
<a href='../../../index.html'><img src='../../../../skins/common/images/wiki.jpg' alt='[首页]' /></a>
<hr class='sep' /><a href="../../../index.html">首页</a>
<br /><a href="../../../c/o/m/WIKI-HIT_IBM_CLUB%7ECommunity_Portal_9150.html">社区</a>
<br /><a href="../../../c/u/r/Current_events.html">新闻动态</a>
<br /><a href="../../../r/e/c/Special%7ERecentchanges.html">最近更改</a>
<br /><a href="../../../r/a/n/Special%7ERandom.html">随机页面</a>
<br /><a href="../../../w/i/k/Wikipedia%7E%E5%B8%AE%E5%8A%A9.html">帮助</a>
<br /><a href="../../../s/i/t/WIKI-HIT_IBM_CLUB%7ESite_support.html">Donations</a>
<br />
<hr class='sep' /><strong><a href="../../../c/h/a/Chapter3S_ea2a.html" title="Chapter3S">编辑本页</a></strong>
<br /><a href="../../../c/h/a/Talk%7EChapter3S_2916.html" class="new" title="Talk:Chapter3S">讨论本页</a>
<br /><a href="../../../c/h/a/Chapter3S_ea2a.html" title="Chapter3S">较早版本</a>
<br /><a href="../../../w/h/a/Special%7EWhatlinkshere.html" title="Special:Whatlinkshere">链入页面</a>
<br /><a href="../../../r/e/c/Special%7ERecentchangeslinked.html" title="Special:Recentchangeslinked">链出更改</a>
<br /><hr class='sep' /><a href="../../../s/p/e/Special%7ESpecialpages.html" title="Special:Specialpages">特殊页面</a>
<br /><a href="../../../w/i/k/Wikipedia%7E%E9%94%99%E8%AF%AF%E6%8A%A5%E5%91%8A.html" title="Wikipedia:错误报告">错误报告</a>
<br /></div>
<!-- Served by dns.cs.hit.edu.cn in 1351393330.55 secs. -->
</body></html>