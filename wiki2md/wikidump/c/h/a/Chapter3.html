<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh-cn" lang="zh-cn" >
<head>
<title>Chapter3 - WIKI-HIT IBM CLUB</title>
<meta name="KEYWORDS" content="首页,ALP,Address,Android,Android Newbie Guide,Android Project Development,Android Research Field,Android Third Party Lib And Tool,BoardGame,CSAPP" />
<meta http-equiv="Content-type" content="text/html; charset=UTF-8" />
<meta name="robots" content="index,follow" />
<link rel="shortcut icon" href="/favicon.ico" />
<link rel='stylesheet' type='text/css' media='print' href='../../../../skins/common/wikiprintable.css' />
<script type="text/javascript" src="../../../../skins/common/wikibits.js"></script>
<style type='text/css'>
/*/*/ /*<![CDATA[*/
@import "../../../../skins/common/wikistandard.css";
@import "../../../s/t/a/MediaWiki%7EStandard.css.html";
a.new, #quickbar a.new { color: #CC2200; }
.editsection { display: none; }
#quickbar { position: absolute; top: 4px; left: 4px; border-right: 1px solid gray; }
#article { margin-left: 152px; margin-right: 4px; }

/*]]>*/ /* */
</style>
</head>

<body bgcolor='#FFFFFF' onload=''>

<div id='content'>
<div id='topbar'>
<table border='0' cellspacing='0' width='98%'>
<tr>
<td width='152' rowspan='1'>&nbsp;</td><td class="top" align='left' valign='top'>
<a href="../../../index.html" title="首页">首页</a> |
<a href="../../../r/e/c/Special%7ERecentchanges.html" title="Special:Recentchanges">最近更改</a> |
<a href="../../../c/h/a/Chapter3.html" title="Chapter3">编辑本页</a> |
<a href="../../../c/h/a/Chapter3.html" title="Chapter3">较早版本</a><p class='subtitle'><a href="../../../c/h/a/Chapter3.html">可打印版</a> | <a href="../../../g/e/n/WIKI-HIT_IBM_CLUB%7EGeneral_disclaimer.html" title="WIKI-HIT IBM CLUB:General disclaimer">Disclaimers</a></p>
</td>
<td class="top" valign='top' align='right' nowrap='nowrap'>Not logged in
<br /><a href="../../../u/s/e/Special%7EUserlogin.html" title="Special:Userlogin">登录</a> | <a href="../../../w/i/k/Wikipedia%7E%E5%B8%AE%E5%8A%A9.html" title="Wikipedia:帮助">帮助</a>
<br /><form name="search" class="inline" method="post" action="../../../s/e/a/Special%7ESearch.html">
<input type="text" name="search" size="19" value="" />
<input type="submit" name="go" value="进入" />&nbsp;<input type="submit" name="fulltext" value="搜索" />
</form></td></tr>
</table>
</div>

<div id='article'>
<h1 class="pagetitle">Chapter3</h1><p class='subtitle'>Wikipedia，自由的百科全书</p>
<table id='toc' class='toc'><tr><td><div id='toctitle'><h2>目录</h2></div>
<ul>
<li class='toclevel-1'><a href="#.E7.AC.AC.E4.B8.89.E7.AB.A0_.E5.B8.A6.E7.BC.93.E5.86.B2.E7.9A.84I.2FO"><span class="tocnumber">1</span> <span class="toctext">第三章 带缓冲的I/O</span></a>
<ul>
<li class='toclevel-2'><a href="#.E7.94.A8.E6.88.B7.E6.80.81.E5.B8.A6.E7.BC.93.E5.86.B2.E7.9A.84I.2FO"><span class="tocnumber">1.1</span> <span class="toctext">用户态带缓冲的I/O</span></a>
<ul>
<li class='toclevel-3'><a href="#.E5.9D.97.E5.A4.A7.E5.B0.8F"><span class="tocnumber">1.1.1</span> <span class="toctext">块大小</span></a></li>
</ul>
</li>
<li class='toclevel-2'><a href="#.E6.A0.87.E5.87.86_I.2FO_.E5.BA.93"><span class="tocnumber">1.2</span> <span class="toctext">标准 I/O 库</span></a>
<ul>
<li class='toclevel-3'><a href="#.E6.96.87.E4.BB.B6.E6.8C.87.E9.92.88"><span class="tocnumber">1.2.1</span> <span class="toctext">文件指针</span></a></li>
</ul>
</li>
<li class='toclevel-2'><a href="#.E6.89.93.E5.BC.80.E6.96.87.E4.BB.B6"><span class="tocnumber">1.3</span> <span class="toctext">打开文件</span></a>
<ul>
<li class='toclevel-3'><a href="#.E6.A8.A1.E5.BC.8Fmode"><span class="tocnumber">1.3.1</span> <span class="toctext">模式mode</span></a></li>
</ul>
</li>
<li class='toclevel-2'><a href="#.E9.80.9A.E8.BF.87.E6.96.87.E4.BB.B6.E6.8F.8F.E8.BF.B0.E7.AC.A6.E6.89.93.E5.BC.80.E6.B5.81"><span class="tocnumber">1.4</span> <span class="toctext">通过文件描述符打开流</span></a></li>
<li class='toclevel-2'><a href="#.E5.85.B3.E9.97.AD.E6.B5.81"><span class="tocnumber">1.5</span> <span class="toctext">关闭流</span></a>
<ul>
<li class='toclevel-3'><a href="#.E5.85.B3.E9.97.AD.E6.89.80.E6.9C.89.E6.B5.81"><span class="tocnumber">1.5.1</span> <span class="toctext">关闭所有流</span></a></li>
</ul>
</li>
<li class='toclevel-2'><a href="#.E4.BB.8E.E4.B8.80.E4.B8.AA.E6.B5.81.E4.B8.AD.E8.AF.BB.E6.95.B0.E6.8D.AE"><span class="tocnumber">1.6</span> <span class="toctext">从一个流中读数据</span></a>
<ul>
<li class='toclevel-3'><a href="#.E4.B8.80.E6.AC.A1.E8.AF.BB.E5.85.A5.E4.B8.80.E4.B8.AA.E5.AD.97.E7.AC.A6"><span class="tocnumber">1.6.1</span> <span class="toctext">一次读入一个字符</span></a>
<ul>
<li class='toclevel-4'><a href="#.E6.8A.8A.E4.B8.80.E4.B8.AA.E5.AD.97.E7.AC.A6.E5.8E.8B.E5.9B.9E.E6.B5.81.E4.B8.AD"><span class="tocnumber">1.6.1.1</span> <span class="toctext">把一个字符压回流中</span></a></li>
</ul>
</li>
<li class='toclevel-3'><a href="#.E8.AF.BB.E5.85.A5.E4.B8.80.E8.A1.8C"><span class="tocnumber">1.6.2</span> <span class="toctext">读入一行</span></a></li>
<li class='toclevel-3'><a href="#.E8.AF.BB.E4.BA.8C.E8.BF.9B.E5.88.B6.E4.B8.B2"><span class="tocnumber">1.6.3</span> <span class="toctext">读二进制串</span></a></li>
<li class='toclevel-3'><a href="#.E8.AF.BB.E4.BA.8C.E8.BF.9B.E5.88.B6.E6.95.B0.E6.8D.AE"><span class="tocnumber">1.6.4</span> <span class="toctext">读二进制数据</span></a></li>
</ul>
</li>
<li class='toclevel-2'><a href="#.E5.BE.80.E6.B5.81.E4.B8.AD.E5.86.99.E6.95.B0.E6.8D.AE"><span class="tocnumber">1.7</span> <span class="toctext">往流中写数据</span></a>
<ul>
<li class='toclevel-3'><a href="#.E5.AF.B9.E9.BD.90.E9.97.AE.E9.A2.98"><span class="tocnumber">1.7.1</span> <span class="toctext">对齐问题</span></a></li>
<li class='toclevel-3'><a href="#.E5.86.99.E4.B8.80.E4.B8.AA.E5.8D.95.E7.8B.AC.E7.9A.84.E5.AD.97.E7.AC.A6"><span class="tocnumber">1.7.2</span> <span class="toctext">写一个单独的字符</span></a></li>
<li class='toclevel-3'><a href="#.E5.86.99.E4.B8.80.E4.B8.AA.E5.AD.97.E7.AC.A6.E4.B8.B2"><span class="tocnumber">1.7.3</span> <span class="toctext">写一个字符串</span></a></li>
<li class='toclevel-3'><a href="#.E5.86.99.E4.BA.8C.E8.BF.9B.E5.88.B6.E6.95.B0.E6.8D.AE"><span class="tocnumber">1.7.4</span> <span class="toctext">写二进制数据</span></a></li>
</ul>
</li>
<li class='toclevel-2'><a href="#.E5.B8.A6.E7.BC.93.E5.86.B2.E6.9C.BA.E5.88.B6I.2FO.E7.9A.84.E7.A4.BA.E4.BE.8B.E7.A8.8B.E5.BA.8F"><span class="tocnumber">1.8</span> <span class="toctext">带缓冲机制I/O的示例程序</span></a></li>
<li class='toclevel-2'><a href="#.E5.AE.9A.E4.BD.8D.E4.B8.80.E4.B8.AA.E6.B5.81"><span class="tocnumber">1.9</span> <span class="toctext">定位一个流</span></a>
<ul>
<li class='toclevel-3'><a href="#.E8.8E.B7.E5.8F.96.E5.BD.93.E5.89.8D.E6.B5.81.E7.9A.84.E4.BD.8D.E7.BD.AE"><span class="tocnumber">1.9.1</span> <span class="toctext">获取当前流的位置</span></a></li>
<li class='toclevel-3'><a href="#.E6.B8.85.E9.99.A4.E6.B5.81"><span class="tocnumber">1.9.2</span> <span class="toctext">清除流</span></a></li>
</ul>
</li>
<li class='toclevel-2'><a href="#.E5.87.BA.E9.94.99.E5.A4.84.E7.90.86.E5.8F.8A.E6.96.87.E4.BB.B6.E7.BB.93.E6.9D.9F.28EOF.29"><span class="tocnumber">1.10</span> <span class="toctext">出错处理及文件结束(EOF)</span></a></li>
<li class='toclevel-2'><a href="#.E8.8E.B7.E5.8F.96.E7.9B.B8.E5.BA.94.E7.9A.84.E6.96.87.E4.BB.B6.E6.8F.8F.E8.BF.B0.E7.AC.A6"><span class="tocnumber">1.11</span> <span class="toctext">获取相应的文件描述符</span></a></li>
<li class='toclevel-2'><a href="#.E6.93.8D.E6.8E.A7.E7.BC.93.E5.86.B2.E5.8C.BA"><span class="tocnumber">1.12</span> <span class="toctext">操控缓冲区</span></a>
<ul>
<li class='toclevel-3'><a href="#.E6.97.A0.E7.BC.93.E5.86.B2"><span class="tocnumber">1.12.1</span> <span class="toctext">无缓冲</span></a></li>
<li class='toclevel-3'><a href="#.E8.A1.8C.E7.BC.93.E5.86.B2"><span class="tocnumber">1.12.2</span> <span class="toctext">行缓冲</span></a></li>
<li class='toclevel-3'><a href="#.E5.9D.97.E7.BC.93.E5.86.B2"><span class="tocnumber">1.12.3</span> <span class="toctext">块缓冲</span></a></li>
</ul>
</li>
<li class='toclevel-2'><a href="#.E7.BA.BF.E7.A8.8B.E5.AE.89.E5.85.A8"><span class="tocnumber">1.13</span> <span class="toctext">线程安全</span></a>
<ul>
<li class='toclevel-3'><a href="#.E6.89.8B.E5.8A.A8.E9.94.81.E6.96.87.E4.BB.B6"><span class="tocnumber">1.13.1</span> <span class="toctext">手动锁文件</span></a></li>
<li class='toclevel-3'><a href="#.E4.B8.BA.E6.B5.81.E8.A7.A3.E9.94.81"><span class="tocnumber">1.13.2</span> <span class="toctext">为流解锁</span></a></li>
</ul>
</li>
<li class='toclevel-2'><a href="#.E8.AF.84.E4.BB.B7.E6.A0.87.E5.87.86I.2FO"><span class="tocnumber">1.14</span> <span class="toctext">评价标准I/O</span></a></li>
<li class='toclevel-2'><a href="#.E6.80.BB.E7.BB.93"><span class="tocnumber">1.15</span> <span class="toctext">总结</span></a></li>
</ul>
</li>
</ul>
</td></tr></table>
<p><script type="text/javascript"> if (window.showTocToggle) { var tocShowText = "显示"; var tocHideText = "隐藏"; showTocToggle(); } </script>
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../c/h/a/Chapter3.html" title="Chapter3">编辑</a>]</div><a name=".E7.AC.AC.E4.B8.89.E7.AB.A0_.E5.B8.A6.E7.BC.93.E5.86.B2.E7.9A.84I.2FO"></a><h1>第三章 带缓冲的I/O</h1>
<p>由第一章我们知道，一个文件系统可以抽象为块，块是 I/O 世界的通用语。所有的磁盘操作在某种意思上都是对块进行的。
因此，如果我们能按块大小的整数倍来对齐，从而对 I/O 进行读写操作，那么操作的性能能达到最佳。
</p><p>增加用于读写的系统调用次数会使性能急剧退化，比如说读1024次每次字节，跟一次性读1024字节相比，后者性能好得多。
甚至一连串对尺寸大于一个块的操作，其性能也是欠佳的，如果每次操作的尺寸不是块大小的整数倍。比如，假设块大小为
1k 字节，选1，130字节作为一欠操作的整块，仍然会比选1，024字节的操作慢。
</p><p><br />
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../c/h/a/Chapter3.html" title="Chapter3">编辑</a>]</div><a name=".E7.94.A8.E6.88.B7.E6.80.81.E5.B8.A6.E7.BC.93.E5.86.B2.E7.9A.84I.2FO"></a><h2>用户态带缓冲的I/O</h2>
<p>那些需要对一般文本进行多次轻量级I/O访问的程序往往应用用户态的带缓冲I/O。
这涉及到用户态的缓冲而不是由内核处理的缓冲，这种缓冲一般由程序人工地或者由库透明地执行。
就像我们在第2章讲过的，为了提高性能，内核会在底层通过缓写和预读来进行数据缓冲。
虽然手段不同，但用户态缓冲机制也是为了提高性能。
</p><p>考虑一个在用户态执执行程序 dd 的例子:
</p>
<pre>dd bs=1 count=2097152 if=/dev/zero of=pirate
</pre>
<p>因为参数 bs = 1,这个命令会从设备 /dev/zero(一个能提供源源不断 0 的虚拟设备)拷贝 2Mbs 到文件pirate，
其形式是2，097，152个字节块。也就是说，它会执行两百万次读和写的操作，每次一个字节。
</p><p>现在考虑同关2Mbs数据的拷贝，不同的是以1，024字节作为块大小:
</p>
<pre>dd bs=1024 count=2048 if=/dev/zero of=pirate
</pre>
<p>该操作拷贝同样 2Mbs 数据至同一个文件，但是只进行了1，024次读和写。
从表3-1可以看到，性能得到了很大提高。
表中，我记录了4次 dd 命令所消耗的时间(通过三种不同的方式)，它们的区别仅仅是块的大小。
real time 是程序开始执行到退出花的时间，user time 是用户态执行该程序的时间,system time 是在内核态执行系统调用的时间。
</p><p>表3-1.　块大小对性能的影响
</p>
<pre>Block size 　　　Real time 　　　　User time 　　　 System time
1 byte 　　　　  18.707 seconds 　1.118 seconds 　17.549 seconds
1,024 bytes　 　0.025 seconds 　　0.002 seconds 　0.023 seconds
1,130 bytes 　　0.035 seconds 　　0.002 seconds 　0.027 seconds
</pre>
<p><br />
用1，024字节作为块大小与仅仅用１个字节作为块大小相比，前者能大副度提高性能。
然而，上表也表明虽然用大尺寸能减少系统调用，但也有可能会使性能退化，如果这个尺寸不是磁盘块大小的整数倍的话。
尽管1，130字节的需要更少的系统调用，但是它的读写请求最终会产生未对齐的读写请求，
这样的话会使它不如1，024字节的读写请求那么高效。
</p><p>要想利用这种性能的恩赐，我们需要预先知道很相近的物理块大小。
上表表明这个数字很可能是1，024的整数倍或者能被1，024整除。
在例子　/dev/zero 中，块的大小实际上是4，096字节。
</p><p><br />
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../c/h/a/Chapter3.html" title="Chapter3">编辑</a>]</div><a name=".E5.9D.97.E5.A4.A7.E5.B0.8F"></a><h3>块大小</h3>
<p>通常，块大小一般是　512, 1,024, 2,048, 或 4,096 字节。
</p><p>表3-1表明，以块大小的整数倍或因子为单位进行读写操作，可以取得很好的性能。
这是因为内核和硬件是以块作为语言来进行交流的。因此，以块大小或一个能很整洁安排块的大小为单位，
这样可以保证块对齐的要求，从而避免内核做些雍余的工作。
</p><p>用系统调用　stat()(见第7章) 或 命令stat(1)　可以很简单地算出给定设备的块大小。
然而大多数时候我们并不需要知道准确的块大小。
</p><p>当你为 I/O 操作选一个合适的大小时，最重要的目标是不要选类似　1，130　这么蹩脚的数字。
在 Unix 历史上，从来没有块大小为1，130字节的。
选这样的大小会使你第一次以后的读写操作都对不齐。
选择块大小的因子或整数倍，可以防止未对齐的请求。
只要选择的大小能使一切都以块对齐，那么就能得到好的性能，
选择更大整数倍的只会简单地减少系统调用的次数。
</p><p><br />
User-Buffered I/O | 63
</p><p>因此，最简单的做法是选典型块大小的整数倍来进行 I/O 操作，比如4，096和8，192字节都不错。
</p><p>当然，问题在于很少有程序从块的角度出发。大多程序是与域，行以及单个字符打交道的，而不是抽象的块。
如前所述，为了补救这种状况就引入了用户态缓冲机制的I/O。
将要被写的数据会先存入在一个缓冲区里，这个缓冲区位于程序的地址空间。
当缓冲区里的数据大小达到特定的尺寸(缓冲大小)时，整个缓冲区里的内容会被单独的一个写操作写出。
同样的，数据被读入时也是按照块对齐的缓冲区大小进行的。
随着程序响应它尺寸冏异的读请求，大块的缓冲区被一片片瓜分。
最终，当瓜分殚尽时，按块对齐的另一大块数据会被读入缓冲区。
如果缓冲区大小合适的话，可以获得良好的性能效益。
</p><p>在你的程序里手动实现用户缓冲寄存器是不是不可能的。
其实很多紧要使命的程序正是这么做的。
然而，大多数程序还是利用了流行的标准I/O库(标准C库的一部分)，
它提供了一个良好的鲁棒性和功能强大的用户态缓冲机制解决方案。
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../c/h/a/Chapter3.html" title="Chapter3">编辑</a>]</div><a name=".E6.A0.87.E5.87.86_I.2FO_.E5.BA.93"></a><h2>标准 I/O 库</h2>
<p>C标准库提供了标准 I/O 库，通常简称为 stdio,standard I/O library。
stdio反过来又提供了一个与平台无关的用户态缓冲机制解决方案。
</p><p>不像 FORTRAN 之类的编程语言，除了流控制，算术之类的功能外，
C语言没有对其他更高级的功能提供内置的支持或关键字。
当然也不会对I/O有任何固有支持。
随着C语言的发展，用户开发了一些标准的例程集来提供核心功能，比如字符串处理，数学函数，
时间和日期功能，以及I/O等。
随着时间的过去，这些例程也慢慢成熟了，最终在1989年通过了 ANSI C　标准(C89)的认可，从而成为标准C 库的一部分。
尽管　C95　和　C99　都加了一些新的接口，但标准　I/O 库自从1989年制定以来相对来说没有改变过。
</p><p>本章剩下的篇幅来讨论用户态缓冲机制的 I/O ,因为它是属于文件 I/O　的，并且是由　C语言标准库实现的。
也就是说文件的打开，关闭，读写的实现都借助于　C　语言标准库。
一个程序是否使用标准 I/O,这个home-rolled? 或者进行系统调用？
开发者要认真权衡程序的需求和行为才能做决定。
</p><p>C标准总是为每个函数的实现留下一些可扩充的细节，这些函数往往被添加其他功能。
本章包括以后章节中，整理归档了在现代linux系统中，glibc实现的一些接口和行为。
凡是Linux偏离基本标准的地方，会作出提示。
</p><p><br />
64 | Chapter 3: Buffered I/O
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../c/h/a/Chapter3.html" title="Chapter3">编辑</a>]</div><a name=".E6.96.87.E4.BB.B6.E6.8C.87.E9.92.88"></a><h3>文件指针</h3>
<p>标准 I/O 例程不直接操作的文件描述符。
相反，它们利用自己独特的标识，称为文件指针。
在C库中，文件指针映射到文件描述符。
文件指针被表示为指针FILE,它由typedef定义在&lt;stdio.h&gt;中。
</p><p>在标准I/O里，一个打开的文件被称为流。
流可以打开进行读（输入流），写（输出流） ，或两者兼施（输入/输出流） 。
</p><p><br />
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../c/h/a/Chapter3.html" title="Chapter3">编辑</a>]</div><a name=".E6.89.93.E5.BC.80.E6.96.87.E4.BB.B6"></a><h2>打开文件</h2>
<p>fopen()用来打开文件从而进行读或写操作。
</p>
<pre>#include &lt;stdio.h&gt;
FILE * fopen (const char *path, const char *mode);
</pre>
<p>该函数根据给定的模式mode来打开文件path，然后把它和一个流绑定起来。
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../c/h/a/Chapter3.html" title="Chapter3">编辑</a>]</div><a name=".E6.A8.A1.E5.BC.8Fmode"></a><h3>模式mode</h3>
<p>参数mode指定了怎么打开一个文件，它可以是以下几种:
</p>
<pre>r
打开文件进行读操作。流指向文件的开始位置。
</pre>
<pre>r+
打开文件进行读和写操作。流指向文件的开始位置。
</pre>
<pre>w
打开文件进行写操作。如果文件已经存在，就把它的长度截断为0。
如果文件不存在，就创建一个新的。流指向文件的开始位置。
</pre>
<pre>w+
打开文件进行读和写操作。如果文件已经存在，就把它的长度截断为0。
如果文件不存在，就创建一个新的。流指向文件的开始位置。
</pre>
<pre>a
打开文件进行追加操作。如果文件不存在，就创建一个新的。流指向文件的尾部。
所有的写操作都会附加到文件。
</pre>
<pre>a+
打开文件进行读以及追加操作。如果文件不存在，就创建一个新的。流指向文件的尾部。
所有的写操作都会附加到文件。
</pre>
<p>Opening Files | 65
</p><p>给定的模式也可能包含的字母b，虽然这个值总是被 Linux 忽略.
有些操作系统处理文本文件和二进制文件是不同的，而模式b可以用来指示以二进制模式打开文件。
和所有符合POSIX的系统一样，Linux完全等同地对待文本文件和二进制文件。
</p><p>一旦成功， fopen()函数返回一个有效的文件指针。
如果失败，则返回 NULL，并设置相应的errno。
</p><p>例如，下面的代码打文件 /etc/mainfest　进行读操作，并且将它跟流绑定起来。
</p>
<pre>FILE *stream;
stream = fopen ("/etc/manifest", "r");
if (!stream)
      /* error */
</pre>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../c/h/a/Chapter3.html" title="Chapter3">编辑</a>]</div><a name=".E9.80.9A.E8.BF.87.E6.96.87.E4.BB.B6.E6.8F.8F.E8.BF.B0.E7.AC.A6.E6.89.93.E5.BC.80.E6.B5.81"></a><h2>通过文件描述符打开流</h2>
<p>函数fdopen()可以将一个已经打开的文件描述符(fd)转化为一个流。
</p>
<pre>#include &lt;stdio.h&gt;
FILE * fdopen (int fd, const char *mode);
</pre>
<p>函数可以使用的的模式mode同fopen(),而且要符合原本用来打开文件描述符的模式。
需要指明的是　w　和　w+　不会截断文件。
流在文件中的位置跟文件描述符相关。
</p><p>一旦一个文件描述符被转化为一个流，I/O不应该再直接操作那个文件描述符(尽管这种做法是合法的)。
请注意，原来的文件描述符不会被复制，而仅仅是与一个新的流绑定起来。
关闭这个流也将关闭相应的文件描述符。
</p><p>执行成功的话，fdopen()返回一个有效的文件指针;失败则返回　NULL。
比如，下面的代码用系统调用open()打开文件 /home/kidd/map.txt，
然后利用之前的文件描述符建立一个与之相关的流。
</p>
<pre>FILE *stream;
int fd;
fd = open ("/home/kidd/map.txt", O_RDONLY);
if (fd == &#8722;1)
      /* error */
stream = fdopen (fd, "r");
if (!stream)
     /* error */
</pre>
<p>66 | Chapter 3: Buffered I/O
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../c/h/a/Chapter3.html" title="Chapter3">编辑</a>]</div><a name=".E5.85.B3.E9.97.AD.E6.B5.81"></a><h2>关闭流</h2>
<p><br />
函数fclose()用来关闭一个流:
</p>
<pre>#include &lt;stdio.h&gt;
int fclose (FILE *stream);
</pre>
<p>fclose函数将所有未写入的数据写入stream中，如果出错则返回EOF,并设置相应的errno.
</p><p><br />
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../c/h/a/Chapter3.html" title="Chapter3">编辑</a>]</div><a name=".E5.85.B3.E9.97.AD.E6.89.80.E6.9C.89.E6.B5.81"></a><h3>关闭所有流</h3>
<p>fcloseall函数关闭与目前进程相关的所有流，包括stdin,stdout,stderr.
</p>
<pre>#define _GNU_SOURCE
#include &lt;stdio.h&gt;
int fcloseall (void);
</pre>
<p>在关闭之前，所有的流都会被刷新，该函数总是返回０，这是linux特色。
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../c/h/a/Chapter3.html" title="Chapter3">编辑</a>]</div><a name=".E4.BB.8E.E4.B8.80.E4.B8.AA.E6.B5.81.E4.B8.AD.E8.AF.BB.E6.95.B0.E6.8D.AE"></a><h2>从一个流中读数据</h2>
<p>C标准库实现了很多函数从一个打开的文件中读数据，有常用的，也用罕见的。
本节将讨论其中三个最常用的:一次读入一个字符，一次读一行，以及读二进制数据。
要想从一个流中读数据，这个流在打开时所用的模式必须是有效的，也就是说除了w和a之外的其他模式。
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../c/h/a/Chapter3.html" title="Chapter3">编辑</a>]</div><a name=".E4.B8.80.E6.AC.A1.E8.AF.BB.E5.85.A5.E4.B8.80.E4.B8.AA.E5.AD.97.E7.AC.A6"></a><h3>一次读入一个字符</h3>
<p>通常情况下，理想的I/O模型是简单地一次只读一个字符。
函数fgetc()刚好实现了这个功能。
</p>
<pre>#include &lt;stdio.h&gt;
int fgetc (FILE *stream);
</pre>
<p>该函数返回stream流的下一个字符，返回类型为unsigned char，然后被转换为int类型。
这个类型转换只为了给出错时返回的EOF留出足够的空间范围.
fgetc()的返回值必须存在int里，如果把它存在一个char里将是一个常见但危险的错误。
</p><p>Reading from a Stream | 67
</p><p>下面的例子从stream中读入一个字符，检查错误，然后以字符格式打印出来:
</p>
<pre>int c;
c = fgetc (stream);
if (c == EOF)
    /* error */
else
printf ("c=%c\n", (char) c);
</pre>
<p>当然，stream指向的流必须是以可读模式打开的。
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../c/h/a/Chapter3.html" title="Chapter3">编辑</a>]</div><a name=".E6.8A.8A.E4.B8.80.E4.B8.AA.E5.AD.97.E7.AC.A6.E5.8E.8B.E5.9B.9E.E6.B5.81.E4.B8.AD"></a><h4>把一个字符压回流中</h4>
<p><br />
标准I/O提供了一个函数将一个已读的字符放回流中，该功能使你能够“偷窥”一下，
如果流中下一个字符不是你想要的，你还可以把它放回流中。
</p>
<pre>#include &lt;stdio.h&gt;
int ungetc (int c, FILE *stream);
</pre>
<p>每次调用该函数都会把 c 强转为unsigned char, 然后压回去流中。
如果调用成功，则返回c;失败则返回EOF。
随后的读操作将会返回c.
如果有多个字符被压回，则它们会以相反的次序被读出，
也就是说，最后被压入的字符第一个返回。
POSIX规定，只能确保一个字符的压回是正确的，并且其间不能有读操作。
有些系统只允许一个字符被压回，Linux 没有对这个数量进行约束，
你其至可以把所有的空间都用上。当然只压回一个字符肯定是成功的。
</p><p><br />
在调用ungetc()之后，如果你没有进行读操作就进行了文件位置操作(参见本章后面定位文件小节)，
可能会导致压回的字符丢失。
这种情况发生在同一进程的多个线程之间，因为它们共享同一个缓冲区。
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../c/h/a/Chapter3.html" title="Chapter3">编辑</a>]</div><a name=".E8.AF.BB.E5.85.A5.E4.B8.80.E8.A1.8C"></a><h3>读入一行</h3>
<p>函数fgets()从给定的流中读入一个字符串。
</p>
<pre>#include &lt;stdio.h&gt;
char * fgets (char *str, int size, FILE *stream);
</pre>
<p>从stream中最多读取size-1个字符到字符串str中。
该读操作完成时，一个null(\0)会写入到str中。
一旦遇到EOF或换行符，就结束读操作。如果读到换行符，那么就把\n存到str中。
调用成功，返回str;失败则返回NULL。
</p><p>68 | Chapter 3: Buffered I/O
</p><p><br />
例如:
</p>
<pre>char buf[LINE_MAX];
if (!fgets (buf, LINE_MAX, stream))
     /* error */
</pre>
<p>POSIX 在头文件limits.h中定入了LINE_MAX:
这是POSIX行处理接口可以操作的最大值。
Linux 的C 库没有这样的限制，一行可以是任意大小，但是你没办法接触LINE_MAXR 的定义。
需要移植到其他平台的程序可以利用LINE_MAX来保证安全。
这个值在linux上设置的相对很大，因此linux特有的程序不需要担心一行的容量限制。
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../c/h/a/Chapter3.html" title="Chapter3">编辑</a>]</div><a name=".E8.AF.BB.E4.BA.8C.E8.BF.9B.E5.88.B6.E4.B8.B2"></a><h3>读二进制串</h3>
<p><br />
通常情况下，这种基于行的读操作fgets()是有益的。几乎常常，它也很烦人。
有时候，开发者想使用非回车的分隔符，而有些开发者甚至不想要分隔符。
很少有开发人员想把分隔符存入缓冲区。
回想起来，把换行符存在返回的缓冲区中很少是正确的决定。
</p><p><br />
用fgetc()来实现fgets()的功能是件很容易的事。
比如，下面的代码从stream读入n-1字节，然后存入str,并在末尾追加一个'\0':
</p>
<pre>char *s;
int c;
s = str;
while (--n &gt; 0 &amp;&amp; (c = fgetc (stream))&nbsp;!= EOF)
*s++ = c;
*s = '\0';
</pre>
<p><br />
这段代码可以扩展成读入到由d指定的分隔符后停止，在这个例子中d不能为空字符:
</p>
<pre>char *s;
int c = 0;
s = str;
while (--n &gt; 0 &amp;&amp; (c = fgetc (stream))&nbsp;!= EOF &amp;&amp; (*s++ = c)&nbsp;!= d)
  &nbsp;;
if (c == d)
   *--s = '\0';
else
   *s = '\0';
</pre>
<p><br />
如果将d设为'\n'，那么这段代码跟fgets()的行为很相似了，只是前者将换行存入了缓冲区。
</p><p>Reading from a Stream | 69
</p><p>比起fgets()的实现，这个变种可能会慢一些，因为它反复地调用fgetc().
然而，这种情况跟之前我们说的dd那个例子是不同的。
虽然这段代码要承担额外的函数调用开销，它不承担系统调用开销，
也没有bs=1时，dd例子中未对齐的I/O负担。后者则是更大的问题。
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../c/h/a/Chapter3.html" title="Chapter3">编辑</a>]</div><a name=".E8.AF.BB.E4.BA.8C.E8.BF.9B.E5.88.B6.E6.95.B0.E6.8D.AE"></a><h3>读二进制数据</h3>
<p>仅仅一次读入一个字符或一行对有些程序来说是不够的。
有时，开发者需要对复杂的二进制数据进行读写，比如C中的结构。
为此，标准I/O提供了fread():
</p>
<pre>#include &lt;stdio.h&gt;
size_t fread (void *buf, size_t size, size_t nr, FILE *stream);
</pre>
<p>调用fread()会从流stream中最多读入 nr 个元素，每个元素 size个字节，然后将它们存入buf指向的缓冲区中。
同时，文件指针会向前移动刚才读入的字节数量。
</p><p>函数返回值是读入元素的个数(而不是字节数)。 如果返值小于nr，则表明出错或文件结束，
除非调用ferror()和feof()(见后面“错误及文件结束”)，否则无法分辨这两种情况。
</p><p>由于不同的变量大小，对齐，填充，和字节顺序，由一个程序写入的二进制数据对另一个程序是不可读的，
甚至同一个程序在不同机器上也会出现这种情况。
</p><p>fread()最简单的例子是给定的流stream中读入一个线性的字符串:
</p>
<pre>char buf[64];
size_t nr;
nr = fread (buf, sizeof(buf), 1, stream); 
if (nr == 0)
   /* error */
</pre>
<p>等我们学到与fread()相对的函数fwrite()时再看一些复杂点的例子。
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../c/h/a/Chapter3.html" title="Chapter3">编辑</a>]</div><a name=".E5.BE.80.E6.B5.81.E4.B8.AD.E5.86.99.E6.95.B0.E6.8D.AE"></a><h2>往流中写数据</h2>
<p>和读操作一样，标准C语言库定义了许多函数对打开的流文件进行写操作。
本节将关注三个最常用的写操作:写一个单独的字符，写一个字符串和写二进制数据。
这些不同的写操作适合于带缓冲的I/O.
要想往一个流中写数据，这个流必须以适当的模式打开，也就是说除了 r 之外的其他模式。
</p><p><br />
70 | Chapter 3: Buffered I/O
</p>
<hr />
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../c/h/a/Chapter3.html" title="Chapter3">编辑</a>]</div><a name=".E5.AF.B9.E9.BD.90.E9.97.AE.E9.A2.98"></a><h3>对齐问题</h3>
<p><br />
所有机器的架构都有数据对齐的要求。
程序员倾向于认为内存只是一个字节数组。
但是，处理器不会从内存中读和写字节大小的块，而是以特定的粒度大小来存取内存，
如2，4，8或16字节。
因为每一个进程的地址空间开始于地址0 ，进程必须从这个粒度大小的整数倍来开始存取数据。
</p><p><br />
因此，对C语言中的变量存储和读取时必须保持地址对齐。
一般情况下，变量会自然对齐，其中提到的调整的大小对应于C数据类型。
比如，一个32位的整数是以4个字节对齐的，换句话说就是，
int 应该被存储在能被4整除的内存地址上。
</p><p><br />
对未对准的数据进行访问会产生各种处罚，这些处罚取决于机器架构。
某些处理器可以访问错位的数据，但有大量性能损失。
某些处理器根本不能能这种数据进行访问，任何这样的意图都会引起硬件异常。
更严重的是，有些进程会悄无声息地丢弃低价位，这几乎可以完全肯定会导致意想不到的结果。
</p><p><br />
通常情况下，编译器会自动地对齐数据，这种对齐对程序员来说是透明的。
处理结构，手动管理内存的执行，将二进制数存入磁盘以及网络通信都会引起对齐的问题。
因此系统程序员应该精通这些问题。
</p><p>第8章会更加深入地阐述对齐的问题
</p><p><br />
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../c/h/a/Chapter3.html" title="Chapter3">编辑</a>]</div><a name=".E5.86.99.E4.B8.80.E4.B8.AA.E5.8D.95.E7.8B.AC.E7.9A.84.E5.AD.97.E7.AC.A6"></a><h3>写一个单独的字符</h3>
<p><br />
和函数fgetc()的对应的是fputc():
</p>
<pre>#include &lt;stdio.h&gt;
int fputc (int c, FILE *stream);
</pre>
<p>fputc()函数将c指定的字符(强转为unsigned char)写入stream指向的流。
函数执行成功时返回c,否则返回EOF并设置相应的errno.
使用很简单:
</p>
<pre>if (fputc ('p', stream) == EOF)
     /* error */
</pre>
<p>该例子将字符p写入流stream,且stream必须是以可写模式打开的。
Writing to a Stream | 71
</p><p><br />
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../c/h/a/Chapter3.html" title="Chapter3">编辑</a>]</div><a name=".E5.86.99.E4.B8.80.E4.B8.AA.E5.AD.97.E7.AC.A6.E4.B8.B2"></a><h3>写一个字符串</h3>
<p>函数fputs()将一整串字符写入流stream中。
</p>
<pre>#include &lt;stdio.h&gt;
int fputs (const char *str, FILE *stream);
</pre>
<p><br />
调用fputs()会将str指向的字符串里所有非分隔符之前的内容写入流stream。
成功时fputs()返回一个非负数，否则返回EOF.
</p><p><br />
下面的例子以追加模式打开一个文件，将给定的字符串写入流stream，然后关闭stream.
</p>
<pre>FILE *stream;
stream = fopen ("journal.txt", "a");
if (!stream)
      /* error */
if (fputs ("The ship is made of wood.\n", stream) == EOF)
     /* error */
if (fclose (stream) == EOF)
    /* error */
</pre>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../c/h/a/Chapter3.html" title="Chapter3">编辑</a>]</div><a name=".E5.86.99.E4.BA.8C.E8.BF.9B.E5.88.B6.E6.95.B0.E6.8D.AE"></a><h3>写二进制数据</h3>
<p>Individual characters and lines will not cut it when programs need to write complex
data. To directly store binary data such as C variables, standard I/O provides fwrite():
cut it？？？？
标准I/O库提供了函数fwrite()用来直接存储二进制数据，比如C的变量。
</p>
<pre>#include &lt;stdio.h&gt;
size_t fwrite (void *buf,
size_t size,
size_t nr,
FILE *stream);
</pre>
<p><br />
调用fwrite()会将buf指向的数据中最多nr个元素写入stream中，每个元素长度为size个字节。
文件指针将向前移动写入的字节数量。
</p><p><br />
返回值是成功写入的元素个数(而不是字节数)。
返回值小于nr标志着出错了。
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../c/h/a/Chapter3.html" title="Chapter3">编辑</a>]</div><a name=".E5.B8.A6.E7.BC.93.E5.86.B2.E6.9C.BA.E5.88.B6I.2FO.E7.9A.84.E7.A4.BA.E4.BE.8B.E7.A8.8B.E5.BA.8F"></a><h2>带缓冲机制I/O的示例程序</h2>
<p><br />
现在我们看一个例子，一个完整的程序，它整合了我们迄今讲到的许多接口。
程序首先定义了结构pirate,然后用它声明了两个变量实例。
程序初始结了其中一个变量，然后通过一个输入出流把它写入磁盘文件中。
</p><p><br />
72 | Chapter 3: Buffered I/O
</p><p><br />
通过另一个不同的流，程序将数据读入到另一个结构pirate实例中。
最后，程序打印出结构的内容。
</p>
<pre>#include &lt;stdio.h&gt;
int main (void)
{
  FILE *in, *out;
  struct pirate {
      char name[100]; /* real name */
      unsigned long booty; /* in pounds sterling */
      unsigned int beard_len; /* in inches */
      } p, blackbeard = { "Edward Teach", 950, 48 };
 out = fopen ("data", "w");
 if (!out) {
        perror ("fopen");
        return 1;
        }
 if (!fwrite (&amp;blackbeard, sizeof (struct pirate), 1, out)) {
       perror ("fwrite");
       return 1;
       }
 if (fclose (out)) {
       perror ("fclose");
       return 1;
       }
 in = fopen ("data", "r");
 if (!in) {
       perror ("fopen");
       return 1;
       }
 if (!fread (&amp;p, sizeof (struct pirate), 1, in)) {
       perror ("fread");
       return 1;
       }
 if (fclose (in)) {
       perror ("fclose");
       return 1;
       }
 printf ("name=\"%s\" booty=%lu beard_len=%u\n",
 p.name, p.booty, p.beard_len);
 return 0;
}
</pre>
<p><br />
输出结果当然是原始的数据:
</p>
<pre>name="Edward Teach" booty=950 beard_len=48
</pre>
<p>Sample Program Using Buffered I/O | 73
</p>
<hr />
<p>再次强调，有一点要引起注意的是，由于不同变量的大小，对齐等问题，
由一个程序写入的二进制数据对另一个程序来说可能是不可读的。
也就是说，不同的程序或者同一程序在不同的机器上也许不能正确读出由fwrite()写入的数据。
上面的程序中，unsigned long 的大小可能会有变化，或者填充字节数不同，这些都是要考虑的差异。
只有特定机器上的特定ABI才能保障这些数据都是恒定的。
</p><p><br />
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../c/h/a/Chapter3.html" title="Chapter3">编辑</a>]</div><a name=".E5.AE.9A.E4.BD.8D.E4.B8.80.E4.B8.AA.E6.B5.81"></a><h2>定位一个流</h2>
<p>一般情况下，操纵流指针的当前位置是很有用的。
比如一个应用程序可能正在读一个复杂的基于记录的文件，因此需要不断地跳来跳去。
或者有可能程序需要将文件指针移到文件开头。
不管哪种情况，标准I/O提供了一组接口，其功能等同于系统调用lseek()(见第2章);
这些接口中，最常用的是fseek()函数，它有两个参数：offset和whence.
</p><p><br />
</p>
<pre>#include &lt;stdio.h&gt; 
int fseek (FILE *stream, long offset, int whence);
</pre>
<p>调用该函数时，如果whence为SEEK＿SET，那么文件指针更新为offset的值;
如果whence为SEEK＿CUR，那么文件指针更新为当前位置加上offset的值；
如果whence为SEEK＿END，那么文件指针更新为文件未尾加上offset的值。
</p><p>如果调用成功，fseek()返回0，清除EOF标记，并且使ungetc()失效(如果有的话)。
错误时返回－1，并设置相就的出错位。
最常见的错误信息是非法流（EBADF）和非法的whence参数。
</p><p>作为选择，标准I/O提供了函数fsetpos():
</p>
<pre>#include &lt;stdio.h&gt;
int fsetpos (FILE *stream, fpos_t *pos);
</pre>
<p>该函数将流stream的当前位置设置为pos.
它等价于参数whence为SEEK_SET时调用函数fseek().
调用成功返回0;否则返回-1,并设置相应的出错位。
这个函数(连同其对应的fgetpos(),后面会讲到)是专门针对其他(非UNIX)平台的，这些平台具有复杂的类型来表示流位置。
在这些平台上，该函数是来以一个任意值来设置流位置的唯一途径，因为C语言的 long 大概是不够的。
linux特色的程序没必要使用这个接口，当然如果想要跨平台支持，也可以利用该函数。
</p><p><br />
标准I/O还提供了一条捷径，rewind():
</p>
<pre>#include &lt;stdio.h&gt;
void rewind (FILE *stream);
</pre>
<p>74 | Chapter 3: Buffered I/O
</p><p><br />
这样调用:
</p>
<pre>rewind (stream);
</pre>
<p>将文件位置重置到流的开始。它等价于:
</p>
<pre>fseek (stream, 0, SEEK_SET);
</pre>
<p>不同的是前者清除了出错标记。
</p><p>请注意，rewind()没有返回值，所以不能直接跟判断出误条件打交道。
调用者如果想确认是否出错，则应该在调用之前清除出错标记errno，并在调用之后检查变量errno是否为0.
例如:
</p>
<pre>errno = 0;
rewind (stream);
if (errno)
   /* error */
</pre>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../c/h/a/Chapter3.html" title="Chapter3">编辑</a>]</div><a name=".E8.8E.B7.E5.8F.96.E5.BD.93.E5.89.8D.E6.B5.81.E7.9A.84.E4.BD.8D.E7.BD.AE"></a><h3>获取当前流的位置</h3>
<p>与lseek()不同，fseek()并不返回更新后的文件位置。
ftell()作为一个单独的接口来实现这个目的，该函数返回文件的当前位置。
</p>
<pre>#include &lt;stdio.h&gt;
long ftell (FILE *stream);
</pre>
<p>出错时返回-1,并设置相应的出错标记。
作为选择，标准I/O还提供了fgetpos():
</p>
<pre>#include &lt;stdioh.h&gt;
int fgetpos (FILE *stream, fpos_t *pos);
</pre>
<p>调用成功，fgetpos()返回0,并将当前文件位置设置为pos.
失败则返回-1,并设置相应的出错标记。
同fsetpos()一样，fgetpos()是专门为具有复杂文件位置类型的非linux平台提供的。
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../c/h/a/Chapter3.html" title="Chapter3">编辑</a>]</div><a name=".E6.B8.85.E9.99.A4.E6.B5.81"></a><h3>清除流</h3>
<p>标准I/O库提供了一个函数用来将用户缓冲区里的内容写入内核，以确保所有的数据都通过write()写入流中。
这个函数就是fflush():
</p>
<pre>#include &lt;stdio.h&gt;
int fflush (FILE *stream);
</pre>
<p>Flushing a Stream | 75
</p><p><br />
</p><p>调用该函数，所有stream指向的流中所有未写的数据均被写入内核。
如果参数stream为NULL，那么进程中所有打开的输入流都会被清除。
调用成功时fflush()返回0,否则返回EOF,并设置相应有出错位。
</p><p>要想理解fflush()的影响，我们必须明白C库的缓冲区与内核自己的缓冲区之间的区别。
本章所描述的所有函数都作用在驻留在用户空间的由C库维护的缓冲区中，而不是内核缓冲区。
这就是性能优化所在，程序是在用户空间，因此运行的是用户区代码，而不涉及系统调用。
只有在需要访问磁盘或其介质时才会进行系统调用。
</p><p><br />
fflush()仅仅只是将用户缓冲区的数据写入内核缓冲区。
其效果等同于不使用用户态缓冲区而直接调用write()函数。
但是它不保证这些数据会被物理地写入介质，要完成这个功能可以调用类似fsync()函数(见第二章“同步I/O”)。
最有可能的情况是，你会先调用fflush(),紧接着调用fsync():
这样的话，首先可以确保用户态缓冲区内容都写入内核缓冲区中， 然后再保障内核缓冲的数据被写入磁盘。
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../c/h/a/Chapter3.html" title="Chapter3">编辑</a>]</div><a name=".E5.87.BA.E9.94.99.E5.A4.84.E7.90.86.E5.8F.8A.E6.96.87.E4.BB.B6.E7.BB.93.E6.9D.9F.28EOF.29"></a><h2>出错处理及文件结束(EOF)</h2>
<p>一些标准I/O接口，如fread(),与调用者的侦错交流很差，因为它们没有提供任何机制去辨别一般出错还是文件结束。
对于这些函数以及其他的一些情况，检查给定流的状态以确定是否出错或到达文件结束是很有用的。
标准I / O提供了两个接口来达到这一目的。
函数ferror()就是用来测试流上是否有出错标记的。
</p>
<pre>include &lt;stdio.h&gt;
int ferror (FILE *stream);
</pre>
<p>出错标记是由其他标准I/O接口为了响影出错情况而设置的。
如果出错标记被设置，函数返为一个非零值，否则返回。
</p><p>函数feof()测试stream上是否有EOF标记。
</p>
<pre>include &lt;stdio.h&gt;
int feof (FILE *stream);
</pre>
<p>EOF标记是由其他标准函数为了响文件结束而设置的。
如果该标记被设置，函数返回非0值，否则返回0.
clearerr()函数用来清除stream的出错和EOF标记。
</p>
<pre>#include &lt;stdio.h&gt;
void clearerr (FILE *stream);
</pre>
<p>76 | Chapter 3: Buffered I/O
</p><p><br />
</p><p>该函数没有返回值并且不会失败(没有办法知道实参stream是否合法)。
clearerr()只应该在检查错误和EOF标记之后调用，因为它们会被不可挽回地丢弃。
比如:
</p>
<pre>/* 'f' 是一个合法的流 */
if (ferror (f)) 
printf ("Error on f!\n");
</pre>
<pre>if (feof (f)) 
printf ("EOF on f!\n");

clearerr (f);
</pre>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../c/h/a/Chapter3.html" title="Chapter3">编辑</a>]</div><a name=".E8.8E.B7.E5.8F.96.E7.9B.B8.E5.BA.94.E7.9A.84.E6.96.87.E4.BB.B6.E6.8F.8F.E8.BF.B0.E7.AC.A6"></a><h2>获取相应的文件描述符</h2>
<p>有时，获取支持给定流的文件描述符是有利的。
比如，当没有相应的标准I/O函数时，通过文件描述符进行系统调用是很有用的。
fileno()用来获取支持流的文件描述符:
</p>
<pre>#include &lt;stdio.h&gt;
int fileno (FILE *stream);
</pre>
<p>调用成功时fileno()返回与stream相对应的文件描述符。
失败时返回-1,这只能发生在当实参stream非法的情况，此时函数置出错标记EBADF.
</p><p>通常不建议混合地使用标准I/O函数与系统调用。
程序员必须谨慎使用fileno()以确保适当的行为。
</p><p><br />
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../c/h/a/Chapter3.html" title="Chapter3">编辑</a>]</div><a name=".E6.93.8D.E6.8E.A7.E7.BC.93.E5.86.B2.E5.8C.BA"></a><h2>操控缓冲区</h2>
<p>标准I/O实现了三种类型的缓冲区,并且为开发者提供了一个接口来操作缓冲类型及缓冲区大小.
不同类型的用户缓冲区服务于不同的目的,并且分别适合不同的情况.下面是这些选择:
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../c/h/a/Chapter3.html" title="Chapter3">编辑</a>]</div><a name=".E6.97.A0.E7.BC.93.E5.86.B2"></a><h3>无缓冲</h3>
<p>不进行任何用户态缓冲,数据直接提交给内核处理.
这是用户态缓冲的对立面,因此此选项是不常用的.
默认情况下,标准错误(stderr)属于此类型.
</p><p>Controlling the Buffering | 77
</p><p><br />
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../c/h/a/Chapter3.html" title="Chapter3">编辑</a>]</div><a name=".E8.A1.8C.E7.BC.93.E5.86.B2"></a><h3>行缓冲</h3>
<p>缓冲是以每一行为基础的.
每个换行符将使缓冲提交给内核.
行缓冲对于向屏幕输出的流是有意义的.
因此,这是终端的却省缓冲(标准输出stdout默认是行缓冲的).
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../c/h/a/Chapter3.html" title="Chapter3">编辑</a>]</div><a name=".E5.9D.97.E7.BC.93.E5.86.B2"></a><h3>块缓冲</h3>
<p>缓冲是以块为单位进行的.
这就是我们在本章开头提到的缓冲类型,它对文件操作来说是最理想的选择.
所有与文件相关的流都是块缓冲的.
标准I/O对此使用的术语是全缓冲.
</p><p>在大多数情况下，默认的缓冲类型是正确的和最佳的。但是，标准I/O也确实提供了一个接口来控制所用缓冲的类型：
</p>
<pre>#include &lt;stdio.h&gt;
int setvbuf (FILE *stream, char *buf, int mode, size_t size);
</pre>
<p>setvbuf()函数将流stream的缓冲类型设置为模式mode,可选模式有:
</p>
<pre>_IONBF 
无缓冲
</pre>
<pre>_IOLBF 
行缓冲
</pre>
<pre>_IOFBF 
块缓冲
</pre>
<p>模式为_IONBF时,buf和size的值被忽略,其他模式下,buf可以指向一个大小为size的缓冲区,标准I/O会将它用作流stream的缓冲区.
如果buf为NULL,glibc会自动为其分配一个缓冲区.
</p><p>必须在打开流后,并且所有对流的其他操作被调用之前,才能调用setvbuf().
成功,返回0,否则返回一个非0值.
</p><p><br />
如果人为地提供了缓冲区,那么它必须在流关闭之前一直存在.
一个常见的错误是在一个作用域里声明一个缓冲,但是这个作用域比流更早地结束了.
特别地,注意不要在main()里提供一个局部缓冲区,然后却没有明确地关闭流.
比如,下面是一个错误的例子:
</p>
<pre>#include &lt;stdio.h&gt;
int main (void) 
{ 
  char buf[BUFSIZ];
  /* set stdin to block-buffered with a BUFSIZ buffer */ 
  setvbuf (stdout, buf, _IOFBF, BUFSIZ);
</pre>
<p>78 | Chapter 3: Buffered I/O
</p><p><br />
</p>
<pre>   printf ("Arrr!\n");
</pre>
<pre>     return 0; 
} 
</pre>
<p>可以这样修复这个错误:在退出作用域之前显式地关闭流,或者将buf设为全局变量.
</p><p>一般来说,开发人员没有必要参与流上的缓冲区.
除了stderr外,终端是行缓冲的才有意义.
文件是块缓冲的才有意义.
默认的缓冲区大小是BUFSIZ,它的定义在&lt;stdio.h&gt;,通常情况下这个值(一个典型块大小的很多倍)是最优的选择.
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../c/h/a/Chapter3.html" title="Chapter3">编辑</a>]</div><a name=".E7.BA.BF.E7.A8.8B.E5.AE.89.E5.85.A8"></a><h2>线程安全</h2>
<p>一簇线程共同运行在同一进程的空间中.
和它等同的概念是多相进程共享同一地地空间.
线程可以运行在任何时间，而且可以覆盖共享数据,只要注意同步地访问数据,或者使数据成为线程局部所有的.
支持线程的操作系统都提供了锁机制(编程结构,以保证线程之间相斥)来确保线程不会改写其他线程的数据.
标准I/O使用这些机制,仅有这些当然是不够的.
比如,有时你会想要锁住一组函数调用,增大临界区(不被其他线程干涉的大块代码)的作用范围.
而在另一些情况下,你可能希望完全取消锁机制来提高效率.
在本节中,我们会分别讨论这两种情况的实现.
</p><p>标准I/O函数天生就是线程安全的.
在内部,这些函数联合了一把锁,一个锁计数器,并且它们被每个流的其中一个线程拥有.
任何指定的线程必须获取了锁才能进行I/O请求.
同一个流上的不同线程不能进行交错地进行标准I/O操作,
因此,在单一的函数调用范围内,标准I/O操作是原子操作.
</p><p>当然在实践中许多应用中需要比单独的函数调用更大意义上的原子操作.
比如,如果多个线程都有写请求,虽然个别写并不会交错，也导致乱码输出，
但也许程序想要每个写操作不被打断,一次性完成.
为此,标准I/O提供了一组函数用来单独地操控与流相关的锁.
</p><p>通常情况下，消除锁将导致各种各样的问题.
但是一些程序可能会明确地将所有的I/O操作都委托给单独一个线程.
在那种情况下,就没必要锁的开销.
</p><p><br />
Thread Safety | 79 
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../c/h/a/Chapter3.html" title="Chapter3">编辑</a>]</div><a name=".E6.89.8B.E5.8A.A8.E9.94.81.E6.96.87.E4.BB.B6"></a><h3>手动锁文件</h3>
<p>调用函数flockfile()时,线程会堵塞直到流没有被锁上,
然后获得锁,增加锁计数器,成为拥有锁的线程,最后返回:
</p>
<pre>#include &lt;stdio.h&gt; 
void flockfile (FILE *stream);
</pre>
<p>函数funlockfile()减少流相关联的锁计数器:
</p>
<pre>#include &lt;stdio.h&gt; 
void funlockfile (FILE *stream);
</pre>
<p>如果锁计数器达到零时,当前线程放弃流的所有权,
另一个线程现在可以获得这个锁.
</p><p>这些函数嵌套调用.也就是说,一个单独的线程可以多次调用flockfile(),
并且流不会被解锁除非该进程调用了同样次数的funlockfile().
</p>
<pre>ftrylockfile()是flockfile()的一个非阻塞版本.
#include &lt;stdio.h&gt;
int ftrylockfile (FILE *stream);
</pre>
<p>如果流目前被锁定,则ftrylockfile()什么都不做立即返回一个非0值.
如果流目前没有被锁定,当前线程获得锁,增加锁计数器,成为拥有锁的线程,并且返回0.
</p><p>我们看一个例子:
</p>
<pre>flockfile (stream);
</pre>
<pre>fputs ("List of treasure:\n", stream); 
fputs (" (1) 500 gold coins\n", stream); 
fputs (" (2) Wonderfully ornate dishware\n", stream);
</pre>
<pre>funlockfile (stream);
</pre>
<p>虽然单独的fputs()操作永远不会产生竞争,比如我们不可能打断"List of treasure",
但是如果来自别的线程中的标准I/O操作也对同一个流进行访问,则有可能打断连续的两个fputs().
理想的情况下,一个应用中多个线程不会访问同一个流.
但是,如果你的程序确实有这种需求的话,你需要一个比单独调用函数更大范围的原子操作
那么flockfile()家族可以帮你扭转败局.
80 | Chapter 3: Buffered I/O
</p><p><br />
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../c/h/a/Chapter3.html" title="Chapter3">编辑</a>]</div><a name=".E4.B8.BA.E6.B5.81.E8.A7.A3.E9.94.81"></a><h3>为流解锁</h3>
<p>还有第二个原因进行手动锁流.
随着对锁的控制粒度更加细化和精确化,而这些操作只能有程序员进行,
有可能需要尽量减少锁的开销来提高性能.
为此,Linux 提供了另外一组函数,它们就像普通标准I/O接口的姊妹组,
他们不进行任何锁操作,实际上他们是标准I/O对应的非加锁版本.
</p><p><br />
</p>
<pre>#define _GNU_SOURCE
#include &lt;stdio.h&gt;
int fgetc_unlocked (FILE *stream);
char *fgets_unlocked (char *str, int size, FILE *stream);
size_t fread_unlocked (void *buf, size_t size, size_t nr,
FILE *stream);
int fputc_unlocked (int c, FILE *stream);
int fputs_unlocked (const char *str, FILE *stream);
size_t fwrite_unlocked (void *buf, size_t size, size_t nr,
FILE *stream);
int fflush_unlocked (FILE *stream);
int feof_unlocked (FILE *stream);
int ferror_unlocked (FILE *stream);
int fileno_unlocked (FILE *stream);
void clearerr_unlocked (FILE *stream);
</pre>
<p>这些函数的功能和对应带锁机制的姊妹函数相同,只是前者不会检查或获取指定流上的锁.
程序员有责任确保在需要的时候,锁能被正确地手动获得和释放.
</p><p><br />
虽然POSIX确实定义了一些标准I/O函数的非带锁版本,但是上面的函数一个也不在POSIX范围内.
它们都是Linux特色的,尽管其他Unix的变种支持其中的一部分.
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../c/h/a/Chapter3.html" title="Chapter3">编辑</a>]</div><a name=".E8.AF.84.E4.BB.B7.E6.A0.87.E5.87.86I.2FO"></a><h2>评价标准I/O</h2>
<p>正如被广泛应用一样,标准I/O也广泛地被专家挑出缺陷.
有些函数如fgets()的功能是不够的.
有些函数如gets()是如此可怕以致于快被逐出标准库了.
</p><p>影响标准I/O性能的头号杀手是双复本.
读数据时,标准I/O发起一个系统调用read()到内核,将数据从内核拷到标准I/O缓冲区.
然后当应用程序通过标准I/O发起一个读请求,比如fgetc(),那么数据会被第二次被拷贝,
这次是从标准I/O的缓冲区拷贝到应用程序提供的缓冲区.
写操作以相反的方式工作:一次是将数据从程序缓冲区拷贝到标准I/O的缓冲区,
然后又被函数write()拷贝到内核.
</p><p>Critiques of Standard I/O | 81
</p><p>一个预防双复本实现方法是,每次读请求都返回一个指向标准I/O缓冲区的一个指针.
那么数据就可以直接被从标准I/O缓冲区里读取,不必再进行一次额外的拷贝.
如果确实需要将数据写入程序内部自己的缓冲区中,比如要对它进行更新,那么总是可以进行手动拷贝.
这个实现过程可以提供一个"免费"的接口:当应用程序结束了对给定读缓冲区的操作时,允许其向外发信号.
</p><p><br />
写操作可能会麻烦一点,但是仍然可以避免双副本.
当发起写请求时,记录下指针.
最后,当要刷新缓冲区数据到内核时,可以遍历所记录的指针,由此将数据写出.
这可以使用分散-收集的I/O,只需要一个系统调用writev()。
(我们将在接下来的一章中讨论到分散-收集的I/O.）
</p><p><br />
C库中存在高度优化的用户缓冲机制,它解决双副本的方法跟我们刚才讨论的很相似.
另外,一些开发者选择去实现自己的用户缓冲方案.
尽管有这些代替品,标准I/O依然很受欢迎.
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../c/h/a/Chapter3.html" title="Chapter3">编辑</a>]</div><a name=".E6.80.BB.E7.BB.93"></a><h2>总结</h2>
<p>标准I/O是由标准C库提供的一个用户态缓冲库.
除去一点小的缺陷，它是一个强大的,非常受欢迎的解决方案。
许多C程序员，事实上,只知道标准的I/O.
当然,对终端I/O来说,基于行的缓冲是理想的,这只能标准I/O来实现.
谁会直接调用write()来打印数据到标准输出?
</p><p><br />
通常情况下,标准I/O及用户态缓冲区在处理下面情况时才有意义:
</p><p>. 你可能会频繁进行系统调用,并且你想要通过合并系统调用来尽量减少开销.
</p><p>. 性能是至关重要的，并且你想要确保所有的I/O操作都是以块大小的整数倍为单位,还要保证块对齐.
</p><p>. 你的访问模式是以字符或行为基础的,你想要一些函数来满足这种要求,并且不通过不相干的系统调用.
</p><p>. 比起低级别的Linux系统调用,你更喜欢高级别的接口.
</p><p>然而,最大的灵活性还是存在于当你直接跟linux系统函数打交道的时候.
下一章中,我们将学习高级形式的I/O以及对应的系统调用.
82 | Chapter 3: Buffered I/O 
</p>
<hr />

<div class="printfooter">
<p>取自"<a href="http://dns.cs.hit.edu.cn../../../c/h/a/Chapter3.html">http://dns.cs.hit.edu.cn../../../c/h/a/Chapter3.html</a>"</p>

<p>本页面已经被浏览270次。 This page was last modified 19:55 2009年3月13日 by <a href="../../../c/u/i/User%7ECuiyuchun.html" class="new" title="User:Cuiyuchun">崔玉春</a>.  </p>
</div>

</div><br style="clear:both" />

<div id='footer'><table border="0" cellspacing="0"><tr><td width='152' rowspan='1'>&nbsp;</td><td class='bottom' align='left' valign='top'><strong><a href="../../../c/h/a/Chapter3.html" title="Chapter3">编辑本页</a></strong> |
<a href="../../../c/h/a/Talk%7EChapter3.html" class="new" title="Talk:Chapter3">讨论本页</a> |
<a href="../../../c/h/a/Chapter3.html" title="Chapter3">较早版本</a> |
<a href="../../../w/h/a/Special%7EWhatlinkshere.html" title="Special:Whatlinkshere">链入页面</a> |
<a href="../../../r/e/c/Special%7ERecentchangeslinked.html" title="Special:Recentchangeslinked">链出更改</a>
<br /><br />

<br /><a href="../../../index.html" title="首页">首页</a> | <a href="../../../w/i/k/Wikipedia%7E%E5%85%B3%E4%BA%8E.html" title="Wikipedia:关于">关于Wikipedia</a> | <a href="../../../r/e/c/Special%7ERecentchanges.html" title="Special:Recentchanges">最近更改</a> | <form name="search" class="inline" method="post" action="../../../s/e/a/Special%7ESearch.html">
<input type="text" name="search" size="19" value="" />
<input type="submit" name="go" value="进入" />&nbsp;<input type="submit" name="fulltext" value="搜索" />
</form><br /><span id="pagestats">本页面已经被浏览270次。 This page was last modified 19:55 2009年3月13日 by <a href="../../../c/u/i/User%7ECuiyuchun.html" class="new" title="User:Cuiyuchun">崔玉春</a>.  </span></td></tr></table>
</div>
</div>

<div id='quickbar'>
<a href='../../../index.html'><img src='../../../../skins/common/images/wiki.jpg' alt='[首页]' /></a>
<hr class='sep' /><a href="../../../index.html">首页</a>
<br /><a href="../../../c/o/m/WIKI-HIT_IBM_CLUB%7ECommunity_Portal_9150.html">社区</a>
<br /><a href="../../../c/u/r/Current_events.html">新闻动态</a>
<br /><a href="../../../r/e/c/Special%7ERecentchanges.html">最近更改</a>
<br /><a href="../../../r/a/n/Special%7ERandom.html">随机页面</a>
<br /><a href="../../../w/i/k/Wikipedia%7E%E5%B8%AE%E5%8A%A9.html">帮助</a>
<br /><a href="../../../s/i/t/WIKI-HIT_IBM_CLUB%7ESite_support.html">Donations</a>
<br />
<hr class='sep' /><strong><a href="../../../c/h/a/Chapter3.html" title="Chapter3">编辑本页</a></strong>
<br /><a href="../../../c/h/a/Talk%7EChapter3.html" class="new" title="Talk:Chapter3">讨论本页</a>
<br /><a href="../../../c/h/a/Chapter3.html" title="Chapter3">较早版本</a>
<br /><a href="../../../w/h/a/Special%7EWhatlinkshere.html" title="Special:Whatlinkshere">链入页面</a>
<br /><a href="../../../r/e/c/Special%7ERecentchangeslinked.html" title="Special:Recentchangeslinked">链出更改</a>
<br /><hr class='sep' /><a href="../../../s/p/e/Special%7ESpecialpages.html" title="Special:Specialpages">特殊页面</a>
<br /><a href="../../../w/i/k/Wikipedia%7E%E9%94%99%E8%AF%AF%E6%8A%A5%E5%91%8A.html" title="Wikipedia:错误报告">错误报告</a>
<br /></div>
<!-- Served by dns.cs.hit.edu.cn in 1351393301.53 secs. -->
</body></html>