<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh-cn" lang="zh-cn" >
<head>
<title>Chapter8C - WIKI-HIT IBM CLUB</title>
<meta name="KEYWORDS" content="首页,ALP,Address,Android,Android Newbie Guide,Android Project Development,Android Research Field,Android Third Party Lib And Tool,BoardGame,CSAPP" />
<meta http-equiv="Content-type" content="text/html; charset=UTF-8" />
<meta name="robots" content="index,follow" />
<link rel="shortcut icon" href="/favicon.ico" />
<link rel='stylesheet' type='text/css' media='print' href='../../../../skins/common/wikiprintable.css' />
<script type="text/javascript" src="../../../../skins/common/wikibits.js"></script>
<style type='text/css'>
/*/*/ /*<![CDATA[*/
@import "../../../../skins/common/wikistandard.css";
@import "../../../s/t/a/MediaWiki%7EStandard.css.html";
a.new, #quickbar a.new { color: #CC2200; }
.editsection { display: none; }
#quickbar { position: absolute; top: 4px; left: 4px; border-right: 1px solid gray; }
#article { margin-left: 152px; margin-right: 4px; }

/*]]>*/ /* */
</style>
</head>

<body bgcolor='#FFFFFF' onload=''>

<div id='content'>
<div id='topbar'>
<table border='0' cellspacing='0' width='98%'>
<tr>
<td width='152' rowspan='1'>&nbsp;</td><td class="top" align='left' valign='top'>
<a href="../../../index.html" title="首页">首页</a> |
<a href="../../../r/e/c/Special%7ERecentchanges.html" title="Special:Recentchanges">最近更改</a> |
<a href="../../../c/h/a/Chapter8C_4f9d.html" title="Chapter8C">编辑本页</a> |
<a href="../../../c/h/a/Chapter8C_4f9d.html" title="Chapter8C">较早版本</a><p class='subtitle'><a href="../../../c/h/a/Chapter8C_4f9d.html">可打印版</a> | <a href="../../../g/e/n/WIKI-HIT_IBM_CLUB%7EGeneral_disclaimer.html" title="WIKI-HIT IBM CLUB:General disclaimer">Disclaimers</a></p>
</td>
<td class="top" valign='top' align='right' nowrap='nowrap'>Not logged in
<br /><a href="../../../u/s/e/Special%7EUserlogin.html" title="Special:Userlogin">登录</a> | <a href="../../../w/i/k/Wikipedia%7E%E5%B8%AE%E5%8A%A9.html" title="Wikipedia:帮助">帮助</a>
<br /><form name="search" class="inline" method="post" action="../../../s/e/a/Special%7ESearch.html">
<input type="text" name="search" size="19" value="" />
<input type="submit" name="go" value="进入" />&nbsp;<input type="submit" name="fulltext" value="搜索" />
</form></td></tr>
</table>
</div>

<div id='article'>
<h1 class="pagetitle">Chapter8C</h1><p class='subtitle'>Wikipedia，自由的百科全书</p>
<p>陈盛版 内存管理
</p><p><br />
</p>
<table id='toc' class='toc'><tr><td><div id='toctitle'><h2>目录</h2></div>
<ul>
<li class='toclevel-1'><a href="#.E7.AC.AC.E5.85.AB.E7.AB.A0_.E5.86.85.E5.AD.98.E7.AE.A1.E7.90.86"><span class="tocnumber">1</span> <span class="toctext">第八章 内存管理</span></a>
<ul>
<li class='toclevel-2'><a href="#.E8.BF.9B.E7.A8.8B.E5.9C.B0.E5.9D.80.E7.A9.BA.E9.97.B4"><span class="tocnumber">1.1</span> <span class="toctext">进程地址空间</span></a>
<ul>
<li class='toclevel-3'><a href="#.E9.A1.B5.E5.92.8C.E5.88.86.E9.A1.B5"><span class="tocnumber">1.1.1</span> <span class="toctext">页和分页</span></a>
<ul>
<li class='toclevel-4'><a href="#.E5.85.B1.E4.BA.AB.E5.92.8C.E5.86.99.E6.97.B6.E5.A4.8D.E5.88.B6"><span class="tocnumber">1.1.1.1</span> <span class="toctext">共享和写时复制</span></a></li>
</ul>
</li>
<li class='toclevel-3'><a href="#.E6.AE.B5"><span class="tocnumber">1.1.2</span> <span class="toctext">段</span></a></li>
</ul>
</li>
<li class='toclevel-2'><a href="#.E5.8A.A8.E6.80.81.E5.86.85.E5.AD.98.E5.88.86.E9.85.8D"><span class="tocnumber">1.2</span> <span class="toctext">动态内存分配</span></a>
<ul>
<li class='toclevel-3'><a href="#.E6.95.B0.E7.BB.84.E5.88.86.E9.85.8D"><span class="tocnumber">1.2.1</span> <span class="toctext">数组分配</span></a></li>
<li class='toclevel-3'><a href="#.E8.B0.83.E6.95.B4.E5.88.86.E9.85.8D.E7.A9.BA.E9.97.B4.E5.A4.A7.E5.B0.8F"><span class="tocnumber">1.2.2</span> <span class="toctext">调整分配空间大小</span></a></li>
<li class='toclevel-3'><a href="#.E9.87.8A.E6.94.BE.E5.8A.A8.E6.80.81.E5.86.85.E5.AD.98"><span class="tocnumber">1.2.3</span> <span class="toctext">释放动态内存</span></a></li>
<li class='toclevel-3'><a href="#.E5.AF.B9.E9.BD.90"><span class="tocnumber">1.2.4</span> <span class="toctext">对齐</span></a>
<ul>
<li class='toclevel-4'><a href="#.E5.88.86.E9.85.8D.E6.97.B6.E7.9A.84.E5.AF.B9.E9.BD.90.E9.97.AE.E9.A2.98"><span class="tocnumber">1.2.4.1</span> <span class="toctext">分配时的对齐问题</span></a></li>
<li class='toclevel-4'><a href="#.E5.85.B6.E5.AE.83.E5.AF.B9.E9.BD.90.E9.97.AE.E9.A2.98"><span class="tocnumber">1.2.4.2</span> <span class="toctext">其它对齐问题</span></a></li>
</ul>
</li>
</ul>
</li>
<li class='toclevel-2'><a href="#.E6.95.B0.E6.8D.AE.E6.AE.B5.E7.AE.A1.E7.90.86"><span class="tocnumber">1.3</span> <span class="toctext">数据段管理</span></a></li>
<li class='toclevel-2'><a href="#.E5.8C.BF.E5.90.8D.E5.86.85.E5.AD.98.E6.98.A0.E5.B0.84"><span class="tocnumber">1.4</span> <span class="toctext">匿名内存映射</span></a>
<ul>
<li class='toclevel-3'><a href="#.E5.88.9B.E5.BB.BA.E5.8C.BF.E5.90.8D.E6.98.A0.E5.B0.84"><span class="tocnumber">1.4.1</span> <span class="toctext">创建匿名映射</span></a></li>
<li class='toclevel-3'><a href="#.E6.98.A0.E5.B0.84.E5.88.B0.2Fdev.2Fzero"><span class="tocnumber">1.4.2</span> <span class="toctext">映射到/dev/zero</span></a></li>
</ul>
</li>
<li class='toclevel-2'><a href="#.E9.AB.98.E7.BA.A7.E5.AD.98.E5.82.A8.E5.99.A8.E5.88.86.E9.85.8D"><span class="tocnumber">1.5</span> <span class="toctext">高级存储器分配</span></a>
<ul>
<li class='toclevel-3'><a href="#.E4.BD.BF.E7.94.A8malloc_usable_size.28.29.E5.92.8Cmalloc_trim.28.29.E8.BF.9B.E8.A1.8C.E5.BE.AE.E8.B0.83"><span class="tocnumber">1.5.1</span> <span class="toctext">使用malloc_usable_size()和malloc_trim()进行微调</span></a></li>
</ul>
</li>
<li class='toclevel-2'><a href="#.E5.AD.98.E5.82.A8.E5.99.A8.E5.88.86.E9.85.8D.E8.B0.83.E8.AF.95"><span class="tocnumber">1.6</span> <span class="toctext">存储器分配调试</span></a>
<ul>
<li class='toclevel-3'><a href="#.E8.8E.B7.E5.8F.96.E7.BB.9F.E8.AE.A1.E8.B5.84.E6.96.99"><span class="tocnumber">1.6.1</span> <span class="toctext">获取统计资料</span></a></li>
</ul>
</li>
<li class='toclevel-2'><a href="#.E5.9F.BA.E4.BA.8E.E6.A0.88.E7.9A.84.E5.88.86.E9.85.8D"><span class="tocnumber">1.7</span> <span class="toctext">基于栈的分配</span></a>
<ul>
<li class='toclevel-3'><a href="#.E6.A0.88.E4.B8.AD.E7.9A.84.E4.B8.B2.E6.8B.B7.E8.B4.9D"><span class="tocnumber">1.7.1</span> <span class="toctext">栈中的串拷贝</span></a></li>
<li class='toclevel-3'><a href="#.E5.8F.AF.E5.8F.98.E9.95.BF.E6.95.B0.E7.BB.84"><span class="tocnumber">1.7.2</span> <span class="toctext">可变长数组</span></a></li>
</ul>
</li>
<li class='toclevel-2'><a href="#.E9.80.89.E6.8B.A9.E4.B8.80.E7.A7.8D.E5.86.85.E5.AD.98.E5.88.86.E9.85.8D.E6.9C.BA.E5.88.B6"><span class="tocnumber">1.8</span> <span class="toctext">选择一种内存分配机制</span></a></li>
<li class='toclevel-2'><a href="#.E5.AD.98.E5.82.A8.E5.99.A8.E6.93.8D.E4.BD.9C"><span class="tocnumber">1.9</span> <span class="toctext">存储器操作</span></a>
<ul>
<li class='toclevel-3'><a href="#.E5.AD.97.E8.8A.82.E8.AE.BE.E7.BD.AE"><span class="tocnumber">1.9.1</span> <span class="toctext">字节设置</span></a></li>
<li class='toclevel-3'><a href="#.E5.AD.97.E8.8A.82.E6.AF.94.E8.BE.83"><span class="tocnumber">1.9.2</span> <span class="toctext">字节比较</span></a></li>
<li class='toclevel-3'><a href="#.E5.AD.97.E8.8A.82.E7.A7.BB.E5.8A.A8"><span class="tocnumber">1.9.3</span> <span class="toctext">字节移动</span></a></li>
<li class='toclevel-3'><a href="#.E5.AD.97.E8.8A.82.E6.90.9C.E7.B4.A2"><span class="tocnumber">1.9.4</span> <span class="toctext">字节搜索</span></a></li>
<li class='toclevel-3'><a href="#.E5.AD.97.E8.8A.82.E7.BC.96.E7.A0.81"><span class="tocnumber">1.9.5</span> <span class="toctext">字节编码</span></a></li>
</ul>
</li>
<li class='toclevel-2'><a href="#.E5.AD.98.E5.82.A8.E5.99.A8.E9.94.81.E5.AE.9A"><span class="tocnumber">1.10</span> <span class="toctext">存储器锁定</span></a>
<ul>
<li class='toclevel-3'><a href="#.E9.94.81.E5.AE.9A.E9.83.A8.E5.88.86.E5.9C.B0.E5.9D.80.E7.A9.BA.E9.97.B4"><span class="tocnumber">1.10.1</span> <span class="toctext">锁定部分地址空间</span></a></li>
<li class='toclevel-3'><a href="#.E9.94.81.E5.AE.9A.E5.85.A8.E9.83.A8.E5.9C.B0.E5.9D.80.E7.A9.BA.E9.97.B4"><span class="tocnumber">1.10.2</span> <span class="toctext">锁定全部地址空间</span></a></li>
<li class='toclevel-3'><a href="#.E5.AD.98.E5.82.A8.E5.99.A8.E8.A7.A3.E9.94.81"><span class="tocnumber">1.10.3</span> <span class="toctext">存储器解锁</span></a></li>
<li class='toclevel-3'><a href="#.E9.94.81.E5.AE.9A.E9.99.90.E5.88.B6"><span class="tocnumber">1.10.4</span> <span class="toctext">锁定限制</span></a></li>
<li class='toclevel-3'><a href="#.E5.88.A4.E6.96.AD.E4.B8.80.E4.B8.AA.E9.A1.B5.E6.98.AF.E5.90.A6.E5.9C.A8.E5.86.85.E5.AD.98.E4.B8.AD"><span class="tocnumber">1.10.5</span> <span class="toctext">判断一个页是否在内存中</span></a></li>
</ul>
</li>
<li class='toclevel-2'><a href="#.E6.8A.95.E6.9C.BA.E6.80.A7.E5.AD.98.E5.82.A8.E5.88.86.E9.85.8D"><span class="tocnumber">1.11</span> <span class="toctext">投机性存储分配</span></a>
<ul>
<li class='toclevel-3'><a href="#.E8.BF.87.E9.87.8F.E5.88.86.E9.85.8D.E5.92.8C.E5.86.85.E5.AD.98.E4.B8.8D.E8.B6.B3"><span class="tocnumber">1.11.1</span> <span class="toctext">过量分配和内存不足</span></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</td></tr></table>
<p><script type="text/javascript"> if (window.showTocToggle) { var tocShowText = "显示"; var tocHideText = "隐藏"; showTocToggle(); } </script>
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../c/h/a/Chapter8C_4f9d.html" title="Chapter8C">编辑</a>]</div><a name=".E7.AC.AC.E5.85.AB.E7.AB.A0_.E5.86.85.E5.AD.98.E7.AE.A1.E7.90.86"></a><h1>第八章 内存管理</h1>
<p><a href="../../../l/s/p/Image%7ELSP.JPG_22ca.html" class="image" title="Image:LSP.JPG"><img src="../../../../upload/d/d0/LSP.JPG" alt="Image:LSP.JPG" width="190" height="163" longdesc="../../../l/s/p/Image%7ELSP.JPG_22ca.html" /></a>
</p><p>对于一个进程来说，内存是最基本也是最重要的资源之一。这章包括了内存管理的以下几个方面：内存分配，内存的使用以及最后内存的释放。
分配(allocate)这个词(最常用的短语就是分配内存)在这里总是有些让人误解。因为它总是让人联想到分配一个稀缺的供不应求的资源。可以确定的是，大多数的用户都喜欢拥有更多的内存。然而在现代的系统中，问题的关键并不是如何在大量的内存中共享一小块内存，而是如何适当的使用并记录下分配的过程。
在这章中，你将会学到一个进程在不同区域分配内存的所有方法以及每种方法的好坏。我们还要复习如何操控任意内存区域中的内容，并了解如何锁定内存以保证进程在运行过程中常驻在内存中而不需要担心有内核从交换区交换数据的风险。
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../c/h/a/Chapter8C_4f9d.html" title="Chapter8C">编辑</a>]</div><a name=".E8.BF.9B.E7.A8.8B.E5.9C.B0.E5.9D.80.E7.A9.BA.E9.97.B4"></a><h2><b>进程地址空间</b></h2>
<p>像其他现代的操作系统一样，Linux将物理内存虚拟化。进程并不直接通过物理地址进行寻址，而是由Linux为每个进程维护一个特殊的虚拟地址空间。这个地址空间是线性的，地址从零开始一直增加到最大值。
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../c/h/a/Chapter8C_4f9d.html" title="Chapter8C">编辑</a>]</div><a name=".E9.A1.B5.E5.92.8C.E5.88.86.E9.A1.B5"></a><h3>页和分页</h3>
<p>虚拟地址空间以页的形式进行组织。系统的体系结构以及机器的类型决定了页的大小（页的大小是固定的），典型的页的大小包括32位系统的4K和64位系统的8K*。每一页都只可能处于有效或空闲这两种状态。一个有效页与物理内存中的页或是一些二级存储（备用存储）如某个交换分区或是硬盘里的某个文件相关联。没有被分配的页不和任何地址关联并被标记上了空闲。连接这样一个页会造成段错误（段冲突）。地址空间不需要是连续的，当它们被线性的编址时，会有很多间断的地方。
</p><p>一个进程不能访问一个处在二级存储中的页，除非这个页和物理内存中的页建立的关联。当一个进程试图访问这样的页时，存储控制单元MMU会产生一个页错误，然后内核就会进行干预，透明的将这个需要的页从二级存储中调入物理内存。因为一般来说虚拟存储器总是要比物理内存大（在有的系统中一个虚拟内存空间就比物理内存大）。同时内核也会将物理内存中的页调出以使更多需要使用的页调入物理内存。内核总是倾向于将在未来最不可能使用的页调出，以使得性能最优。
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../c/h/a/Chapter8C_4f9d.html" title="Chapter8C">编辑</a>]</div><a name=".E5.85.B1.E4.BA.AB.E5.92.8C.E5.86.99.E6.97.B6.E5.A4.8D.E5.88.B6"></a><h4>共享和写时复制</h4>
<p>虚存中大量的页面能被映射到同一个物理内存中的页，即使它们属于不同进程的虚拟地址空间。这就允许不同的虚拟地址空间共享这个物理内存中的数据。这些被共享的数据可能是只读的或者可读可写的。
</p><p>当一个进程试图写某个共享的可写页时，可能发生以下两种情况之一，最简单的情况是内核允许这个行为，在这种情形下所有共享这个页的进程都将看到这次写操作。通常，允许多个进程读写一个共享的内存需要一些协调和同步。
</p><p>而另一种是MMU会截取这次写操作并产生一个异常，作为回应，内核就会透明的创造一份这个页的拷贝以供该进程进行写操作。我们将这种方法称为写时复制(COW)†。允许进程读共享的数据可以有效的节省空间。当一个进程试图写一个共享的页时，它就得到了那个页的一份拷贝，这使得内核看来这个进程始终都有一份自己的拷贝。使用这种建立在分页机制上的写时复制的方法，一个大文件可以有效的被众多进程共享，而每个单独的进程则只拥有它们需要写的那个页的拷贝。
</p>
<pre>*一些系统支持不同的页大小。因此页的大小并不是ABI的一部分。应用程序必须在运行时获取页的大小。我们在第四章中介绍了这部分内容并会在这章里进行复习。
</pre>
<pre>†回忆一下第五章中的fork()函数，它使用了写时复制来为子进程复制和共享父进程的地址空间。
</pre>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../c/h/a/Chapter8C_4f9d.html" title="Chapter8C">编辑</a>]</div><a name=".E6.AE.B5"></a><h3>段</h3>
<p>内核将具有某些相同特征的页组织成块，如拥有的权限。这些块被称为内存区域，段或是映射。每个进程中都可以找到以下段。
</p><p>•代码段：代码段包含了进程的代码，字符串，常量和其他一些只读的数据。在Linux中，这个段被标记为只读，并且直接从目标文件（可执行程序或是库文件）映射到内存中。
</p><p>•堆栈段：堆栈段包含了进程的执行栈。它会随着栈深度的缩减动态的增长或缩短。执行栈包括了程序的局部变量和函数的返回值。
</p><p>•数据段：数据段（或堆）包含了程序的动态存储空间。这个段是可写的，而且它的大小是可以变化的。通过malloc函数返回的空间就在这个段中（将在下一节进行讨论）。
</p><p>•附加段*：附加段包含了没有初始化的全局变量。这些变量根据不同的C标准都有特殊的值（比如都为0）。
</p><p>Linux通过两种方式对这些变量进行优化。首先，因为附加段中只存储未初始化的数据，链接器不会将这些特殊的变量存储在目标文件中，这减少了二进制文件的大小。第二，当段被载入内存时，内核只是简单的根据写时复制的原则将它们映射到一个全是0的页上，这样就十分有效的设置了这些变量的初始值。
</p><p>大多数地址空间含有很多映射文件，比如程序的执行文件，C或是其他语言的链接库和数据文件。看一下/proc/self/maps中的内容，或者看一下pmap程序的输出，这是一个可以看进程中映射文件的很好的例子。
</p><p>这章讲述了Linux提供的用来获得和释放内存以及生成和销毁映射以及所有在这之间的接口。
</p>
<pre>*这个名字有一定的历史，来自于block started by symbol
</pre>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../c/h/a/Chapter8C_4f9d.html" title="Chapter8C">编辑</a>]</div><a name=".E5.8A.A8.E6.80.81.E5.86.85.E5.AD.98.E5.88.86.E9.85.8D"></a><h2>动态内存分配</h2>
<p>内存同样以静态或自动变量的形式构成，但是所有内存管理系统的基础都是动态内存的分配，使用以及最终的返回。动态内存是在运行时才分配的，而不是在编译时就分配好了的，而要分配的大小也只有在分配时才知道。作为一个程序员，当在程序运行前你不知道你需要多大的空间，或是你需要使用这块内存的时间不定，那你就需要使用动态内存。比如说，你可能想要在存储一个文件的内容或是从键盘读入要输入的内容。由于文件的大小以及用户输入内容的长度是不定的，因此所需的内存的大小是可变的，而你就必须给更多的数据动态的分配内存。
</p><p>C中没有变量是被直接存储在动态内存中的。比如说，C不会提供在动态内存中获取结构体struct pirate_ship的机制，而是提供了一种在动态内存中为pirate_ship分配一个足够大空间的机制。程序员通过一个指针来对这块内存进行操作，在这个例子中这个指针就是struct pirate_ship*。
</p><p>C中最经典获得动态内存的接口就是malloc函数：
</p>
<pre>#include &lt;stdio.h&gt;
void *malloc(size_t size);
</pre>
<p>一次对malloc的成功调用可以分配到size个字节的内存，并返回一个指向这片区域开始的指针。这块区域的内容是未定的，而不是0。如果分配失败，那么malloc将返回一个NULL同时errno设置为ENOMEM。
</p><p>malloc的使用非常直接，就像在这个例子中用来分配一块固定字节大小的区域。
</p>
<pre>char *p;
/* give me 2 KB! */
p = malloc (2048);
if (!p)
    perror ("malloc");
</pre>
<p>以下是一个分配结构体的例子：
</p>
<pre>struct treasure_map *map;
/*
* allocate enough memory to hold a treasure_map stucture
* and point 'map' at it
*/
map = malloc (sizeof(struct treasure_map));
if (!map)
    perror ("malloc");
</pre>
<p>C语言会自动将指针类型从void转换为需要的类型。因此这些例子中不需要将malloc返回的指针强制转换为其他的类型。然而C++语言并不会将指针自动设为void，因此C++的程序员需要像下面这个例子一样将返回的指针强制转化为别的类型。
</p>
<pre>char *name;
/* allocate 512 bytes */
name = (char *) malloc (512);
if (!name)
    perror ("malloc");
</pre>
<p>一些C的程序员喜欢将所有返回指针函数（包括malloc）的返回值强转为void，我并不赞赏这种行为，因为这之中隐含了一些问题。当函数的返回值变为其它不是void的指针时就会有错。另外如果函数没有被正确的声明，这样的强转同样会产生问题*。如果说使用malloc时不会产生前一个问题，但后一个问题却很有可能发生。
</p><p>因为malloc可以返回NULL，这对于那些习惯于检查错误的程序员来说是非常重要的。很多程序定义或使用malloc函数来封装，当malloc返回NULL时就打印错误信息或是终止程序。根据约定，程序员们把这个封装叫作xmalloc()。
</p>
<pre>/* like malloc( ), but terminates on failure */
void * xmalloc (size_t size)
{
    void *p;
    p = malloc (size);
    if (!p) {
            perror ("xmalloc");
            exit (EXIT_FAILURE);
    }
    return p;
}
</pre>
<pre>*没有声明的函数默认返回int类型，而int类型到指针类型的转换并不是自动的，并会产生一个警告。强转会隐藏这个警告
</pre>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../c/h/a/Chapter8C_4f9d.html" title="Chapter8C">编辑</a>]</div><a name=".E6.95.B0.E7.BB.84.E5.88.86.E9.85.8D"></a><h3>数组分配</h3>
<p>当所需分配的内存大小本身是可变的时，动态分配内存将更复杂。分配数组空间就是这样一个例子。数组中元素的大小是确定的，但数组元素的个数确实不定的。为了简化这个问题，C提供了calloc()这个函数。
</p>
<pre>#include &lt;stdlib.h&gt;
void * calloc (size_t nr, size_t size);
</pre>
<p>一次成功的calloc调用会返回一个指针，指向一块可以存储下整个数组的内存(nr个元素，每个为size个字节)。就结果来说，这两种内存申请方式得到的内存大小是一样的。（两个都会返回更多的空间，但一定不会变少）。
</p>
<pre>int *x, *y;
x = malloc (50 * sizeof (int));
if (!x) {
        perror ("malloc");
        return -1;
}
y = calloc (50, sizeof (int));
if (!y) {
        perror ("calloc");
        return -1;
}
</pre>
<p>上面的例子中两个的效果是不一样的。不像malloc，calloc将分配的区域全部用0进行初始化。因此y中的50个元素都被赋值为0，而x中的元素则未被赋值。除非数组中的元素要被立刻赋值，否则程序员应该使用calloc来为数组申请空间以保证数组中的元素不会是一些乱的值。另外，需要注意的是二进制的0和浮点数的0是不一样的。
</p><p>用户经常希望用0来初始化动态分配得到的内存，即使这内存不是用来存的数组。在这章稍后一点的地方，我们会提到memset函数，它提供了接口来为一块内存中的每个字节赋值。另外使用calloc会更快，因为内核可以直接提供一块已经被赋值为0的内存块。
</p><p>当分配失败是，和malloc一样，calloc返回NULL，同时将errno设置为ENOMEM。
</p><p>我们不清楚为什么C标准不提供一个calloc以外的函数用来分配以及初始化。但是程序员们可以很容易的定义自己的接口。
</p>
<pre>/* works identically to malloc( ), but memory is zeroed */
void * malloc0 (size_t size)
{
    return calloc (1, size);
}
</pre>
<p>另外我们可以非常方便的将malloc0和我们之前的xmalloc结合起来。
</p>
<pre>/* like malloc( ), but zeros memory and terminates on failure */
void * xmalloc0 (size_t size)
{
    void *p;
    p = calloc (1, size);
    if (!p) {
            perror ("xmalloc0");
            exit (EXIT_FAILURE);
    }
    return p;
}
</pre>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../c/h/a/Chapter8C_4f9d.html" title="Chapter8C">编辑</a>]</div><a name=".E8.B0.83.E6.95.B4.E5.88.86.E9.85.8D.E7.A9.BA.E9.97.B4.E5.A4.A7.E5.B0.8F"></a><h3>调整分配空间大小</h3>
<p>C语言提供了一个用来调整已经分配空间大小(可以变大，也可以变小)的函数
</p>
<pre>#include &lt;stdlib.h&gt;
void * realloc (void *ptr, size_t size);
</pre>
<p>一次realloc的成功调用将ptr指向的内存空间调整为size大小。它返回一个指向新空间的指针，当试图扩大内存块的时候返回的指针可能不再是ptr。如果realloc不能在已有的空间上增加到size大小，那么就会另外申请一块size大小的空间，将原本的数据拷贝到新空间中，然后再将老的空间释放。在任何操作中，内存区域中的内容都将被保存在新旧区域较小的地方。因为有可能需要进行数据的拷贝，用realloc来扩大申请的内存空间将会非常耗时。
</p><p>如果size是0，那么就相当于对ptr调用的free()。
</p><p>如果ptr是NULL，那么结果和调用malloc是一样的。而如果ptr不是NULL，那它之前必定是通过malloc(),calloc()或是realloc()返回的。
</p><p>如果扩大失败，那么realloc()会返回一个NULL，并将errno设置为ENOMEM，而ptr指向的位置不会发生变化。
</p><p>下面让我们来看一个缩小内存空间的例子。首先我们用calloc()来申请一块足够大的空间，用来存储一个含有两个元素的map结构体数组。
</p>
<pre>struct map *p;
/* allocate memory for two map structures */
p = calloc (2, sizeof (struct map));
if (!p) {
        perror ("calloc");
        return -1;
}
/* use p[0] and p[1]... */
</pre>
<p>现在我们假设我们已经找到了其中一个宝藏，于是我们不再需要第二张地图了，所以我们想要缩小我们申请的这块空间，将一半返回给系统。（这可能不是一个非常有意义的操作，但是当map这个结构体非常大或是我们想要保存剩下的那个map很长时间的话，这就变的很有意义了）
</p>
<pre>struct map *r;
/* we now need memory for only one map */
r = realloc (p, sizeof (struct map));
if (!r) {
        /* note that 'p' is still valid! */
        perror ("realloc");
        return -1;
}
/* use 'r'... */
free (r);
</pre>
<p>在这个例子中，p[0]在调用realloc后被保存了下来。之前存储的数据都被保留下来。    如果函数调用失败，表明p并未改变，仍然有效。我们可以继续使用它，并应该最终进行释放。相反，如果调用成功，我们就忽略p，而在相关的地方都使用r（其实和p相同，只是指向的空间变小了）。同时我们也有责任在使用完r之后将其释放。
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../c/h/a/Chapter8C_4f9d.html" title="Chapter8C">编辑</a>]</div><a name=".E9.87.8A.E6.94.BE.E5.8A.A8.E6.80.81.E5.86.85.E5.AD.98"></a><h3>释放动态内存</h3>
<p>不像自动分配内存，当栈的指针向上移时，空间被自动释放。动态申请的空间是一直驻留在进程的地址空间中的直到它们被释放。因此，程序员们有责任将申请到的空间返回给系统。（当然，不管是静态还是动态的空间，在进程退出时都将被释放）。
</p><p>通过malloc()、calloc()或是realloc()申请到的空间都必须在不需要使用的时候通过free()函数进行释放。
</p>
<pre>#include &lt;stdlib.h&gt;
void free (void *ptr);
</pre>
<p>调用free()函数，释放了指针ptr指向的内存空间。参数ptr必须是之前通过malloc()、calloc()或是realloc()返回的。也就是说，你不能用free()来释放申请到的部分内存，比如说用一个指针指向一块空间一半的位置。
</p><p>ptr可能是NULL，在这种情况下free()什么都不返回。这也是我们会再三看到在调用free()之前先检查一下ptr是否为空的原因。
</p><p>让我们来看一个例子。
</p>
<pre>void print_chars (int n, char c)
{
    int i;
    for (i = 0; i &lt; n; i++) {
             char *s;
             int j;
             /*
              * Allocate and zero an i+2 element array
              * of chars. Note that 'sizeof (char)'
              * is always 1.
              */
             s = calloc (i + 2, 1);
             if (!s) {
                     perror ("calloc");
                     break;
             }
             for (j = 0; j &lt; i + 1; j++)
          	 s[j] = c;
             printf ("%s\n", s);
             /* Okay, all done. Hand back the memory. */
             free (s);
    }
}
</pre>
<p>这个例子为n个字符数组分配了空间，n个数组的元素个数依次递增，从两个元素（2字节）一直到n+1个元素（n+1字节）。然后，循环将数组中的最后一个元素外的元素赋值为c（最后一个字节为0），之后将字符串打印，最后将s释放。
</p><p>调用print_chars()函数，并然n=5,c='X'，我们可以得到如下图形。
</p>
<pre>X
XX
XXX
XXXX
XXXXX
</pre>
<p>当然，想要实现这个函数的功能还有很多其它有效的方法。但关键是我们可以动态的分配和释放内存，即使我们只有在运行时才知道需要分配多大的内存。
</p><p><a href="../../../%E7%88%AA/%E5%AD%90/./Image%7E%E7%88%AA%E5%AD%90.JPG_2b15.html" class="image" title="Image:爪子.JPG"><img src="../../../../upload/8/86/%E7%88%AA%E5%AD%90.JPG" alt="Image:爪子.JPG" width="103" height="101" longdesc="../../../%E7%88%AA/%E5%AD%90/./Image%7E%E7%88%AA%E5%AD%90.JPG_2b15.html" /></a>有些Unix系统，像SunOS，SCO提供一个free()的变体cfree()，它根据系统的不同和free()作用相同，有的接受三个参数，与calloc()相对。在Linux中，free()可以用来释放由任意一种我们讨论过动态分配内存的函数获得的空间。除非要考虑向下兼容的问题，不然我们不应该使用cfree()。所有Linux的版本中free()都是一样的。
</p><p>需要指出的是如果上面的例子中没有调用free()会发生什么。程序将永远将得到的内存返回个系统，更糟糕的是，唯一指向这块区域的指针s会消失，使得我们再也没有办法对这块内存进行操作。我们将这种错误称之为内存泄漏。内存泄漏以及其它一些动态内存产生的问题是很多程序中经常出现的，而这种错误也是在C语言编程中最有害。由于C语言将所有的内存管理交给程序员，因此C的程序员必须对内存管理的问题非常敏感。
</p><p>另外一个常见的错误是释放后事用。这个错误发生在将一块内存释放后却还是去访问它。一旦调用了free()释放了某块内存，我们就再也不能对其进行操作了。程序员们必须特别注意那些悬空指针（一种指针，它指向不再存在的对象。虽然指针变量仍包含有效的内存地址，但该地址中的数据不再有效，原因通常是该地址已通过调用free()而释放）或是虽然非空但指向那些无效区域的指针。有两个常用的工具可以帮助你解决这些问题：Electric Fence和valgrind。
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../c/h/a/Chapter8C_4f9d.html" title="Chapter8C">编辑</a>]</div><a name=".E5.AF.B9.E9.BD.90"></a><h3>对齐</h3>
<p>数据的对齐指的是数据的地址和由硬件决定的内存块大小之间的关系。一个变量所在的地址是它大小的整数倍时就叫做自然对齐。比如说一个32位的变量所在的地址如果是4的整数倍那么就叫做对齐，也就是地址中最低的两位都是0。因此，一个2n字节的变量的地址的最低n位（？）应该是0。
</p><p>对齐的规则是根据硬件制定的。在某些计算机体系结构中对数据的对齐有着极其严格的要求。在有的系统中，载入一个没有对齐的数据将导致处理器的错误。在其它系统中，读取非对齐的数据不会出错，但却会造成性能的下降。在编写可移植的程序时，对齐的问题一定要注意，要保持变量的自动对齐。
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../c/h/a/Chapter8C_4f9d.html" title="Chapter8C">编辑</a>]</div><a name=".E5.88.86.E9.85.8D.E6.97.B6.E7.9A.84.E5.AF.B9.E9.BD.90.E9.97.AE.E9.A2.98"></a><h4>分配时的对齐问题</h4>
<p>在大部分的时候，编译器和C的库显性的解决了对齐的问题。POSIX规定通过malloc(),calloc()和realloc()返回的内存空间对于C中的标准类型都应该是对齐的。在Linux中，这些函数在32位机器上总是返回8字节对齐，而在64位则返回16字节对齐的。
</p><p>在某些情况下，程序员们需要按着更大的空间对齐，比如说一个页。虽然需要的理由不同，但往往是需要适当的将I/O接口的缓冲区或是其它软硬件通信的接口对齐。为此，POSIX1003.1d提供了一个叫 posix_memalign()的函数。
</p>
<pre>/* one or the other -- either suffices */
#define _XOPEN_SOURCE 600
#define _GNU_SOURCE
#include &lt;stdlib.h&gt;
int posix_memalign (void **memptr,
                    size_t alignment,
                    size_t size);
</pre>
<p>一次对posix_memalign()的成功调用会分配一个size大小的动态内存并保证是按照alignment进行对齐的。参数alignment必须是2的幂次，以及一个void类型指针大小的整数倍。分配得到地址的内存存放在memptr中，函数返回0。
</p><p>如果分配失败，就不会分配到内存。memptr也将是未定义的，函数会返回以下几种错误信息之一：
</p><p>EINVAL：参数alignment不是2的幂次，或不是一个void类型指针大小的整数倍。
</p><p>ENOMEM：没有有效的内存可以满足需要。	
</p><p>需要注意的是errno没有被设置，函数直接返回了这些错误信息。
</p><p>通过posix_memalign()获得的空间也用free()来释放。使用是非常简单的。
</p>
<pre>char *buf;
int ret;
/* allocate 1 KB along a 256-byte boundary */
ret = posix_memalign (&amp;buf, 256, 1024);
if (ret) {
         fprintf (stderr, "posix_memalign: %s\n",
                 strerror (ret));
         return -1;
}
/* use 'buf'... */
free (buf);
</pre>
<p>之前的接口：造POSIX定义posix_memalign()之前，BSD和SunOS都定义了自己的接口：
</p>
<pre>#include &lt;malloc.h&gt;
void * valloc (size_t size);
void * memalign (size_t boundary, size_t size);
</pre>
<p>valloc函数的功能和malloc基本相同，除了它需要按照页对齐。回想一下第四章，系统中页的大小可以很方便的通过getpagesize()函数获得。
</p><p>memalign函数也差不多，只是它根据boundary来进行对齐。当然boundary必须是2的幂次。下面的例子中两个函数都返回了一块可以存下ship结构的内存空间，并且是按照页对齐的。
</p>
<pre>struct ship *pirate, *hms;
pirate = valloc (sizeof (struct ship));
if (!pirate) {
             perror ("valloc");
             return -1;
}
hms = memalign (getpagesize ( ), sizeof (struct ship));
if (!hms) {
          perror ("memalign");
          free (pirate);
          return -1;
}
/* use 'pirate' and 'hms'... */
free (hms);
free (pirate);
</pre>
<p>在linux中，通过这些函数获得的内存空间都是通过free()进行释放的。然而在一些Unix系统中却不一定是这样，有的根本没有提供可以释放这些空间的接口。使用这些函数的程序只能非常无奈的不将这些空间进行释放。
</p><p>只有为了移植到更老的系统上时，Linux的程序员才可以使用这两个函数。否则，posix_memalign()应该被优先选择。	所有三个函数只有当malloc()的对齐无法满足是才应该被使用。
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../c/h/a/Chapter8C_4f9d.html" title="Chapter8C">编辑</a>]</div><a name=".E5.85.B6.E5.AE.83.E5.AF.B9.E9.BD.90.E9.97.AE.E9.A2.98"></a><h4>其它对齐问题</h4>
<p>除了标准类型的对齐和内存分配，对齐问题还可以进行扩展。比如说，复杂的数据类型的对齐问题将会比标准类型的更复杂。另外，在对不同类型的指针进行赋值以及强制类型转换的时候，对齐的问题将变得重要。
</p><p><b>非标准类型</b>:非标准类型和复杂的数据结构比自然对齐有着更多的要求，下面是四条有用的规则：
</p><p>•结构体的对齐以其中最大的成员变量的大小作为标准。比如说，一个结构体中最大的数据类型是一个按照4字节对齐的32位整数，那这个结构体就必须按照4字节对齐。
</p><p>•结构体同时还存在填充的问题。这是为了保证结构体中的每个成员变量都满足自身的对齐规则。因此如果一个char类型（1字节对齐），后面跟了一个int类型（4字节对齐），那么编译器就会在两个变量之间插入3个字节以使得int类型的变量满足4字节对齐。程序员们有时应该注意一下结构体中成员变量的顺序，来使得空间的浪费达到最小，比如说通过将成员变量按照类型的大小进行排序。在GCC中加入-Wpadded可以帮助你应付这个问题。它会在填充时发出警告。
</p><p>•联合体的对齐是根据最大的成员变量的大小进行对齐的。
</p><p>•数组的对齐就是它基类型的对齐。因此当只有一个成员的时候，数组的对齐不存在别的什么要求。
</p><p><b>指针问题</b>当编译器显性的处理大多数的对齐问题时，它还会试着去发现一些潜在的问题。然而却从来没有听过在处理指针和强转问题时遇到对齐的问题。
</p><p>假设一个指针从一个低字节对齐的类型强转为一个高字节对齐的类型，当通过这样的指针来访问数据会导致处理器读取那些没有根据高字节进行对齐的数据(?)。让我们来看一下下面这个代码，它试图用unsigned long类型来读取c，并对badnews进行赋值。
</p>
<pre>char greeting[] = "Ahoy Matey";
char *c = greeting[1];
unsigned long badnews = *(unsigned long *) c;
</pre>
<p>一个unsigned long的变量可能是按照4字节或是8字节进行对齐的。而C是以1字节为边界进行对齐的(?)。因此当c强转之后再进行读取将会导致对齐错误。根据系统体系结构的不同，这可能会产生不同程度的问题，小的可能产生性能问题，而严重的可能会导致程序的崩溃。在那些可以检测但不能处理这种对齐问题的体系结构中，内核将会向出线问题的进程发出SIGBUS信号，终止这个进程。我们将会在第九章讨论这个信号。
</p><p>像这样的例子在现实中出现的远远比你想的要多。当然现实中的例子肯定不会想这个这么明显，它们将会更加隐蔽。
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../c/h/a/Chapter8C_4f9d.html" title="Chapter8C">编辑</a>]</div><a name=".E6.95.B0.E6.8D.AE.E6.AE.B5.E7.AE.A1.E7.90.86"></a><h2>数据段管理</h2>
<p>Unix系统历来都会提供一些直接管理数据段的接口函数。然而，大多数的程序都不会使用这些函数，因为malloc()和其它的分配方案都比这些函数要简单的多，而且它们也更加强大。在这里我会讲述这些函数以满足部分读者的好奇以及少数想要实现自己的基于堆的分配机制：
</p>
<pre>#include &lt;unistd.h&gt;
int brk (void *end);
void * sbrk (intptr_t increment);
</pre>
<p>这些函数继承了一些老版本Unix系统中函数的名字，在这些系统中，堆和栈都在一个数据段中。动态的堆分配从段的最低端开始向上增长，而栈则从段的最顶部向下生长。两者以分隔点或分隔线分开。现代的系统中数据段独立的有自己的内存映射，我们仍用映射最后的地址来标记分割点。
</p><p>一次brk()的调用将分隔点（数据段的结尾）设定在制定地址的后面。如果调用成功，它会返回0，调用失败则返回-1,并将errno设为ENOMEM。
</p><p>调用sbrk()会把数据段的结尾增加increment个单位。increment可正可负。sbrk()返回更新后分隔点。因此，如果将increment设为0,那么就将返回当前分隔点的值：
</p>
<pre>printf ("The current break point is %p\n", sbrk (0));
</pre>
<p>POSIX和C标准都没有定义这两个函数，但几乎所有的Unix系统都至少支持其中之一。需要可移植的程序应该严格遵守基于各标准的接口函数。
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../c/h/a/Chapter8C_4f9d.html" title="Chapter8C">编辑</a>]</div><a name=".E5.8C.BF.E5.90.8D.E5.86.85.E5.AD.98.E6.98.A0.E5.B0.84"></a><h2>匿名内存映射</h2>
<p>在glibc库中的内存分配都使用的数据段和内存映射。最基本的实现方法malloc()是为了将数据段分为一系列2的幂次大小的块，通过返回最接近要求大小的块来实现分配。释放则只是简单的将这块区域标记为未使用。如果相邻的块都是空闲的，那么它们可以组合成一个更大的块。如果堆的最顶端是空的，那么系统可以调用brk()来降低分隔点以缩小堆，而把不用的内存返回给系统。
</p><p>这个算法叫作buddy memory allocation scheme。它的优点在于简单速度快，但却也有着会产生两种碎片的缺点。内部碎片是在一个已分配块比有效载荷大时发生的。这导致了内存的不完全利用。外部碎片是在空闲存储器合计起来足够满足一个分配请求，但是没有一个单独的空间块足够大可以来处理这个请求时发生的。这同样会导致内存利用不足（因为可能会分配一个更大的块）或是分配的失败（如果已经没有可选的块存在了）。
</p><p>另外，这个算法允许一次内存分配“钉”住另一个上（？），来阻止glibc将释放的内存返回给系统。想像一下有两个内存块，块A和块B已经被分配了。块A正好出来分隔点的位置，而B正好在A的下方。即使程序释放了B，glibc仍然不能调整分隔点直到A也被释放为止。在这中方法中，一个常驻的内存块可以锁死其它的块，使它们不能被返还给系统。
</p><p>不过这也不是一个大问题，因为glibc并不是一直在试图将空间返回给系统*。通常来说堆并不会因为每次的释放而缩小。glibc会维护释放的内存以供之后的分配使用。只有当堆明显的大于需要分配的内存时glibc才会减小数据段的大小。然而，只要出现一次大的分配，这样的行为就会被阻止。
</p>
<pre>*glibc还采用一种比这种简单的分配策略更先进的分配算法，称为arena算法
</pre>
<p>因而，对于需求大的分配，glibc并不使用堆，而是创建一个匿名内存映射来满足要求。匿名内存映射类似于第四章中讲到的基于文件的映射，除了它没有背后支持的文件，因此称之为匿名内存映射。一个匿名内存映射只是一块已经用0初始化的大的内存块供用户使用。可以把它想成一个单独分配的单独的栈。由于这是在堆的外部分配的，因此不会产生内存碎片。
</p><p>通过匿名内存映射来分配有以下几个优点：
</p><p>•没有碎片问题。当程序不再需要这个匿名内存映射时，就将映射解除，这块内存可以立刻返还给系统。
</p><p>•匿名存储映射的大小的是可调整的，而且可以像普通的映射一样接受建议（？）（请见第四章）。
</p><p>•每次分配都存在于单独不同的内存映射中，因此不需要管理全局的堆。
</p><p>使用匿名映射与堆比起来也有两个缺点：
</p><p>•每个内存映射的大小都是系统页大小的整数倍。因此，大小上不是页大小整数倍的分配将造成浪费松散的空间。对于大小较小的分配来说，松散空间的浪费是更加显著的，因为相对于使用的空间，浪费的空间将更大。
</p><p>•创造一个新的内存映射将比从堆中返回内存更加复杂，因为它会涉及到内核中断的问题。而且分配的空间越小，这样的问题也越明显。
</p><p>根据优缺点来判断，glibc的malloc（）使用数据段来满足小的分配，而匿名内存映射则用来满足大的分配。两者间的界线是可调的（请参阅这章稍后的高级内存分配部分）并会随着glibc的改变而有所变化。目前的分界是128KB，即比128KB小的在堆中分配，而大的则用匿名内存映射进行分配。
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../c/h/a/Chapter8C_4f9d.html" title="Chapter8C">编辑</a>]</div><a name=".E5.88.9B.E5.BB.BA.E5.8C.BF.E5.90.8D.E6.98.A0.E5.B0.84"></a><h3>创建匿名映射</h3>
<p>或许你为了一次特别的分配想要使用一个内存映射而不是堆，又或者你正在写自己的内存分配系统，想要人工地创建自己的匿名内存映射，不管怎么样，Linux都将让它变得非常简单。回忆一下第四章用mmap（）函数来创建内存映射，而用munmap（）来销毁：
</p>
<pre>#include &lt;sys/mman.h&gt;
void * mmap (void *start, size_t length, int prot, int flags, int fd, off_t offset);
int munmap (void *start, size_t length);
</pre>
<p>事实上，创建一个匿名内存映射比创建一个以文件为背景的映射更加简单，因为不需要进行文件的打开和管理。两者最基本的区别在于一个标记位的存在，如果这个标记位标记了，那么就是匿名映射，让我们来看一个例子：
</p>
<pre>void *p;
p = mmap (NULL, /* do not care where */
          512 * 1024, /* 512 KB */
          PROT_READ | PROT_WRITE, /* read/write */
          MAP_ANONYMOUS | MAP_PRIVATE, /* anonymous, private */
          -1, /* fd (ignored) */
          0); /* offset (ignored) */
if (p == MAP_FAILED)
   perror ("mmap");
else
    /* 'p' points at 512 KB of anonymous memory... */
</pre>
<p>对于大多数的匿名映射来说，mmap（）的参数和这个相同，当然除了要传递程序员需要多大的空间，其他的参数大致如下：
</p><p>•第一个参数，start被设置为NULL，表示这个匿名映射可以在内核允许的任何地方开始。特别的，一个不是NULL的值在这里也是可以的，只要它是页对齐的，但是限制的可移植性。几乎没有程序会关心一个映射在内存的什么地方。
</p><p>•prot参数通常同时设置PROT_READ和PROT_WRITE位，来标记这个映射是否可读可写。如果一个空的映射不能进行读写，那么它就毫无用处。另一方面，我们很少希望从一个匿名映射中读取执行的代码，而且允许这样的行为将会导致一些安全漏洞。
</p><p>•flag参数设置MAP_ANONYMOUS位，来控制这个映射是匿名的，另外MAP_PRIVATE位标记了这个映射是否是私有的。
</p><p>•当MAP_ANOYMOUS设置时fd和偏移参数就将被忽略。而然，在一些老的系统会希望程序员将fd设置为1，因此如果要考虑到程序的可移植性，那么这将是一个好主意。
</p><p>通过匿名映射获得的内存看起来就和堆中的空间一样。通过匿名映射进行分配的一个好处是所有的页都已经用0进行了初始化。由于内核将通过写时拷贝将一个应用的匿名页全部映射到一个全是0的页上，因此这样的操作将是没有任何代价的。因此就没有必要通过memset（）来对返回的内存进行初始化。事实上这就是使用calloc（）比先使用malloc（）再使用memset（）来的好的原因之一。glibc知道匿名映射中已经全是零了， calloc()就能满足一个不明确要求全是0的映射(?)
</p><p>系统调用munmap()函数释放了一个匿名映射，将分配的空间返回给内核：
</p>
<pre>int ret;
/* all done with 'p', so give back the 512 KB mapping */
ret = munmap (p, 512 * 1024);
if (ret)
   perror ("munmap");
</pre>
<p><a href="../../../%E7%88%AA/%E5%AD%90/./Image%7E%E7%88%AA%E5%AD%90.JPG_2b15.html" class="image" title="Image:爪子.JPG"><img src="../../../../upload/8/86/%E7%88%AA%E5%AD%90.JPG" alt="Image:爪子.JPG" width="103" height="101" longdesc="../../../%E7%88%AA/%E5%AD%90/./Image%7E%E7%88%AA%E5%AD%90.JPG_2b15.html" /></a>想要更好的了解mmap（）munmap（）以及映射，请参阅第四章。
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../c/h/a/Chapter8C_4f9d.html" title="Chapter8C">编辑</a>]</div><a name=".E6.98.A0.E5.B0.84.E5.88.B0.2Fdev.2Fzero"></a><h3>映射到/dev/zero</h3>
<p>其它的Unix系统，比如说BSD，没有MAP_ANONYMOUS的标记位。它们通过另外一种非常简单的方式在解决这个问题，就是映射到一个特别的设备，/dev/zero。这个设备文件提供了和匿名内存相同的意义。一个映射包含了全是0的写时拷贝页。因此这个举动和匿名内存是一样的。
</p><p>Linux同样有/dev/zero这个设备，而且可以映射到这个文件上以获得用0初始化的内存。事实上，在引入MAP_ANONYMOUS之前，Linux的程序员们就使用这种方法。为了向旧版本的Linux提供向下兼容，又或者为了移植到其它Unix系统上，开发者们仍然在创建匿名映射的时候将它们映射到/dev/zero上。这和映射到其它文件上是不一样的：
</p>
<pre>void *p;
int fd;
/* open /dev/zero for reading and writing */
fd = open ("/dev/zero", O_RDWR);
if (fd &lt; 0) {
            perror ("open");
            return -1;
}
/* map [0,page size) of /dev/zero */
p = mmap (NULL,                   /* do not care where */
          getpagesize ( ),        /* map one page */
          PROT_READ | PROT_WRITE, /* map read/write */
</pre>
<p>	   MAP_PRIVATE,            /* private mapping */
	   fd,                     /* map /dev/zero */
	   0);                     /* no offset */
</p>
<pre>if (p == MAP_FAILED) {
       perror ("mmap");
       if (close (fd))
           perror ("close");
       return -1;
}
/* close /dev/zero, no longer needed */
if (close (fd))
   perror ("close");
/* 'p' points at one page of memory, use it... */
</pre>
<p>当然用这种方法的到的内存映射也使用mummap()来解除映射的。
</p><p>然而这种方法去有额外的系统调用开销：打开和关闭设备文件。因此匿名内存是一种更有效的方法。
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../c/h/a/Chapter8C_4f9d.html" title="Chapter8C">编辑</a>]</div><a name=".E9.AB.98.E7.BA.A7.E5.AD.98.E5.82.A8.E5.99.A8.E5.88.86.E9.85.8D"></a><h2>高级存储器分配</h2>
<p>这章中介绍的很多分配函数都是有限制的，通过程序员们改变内核参数来进行控制。为此，可以使用mallopt()函数：
</p>
<pre>#include &lt;malloc.h&gt;
int mallopt (int param, int value);
</pre>
<p>调用mallopt()会将内存管理相关的参数值改为patam指定的值。调用成功会返回一个非零的数，如果失败就返回0.需要指出的是mallopt()不会设置errno。一般来说它都会正常返回，所以不要对能从返回值中获得什么抱太大的希望。
</p><p>目前Linux支持param的六个值，它们都在&lt;malloc.h&gt;中进行了定义：
</p><p>M_CHECK_ACTION：变量MALLOC_CHECK_environment的值（将在下一节中做介绍）
</p><p>M_MMAP_MAX：系统可以满足动态内存申请的最大映射数。当达到这个限制时，分配就只能在数据段中进行，直到其中一个映射被释放。若该值为0，则用匿名映射来作为动态分配基础的行为将被禁止。
</p><p>M_MMAP_THRESHOLD：通过匿名映射而不是在数据段中分配可得到的最大空间（以字节计）。需要注意的是，那些要求空间比这个阈值小的分配也可能通过匿名映射来进行。若该值为0，则允许用匿名映射来进行任何分配，有效的禁止了用数据段来进行动态内存分配。
</p><p>M_MXFAST：fast bin的最大大小。Fast bin是在堆中的一块特殊的内存，它不会和邻近的内存结合，也永远不会返回给系统。它以增加碎片为代价进行超快速的分配。该值为0则禁止fast bin的使用。
</p><p>M_TOP_PAD：调整数据段时使用的填充（？）大小（字节计）。当glibc通过brk()来增加数据段的大小时，它可能申请更多的内存，希望减少未来使用brk()的可能。同样的，当glibc缩小数据段大小时，它会保存额外的一部分内存，返回给系统较少的内存。这些额外的空间就是填充（？）。该值为0则禁止填充的使用。
</p><p>M_TRIM_THRESHOLD：在数据段顶部允许释放的最小内存（字节计）。如果释放的空间比这个阈值小，glibc就会调用brk()来将剩下的部分返回给内核。
</p><p>XPG标准对于mallopt()的定义更加宽松，它还定义了另外三个参数：M_GRAIN，M_KEEP和M_NLBLKS。Linux也定义了这三个参数，不过将它们都设为了无效。参看表8-1。表中列出了全部的参数以及它们的缺省值和变化范围。
</p>
<table border="1" align="middle">
<caption> <b>表8-1：mallopt()的参数</b>
</caption><tr>
<td>参数</td><td>来源</td><td>缺省值</td><td>有效范围</td><td>特殊值来源
</td></tr>
<tr>
<td>M_CHECK_ACTION</td><td>Linux特有</td><td>0</td><td>0-2</td><td>
</td></tr>
<tr>
<td>M_GRAIN</td><td>XPG标准</td><td>Linux不支持</td><td>&gt;=0</td><td>
</td></tr>
<tr>
<td>M_KEEP</td><td>XPG标准</td><td>Linux不支持</td><td>&gt;=0</td><td>
</td></tr>
<tr>
<td>M_MMAP_MAX</td><td>Linux特有</td><td>64*1024</td><td>&gt;=0</td><td>0禁用mmap()
</td></tr>
<tr>
<td>M_MMAP_THRESHOLD</td><td>Linux特有</td><td>128*1024</td><td>&gt;=0</td><td>0禁用堆
</td></tr>
<tr>
<td>M_MXFAST</td><td>XPG标准</td><td>64</td><td>0-80</td><td>0禁用fast bin
</td></tr>
<tr>
<td>M_NLBLK</td><td>XPG标准</td><td>Linux不支持</td><td>&gt;=0</td><td>
</td></tr>
<tr>
<td>M_TOP_PAD</td><td>Linux特有</td><td>0</td><td>&gt;=0</td><td>0禁用填充
</td></tr></table>
<p>程序在第一次调用malloc()或是其它内存分配函数前应该先使用mallopt()，使用是非常简单的：
</p>
<pre>int ret;
/* use mmap( ) for all allocations over 64 KB */
ret = mallopt (M_MMAP_THRESHOLD, 64 * 1024);
if (!ret)
  fprintf (stderr, "mallopt failed!\n");
</pre>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../c/h/a/Chapter8C_4f9d.html" title="Chapter8C">编辑</a>]</div><a name=".E4.BD.BF.E7.94.A8malloc_usable_size.28.29.E5.92.8Cmalloc_trim.28.29.E8.BF.9B.E8.A1.8C.E5.BE.AE.E8.B0.83"></a><h3>使用malloc_usable_size()和malloc_trim()进行微调</h3>
<p>Linux提供了许多用来控制glibc内存分配系统的底层函数。其中一个这样的函数允许程序查询一次分配中有多少可用的空间：
</p>
<pre>#include &lt;malloc.h&gt;
size_t malloc_usable_size (void *ptr);
</pre>
<p>一次对malloc_usable_size的成功调用返回ptr指向的内存块中可用的大小。因为glibc可能会在一个已存在的块或匿名映射上来集中分配以调整具体分配的大小（？），实际中可用的空间可能比申请的要大。当然分配到的空间永远都不会比申请的要小。这里有个例子：
</p>
<pre>size_t len = 21;
size_t size;
char *buf;
buf = malloc (len);
if (!buf) {
          perror ("malloc");
          return -1;
}
size = malloc_usable_size (buf);
/* we can actually use 'size' bytes of 'buf'... */
</pre>
<p>第二个这样的函数允许程序强制让glibc立刻将空闲的空间全部返回的内核：
</p>
<pre>#include &lt;malloc.h&gt;
int malloc_trim (size_t padding);
</pre>
<p>一次对malloc_trim的成功调用会将数据段尽可能的缩小，除去会保留下来的一些填充字节。然后它会返回1。如果调用失败，返回0。一般来说，当空余的空间达到M_TRIM_THRESHOLD个字节时，glibc会自动缩小数据段。它会用M_TOP_PAD进行填充。
</p><p>你不应该将这两个函数用于调试和教学以外的其它地方。它们是不可移植的，而且会将glibc内存分配系统的一些底层细节暴露给你的程序。
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../c/h/a/Chapter8C_4f9d.html" title="Chapter8C">编辑</a>]</div><a name=".E5.AD.98.E5.82.A8.E5.99.A8.E5.88.86.E9.85.8D.E8.B0.83.E8.AF.95"></a><h2>存储器分配调试</h2>
<p>程序可以通过设置环境变量MALLOC_CHECK_来激活内存子系统的高级调试功能。这个额外的调试检查是以降低内存分配的效率为代价的，然而这个开销在开发应用的调试阶段却是非常值得的。
</p><p>由于一个环境变量控制了调试，因此就没有必要重新编译你的程序。比如说，你可以使用一个非常简单的命令，就像这样：
</p>
<pre>$MALLOC_CHECK_=1./rudder
</pre>
<p>如果MALLLOC_CHECK_为0，那么内存子系统就会忽略任何错误。如果它是1，那么调试信息就会被传送给stderr。如果它是2，那么abort()会立刻终结程序。由于MALLOC_CHECK_改变了程序的行为，setuid程序会忽略这个变量。
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../c/h/a/Chapter8C_4f9d.html" title="Chapter8C">编辑</a>]</div><a name=".E8.8E.B7.E5.8F.96.E7.BB.9F.E8.AE.A1.E8.B5.84.E6.96.99"></a><h3>获取统计资料</h3>
<p>Linux提供了mallinfo()函数来获取内存分配相关的统计资料：
</p>
<pre>#include &lt;malloc.h&gt;
struct mallinfo mallinfo (void);
</pre>
<p>mallinfo()以一个mallinfo结构体的形式返回。这个结构体是通过值返回的，而不是指针。它的内容同样在&lt;malloc.h&gt;中进行了定义：
</p>
<pre>/* all sizes in bytes */
struct mallinfo {
    int arena;    /* size of data segment used by malloc */
    int ordblks; /* number of free chunks */
    int smblks;   /* number of fast bins */
    int hblks;    /* number of anonymous mappings */
    int hblkhd;   /* size of anonymous mappings */
    int usmblks;  /* maximum total allocated size */
    int fsmblks;  /* size of available fast bins */
    int uordblks; /* size of total allocated space */
    int fordblks; /* size of available chunks */
    int keepcost; /* size of trimmable space */
};
</pre>
<p>这里有一个使用的例子：
</p>
<pre>struct mallinfo m;
m = mallinfo ( );
printf ("free chunks: %d\n", m.ordblks);
</pre>
<p>同时Linux还提供了malloc_stats()函数，它会将内存相关的信息传送给stderr:
</p>
<pre>#include &lt;malloc.h&gt;
void malloc_stats (void);
</pre>
<p>在一个内存密集型的程序中调用malloc_stats()会产生一些非常大的数：
</p>
<pre>Arena 0:
system bytes     = 865939456
in use bytes     = 851988200
Total (incl. mmap):
system bytes     = 3216519168
in use bytes     = 3202567912
max mmap regions =      65536
max mmap bytes   = 2350579712
</pre>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../c/h/a/Chapter8C_4f9d.html" title="Chapter8C">编辑</a>]</div><a name=".E5.9F.BA.E4.BA.8E.E6.A0.88.E7.9A.84.E5.88.86.E9.85.8D"></a><h2>基于栈的分配</h2>
<p>到目前为止，我们学过的动态内存分配的机制都是使用堆或是匿名映射来获得动态内存的。我们很自然的想到使用它们因为堆和匿名映射本身就是动态的。另外一个在程序地址空间中常用的结构，栈，是用来存放程序的局部变量的。
</p><p>然而，说程序员不能使用栈来进行动态内存分配也是没有理由的。只要分配使得栈不溢出，那么这样一个方法就应该既简单，又有效。想要在栈中进行动态内存分配，使用alloca()这个系统调用：
</p>
<pre>#include &lt;alloca.h&gt;
void * alloca (size_t size);
</pre>
<p>如果调用成功，alloca()会返回一个指向size字节大小空间的指针。这块内存是在栈中的，而且会在调用函数返回时自动释放空间。某些执行会在失败时返回NULL，但是大部分时候alloca()都不可能失败，或是不可能报告失败。失败就表明出现的栈溢出。
</p><p>其它大部分的使用都和malloc()相同，但你不需要（事实上，决不能）释放分配到的内存。这里有个例子，一个函数打开了一个给定的位于系统配置目录（可能是/etc）下的文件，但可能在编译时位置发生变化。这个函数只能开辟一个新的缓冲区，将系统的配置目录拷贝到这个缓冲区中，然后将这块缓冲区与给定的文件名相连。
</p>
<pre>int open_sysconf (const char *file, int flags, int mode)
{
    const char *etc; = SYSCONF_DIR; /* "/etc/" */
    char *name;
    name = alloca (strlen (etc) + strlen (file) + 1);
    strcpy (name, etc);
    strcat (name, file);
    return open (name, flags, mode);
}
</pre>
<p>返回时，通过alloca()分配的内存会随着栈指针移回调用函数而自动释放。这意味着你不能在调用alloca()的函数返回后继续使用这块内存。然而，由于你不需要用过调用free()做任何内存的清理，产生的代码会变得更简洁。下面是一个通过malloc()实现的函数：
</p>
<pre>int open_sysconf (const char *file, int flags, int mode)
{
    const char *etc = SYSCONF_DIR; /* "/etc/" */
    char *name;
    int fd;
    name = malloc (strlen (etc) + strlen (file) + 1);
    if (!name) {
          perror ("malloc");
          return -1;
    }
    strcpy (name, etc);
    strcat (name, file);
    fd = open (name, flags, mode);
    free (name);
    return fd;
}
</pre>
<p>需要注意的是不能将通过alloca()分配到的内存作为指针传递给函数调用,因为这块内存会存放在用来保存函数参数的栈空间中。举个例子，像这样的调用就是绝对不允许的：
</p>
<pre>/* DO NOT DO THIS! */
ret = foo (x, alloca (10));
</pre>
<p>alloca()函数有着一个非常多变的历史。在许多系统中，它的表现非常差，甚至会出现一些没定义的行为。在那些栈的大小固定而且比较小的系统中，使用alloca()很容易造成栈的溢出，从而终止你的程序。而在别的一些系统中，alloca（）根本就不存在。由于经常出错和不稳定，人们对alloca()总是没有一个好的印象。
</p><p>因此，如果你的程序需要保持可移植，那么你应该避免使用alloca()。然而在Linux系统上，alloca()却是一个非常好用但没有被人们认识到的工具。在许多体系结构中，它的表现都异常出色，通过alloca()分配一块空间做的只是增加栈指针的位置，它甚至比malloc()更加好用。对于Linux系统中，一些小量分配的代码来说，alloca()可以获得非常不错的性能。
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../c/h/a/Chapter8C_4f9d.html" title="Chapter8C">编辑</a>]</div><a name=".E6.A0.88.E4.B8.AD.E7.9A.84.E4.B8.B2.E6.8B.B7.E8.B4.9D"></a><h3>栈中的串拷贝</h3>
<p>一个alloca()常见的用法是用来临时复制一个字符串。比如：
</p>
<pre>/* we want to duplicate 'song' */
char *dup;
dup = alloca (strlen (song) + 1);
strcpy (dup, song);
/* manipulate 'dup'... */
return; /* 'dup' is automatically freed */
</pre>
<p>由于这样的操作使用频率很高，以及由alloca()带来的高效，Linux提供了strdup()的变体来将指定的字符串拷贝到栈中：
</p>
<pre>#define _GNU_SOURCE
#include &lt;string.h&gt;
char * strdupa (const char *s);
char * strndupa (const char *s, size_t n);
</pre>
<p>调用strdupa()将返回一个s的拷贝。strndupa()将拷贝s中的n个字符。如果s比n长，那么只会拷贝前n个字符，函数会自动添加一些空字符。这些函数提供和alloca()一样的好处。当调用函数返回时，复制的串会自动释放。
</p><p>POSIX并没有定义alloca()，strdupa()或是strndupa()这些函数，它们在其它一些操作系统中的口碑也很差。所以如果需要考虑移植问题，那这些函数都不应该被使用。然而在Linux上，alloca()以及由它衍生的一些函数却表现的非常好，可以带来性能上的提升，通过简单的移动栈指针来代替其它一些复杂动态分配内存的方式。
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../c/h/a/Chapter8C_4f9d.html" title="Chapter8C">编辑</a>]</div><a name=".E5.8F.AF.E5.8F.98.E9.95.BF.E6.95.B0.E7.BB.84"></a><h3>可变长数组</h3>
<p>C99引入了变长数组（VLAs），这类数组的大小是在运行时确定的，而不是在编译的时候。在这之前，GNUC已经支持变长数组了，但是现在C99将其标准化，因此对于变长数组的使用得到了很大的鼓励。VLAs并不像alloca()那样动态分配内存。它们的使用就像你所希望的那样：
</p>
<pre>for (i = 0; i &lt; n; ++i) {
       char foo[i + 1];
       /* use 'foo'... */
}	
</pre>
<p>在这个程序片段中，foo是一个大小为i+1的可变数组。在每次循环中，foo都被动态的创建，并在这轮循环结束前自动释放。如果我们使用alloca()来代替VLA，那么内存空间将直到函数返回时才会被释放。使用VLA保证在每轮循环过后空间都内被释放。因此，使用VLA最多消耗n个字节，而alloca()则将消耗n*(n+1)/2个字节。
</p><p>使用变长数组，我们可以像下面这样重写open_sysconf():
</p>
<pre>int open_sysconf (const char *file, int flags, int mode)
{
    const char *etc; = SYSCONF_DIR; /* "/etc/" */
    char name[strlen (etc) + strlen (file) + 1];
    strcpy (name, etc);
    strcat (name, file);
    return open (name, flags, mode);
}
</pre>
<p>alloca()和变长数组最大的区别在于通过前者获得的内存在函数执行过程中始终存在，而通过后者得到的则只会保留到下轮循环，这一般都在函数返回之前。这样的方式有好有坏。在for循环中，我们希望每次循环都内释放空间以在没有任何副作用的情况下减小内存的开销（我们不会希望有多余的内存始终被占用着）。然而，如果处于某种原因我们希望这块空间能保留到下一轮的循环中，那么使用alloca()显然是更加合理的。
</p><p>在一个函数中混合使用alloca()和变长数组会引发一些奇特的行为。因此为了安全起见在一个固定的函数中只应使用其中之一。
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../c/h/a/Chapter8C_4f9d.html" title="Chapter8C">编辑</a>]</div><a name=".E9.80.89.E6.8B.A9.E4.B8.80.E7.A7.8D.E5.86.85.E5.AD.98.E5.88.86.E9.85.8D.E6.9C.BA.E5.88.B6"></a><h2>选择一种内存分配机制</h2>
<p>这章中讨论了很多种内存分配的方式，这可能使得程序员们迷惑在一个具体的问题中到底该使用哪一种。在大部分的情况下malloc()总是最好的选择。然而在某些情况下其它的一些方式会更好一些。表8-2总结了一些选择内存分配机理的原则：
</p>
<table border="1" align="middle">
<caption> <b>表8-2 Linux中的内存分配方式</b>
</caption><tr>
<td>分配方式</td><td>优点</td><td>缺点
</td></tr>
<tr>
<td>malloc()</td><td>简单，方便，最常用</td><td>返回的内存为用零初始化
</td></tr>
<tr>
<td>calloc()</td><td>使数组分配变得容易，用0初始化了内存</td><td>在分配非数组空间时显得较复杂
</td></tr>
<tr>
<td>realloc()</td><td>调整已分配的空间大小</td><td>只能用来调整已分配空间的大小
</td></tr>
<tr>
<td>brk()和sbrk()</td><td>允许对堆进行深入控制</td><td>对大多数使用者来说过于底层
</td></tr>
<tr>
<td>匿名内存映射</td><td>使用简单，可共享，允许开发者调整保护等级并提供建议，适合大空间的分配</td><td>不适合小分配。最优时malloc()会自动使用匿名内存映射
</td></tr>
<tr>
<td>posix_memalign()</td><td>分配的内存按照任何合理的大小进行对齐</td><td>相对较新，因此可移植性是问题当对齐问题不是非常重要时显得无用
</td></tr>
<tr>
<td>memalign()和valloc()</td><td>相比posix_memalign()在其它的Unix系统上更常见</td><td>不是POSIX标准，对对齐的控制能力不如posix_memalign()
</td></tr>
<tr>
<td>alloca()</td><td>最快的分配方式，不需要知道确切的大小，对于小的分配非常适合</td><td>不能返回错误信息，不适合大分配，在一些Unix系统上表现不好
</td></tr>
<tr>
<td>变长数组</td><td>与alloca()类似，但在退出此层循环是释放空间，而不是函数返回时</td><td>只能用来分配数组，在一些情况下alloca()的释放方式更加适用，在其它Unix系统中没有alloca()常见
</td></tr></table>
<p>最后我们不能忘记静态分配和动态分配的选择。在栈中分配临时变量，在堆中分配全局变量总是最简单的，而且不需要程序员们控制指针以及释放内存。
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../c/h/a/Chapter8C_4f9d.html" title="Chapter8C">编辑</a>]</div><a name=".E5.AD.98.E5.82.A8.E5.99.A8.E6.93.8D.E4.BD.9C"></a><h2>存储器操作</h2>
<p>C语言提供了很多函数用来对分配到的空间进行操作。这些函数的功能和字符串操作函数如strcmp()以及strcpy()类似，但是它们需要依赖于用户提供块的大小而不是假定字符串是以\0结尾的。需要注意的是这些函数都不会返回错误信息。因此防止错误需要靠程序员。如果你将错误的内存区域作为参数传入，那么毫无疑问，你将获得一个段错误。
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../c/h/a/Chapter8C_4f9d.html" title="Chapter8C">编辑</a>]</div><a name=".E5.AD.97.E8.8A.82.E8.AE.BE.E7.BD.AE"></a><h3>字节设置</h3>
<p>在众多内存操作的函数中，最常用也是最简单的就是memset():
</p>
<pre>#include &lt;string.h&gt;
void * memset (void *s, int c, size_t n);
</pre>
<p>调用memset()将把从s指向区域开始的n个字节设置为c，并返回s。它经常被用来将一块内存清零：
</p>
<pre>/* zero out [s,s+256) */
memset (s, '\0', 256);
</pre>
<p>bzero()是早期由BSD引入的相同功能的函数。新的代码应该使用memset()，但是Linux处于向下兼容和移植的考虑也提供了bzero()：
</p>
<pre>#include &lt;strings.h&gt;
void bzero (void *s, size_t n);
</pre>
<p>下面的调用和之前使用memset()的功能是一样的：
</p>
<pre>bzero (s, 256);
</pre>
<p>需要注意的是bzero()和其它b开头的函数都包括在头文件&lt;strings.h&gt;而不是&lt;string.h&gt;中。
</p><p>如果你使用calloc()分配内存那就坚决不要使用memset()了。不要先用malloc()分配了内存，再马上使用memset()来进行清零。虽然结果可能是一样的，但是将这两部变成一个直接返回已经清零了的空间calloc()会更好。好处在于你不仅少了一次函数调用，而且calloc()是直接从内存中获取已经清零了的内存，这显然比人工的将每个字节清零要高效。
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../c/h/a/Chapter8C_4f9d.html" title="Chapter8C">编辑</a>]</div><a name=".E5.AD.97.E8.8A.82.E6.AF.94.E8.BE.83"></a><h3>字节比较</h3>
<p>与strcmp()类似，memcmp()比较两块内存是否相等：
</p>
<pre>#include &lt;string.h&gt;
int memcmp (const void *s1, const void *s2, size_t n);
</pre>
<p>调用memcmp()比较s1和s2的头n个字节，如果两块内存相同就返回0，如果s1小于s2就返回一个小于0的数，反之则返回大于0的数。
</p><p>BSD同样提供了自己具有类似功能的接口：
</p>
<pre>#include &lt;strings.h&gt;
int bcmp (const void *s1, const void *s2, size_t n);
</pre>
<p>调用bcmp()比较s1和s2的头n个字节，如果两块内存相同就返回0，如果不相同则返回一个非零的值。
</p><p>由于结构体的自动补齐（具体请参见这章中的“其它对齐问题”），通过memcmp()或是bcmp()来比较两个结构体是否相等时不可靠的。两个相同的结构体可能由于含有不同的为初始化的补齐块而被判为不相同。因此，像下面这样的代码是不保险的：
</p>
<pre>int compare_dinghies (struct dinghy *a, struct dinghy *b)
{
return memcmp (a, b, sizeof (struct dinghy));
}
</pre>
<p>程序员们如果想要比较结构体，只能一个一个比较结构体中的每一个元素。下面这个方法实现的比较的最优化，但它的工作量当然会比不安全的memcmp()要大：
</p>
<pre>/* are two dinghies identical? */
int compare_dinghies (struct dinghy *a, struct dinghy *b)
{
   int ret;
   if (a-&gt;nr_oars &lt; b-&gt;nr_oars)
      return -1;
   if (a-&gt;nr_oars &gt; b-&gt;nr_oars)
      return 1;
   ret = strcmp (a-&gt;boat_name, b-&gt;boat_name);
   if (ret)
      return ret;
   /* and so on, for each member... */
}
</pre>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../c/h/a/Chapter8C_4f9d.html" title="Chapter8C">编辑</a>]</div><a name=".E5.AD.97.E8.8A.82.E7.A7.BB.E5.8A.A8"></a><h3>字节移动</h3>
<p>memmove()将src指向的头n个字节拷贝到des指向的位置，并返回des：
</p>
<pre>#include &lt;string.h&gt;
void * memmove (void *dst, const void *src, size_t n);
</pre>
<p>BSD标准中相同功能的函数为：
</p>
<pre>#include &lt;strings.h&gt;
void bcopy (const void *src, void *dst, size_t n);
</pre>
<p>需要指出的是尽管两个函数的参数相同，但是它们的位置是不一样的，在bcopy()中前两个字节的位置是反的。
bcopy()和memmove()都能安全的处理内存区域重叠的问题（也就是说，dst的一部分在src中）。比如说，这就允许一块内存的字节进行上移或下移。虽然这种情况很少见，但是程序员应该知道有这么一回事。C标准定义了memmove()的一个变体，它不支持内存区域的重叠，但是它潜在的更快：
</p>
<pre>#include &lt;string.h&gt;
void * memcpy (void *dst, const void *src, size_t n);
</pre>
<p>这个函数的更能和memmove()类似，除了dst和src不允许重叠。如果它们重叠了，那么函数的结构是没有定义的。
</p><p>另外一个安全的拷贝函数是memccopy()：
</p>
<pre>#include &lt;string.h&gt;
void * memccpy (void *dst, const void *src, int c, size_t n);
</pre>
<p>memccpy()和memcpy()类似，除了当它发现字节c在src指向的前n个字节中时会停止拷贝以外。它返回指向dst中c后一个字节的指针，或者当没有找到c时返回NULL。
</p><p>最后我们可以使用mempcpy()来跨过拷贝的内存：
</p>
<pre>#define _GNU_SOURCE
#include &lt;string.h&gt;
void * mempcpy (void *dst, const void *src, size_t n);
</pre>
<p>mempcpy()的功能和memcpy()相同，除了它返回的是指向拷贝的最后那个字节的下一个字节的指针。当在内存中有连续的一系列数据需要拷贝时它是很有用的。但是它并没有太大的进步因为返回的指针只是dst+n而已。这个函数是GNU中特有的。
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../c/h/a/Chapter8C_4f9d.html" title="Chapter8C">编辑</a>]</div><a name=".E5.AD.97.E8.8A.82.E6.90.9C.E7.B4.A2"></a><h3>字节搜索</h3>
<p>函数memchr()和memrchr()在一块内存中定位一个指定的字节：
</p>
<pre>#include &lt;string.h&gt;
void * memchr (const void *s, int c, size_t n);
</pre>
<p>函数memchr()从s指向的区域开始搜索n个字节以寻找c，c会被转换成一个unsigned char(?)
</p>
<pre>#define _GNU_SOURCE
#include &lt;string.h&gt;
void * memrchr (const void *s, int c, size_t n);
</pre>
<p>调用返回指向第一个c的指针，如果没有找到c则返回NULL
</p><p>memrchr()与memchr()类似，除了它是从s指向的内存开始倒着搜索n个字节意外。和memchr()不同，memrchr()是GNU的衍生，而不是C语言的一部分。
</p><p>对于更加复杂的搜索任务，函数memmem()在一块内存中搜索任意一串字节：
</p>
<pre>#define _GNU_SOURCE
#include &lt;string.h&gt;
void * memmem (const void *haystack,
               size_t haystacklen, 
               const void *needle,
               size_t needlelen);
</pre>
<p>函数mememe()返回从haystack指向的内存开始haystacklen个字节中第一次出现长度为needlelen的needle的字串。如果没找到则返回NULL，这个函数同样是GNU衍生。
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../c/h/a/Chapter8C_4f9d.html" title="Chapter8C">编辑</a>]</div><a name=".E5.AD.97.E8.8A.82.E7.BC.96.E7.A0.81"></a><h3>字节编码</h3>
<p>Linux的C库提供了为数据进行简单编码的接口：
</p>
<pre>#define _GNU_SOURCE
#include &lt;string.h&gt;
void * memfrob (void *s, size_t n);
</pre>
<p>memfrob()函数对s指向的位置开始的n个字节，每个都与42进行异或操作来对数据进行加密。函数返回s。再次对相同的区域调用memfrob()可以将其转换回来。因此下面这行程序对于secret没有进行什么实质性的操作：
</p>
<pre>memfrob (memfrob (secret, len), len);
</pre>
<p>这个函数绝对不是一个合适的（甚至是更差的）加密的替换；它的使用仅限于对于字符串的简单处理。它是GNU标准的。
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../c/h/a/Chapter8C_4f9d.html" title="Chapter8C">编辑</a>]</div><a name=".E5.AD.98.E5.82.A8.E5.99.A8.E9.94.81.E5.AE.9A"></a><h2>存储器锁定</h2>
<p>Linux实现了页面的调度，也就是当需要时将页从硬盘中调入内存，当不再需要时再移出。由于硬盘上的交换空间可以提供一个拥有近乎无限内存空间的假象，这使得系统中进程的虚拟地址空间与实际的物理内存大小没有直接的关系。
</p><p>页的交换由系统显性进行，应用不需要去关心（甚至不需要知道）Linux内核的页调度行为。然而，在两种情况下应用希望可以干涉系统的页调度：
</p><p><i>确定性</i>
</p><p>对于那些有严格时间限制的程序可能会要求自己来决定页的调度行为。如果一些内存访问导致了页错误会引发开销硬盘I/O操作，从而使得应用程序运行超时。通过确保需要的页始终在内存中而且不会 paged to disk，应用可以保证内存访问不会导致页错误，从而保证了连续性，确定性和高效的行为。
</p><p><i>安全性</i>
</p><p>如果一些私有的信息被保存在内存中，而这些信息可能最终经加密就被换页并保存到了硬盘里。比如，如果一个用户的私有密码是正常的经过加密保存在硬盘里的，这个密码解密过后的拷贝可能就在交换空间中。在一个需要高度安全的环境中，这样的行为是不能接受的。对于那些这可能成为问题的应用来说，它们可能要求含有这样信息的页始终处于内存中。
</p><p>当然，改变内核的行为可能会对系统整体的表现产生负面的影响。一个应用的决定和安全可能会提高，但是当它的页被锁在了内存中，那另一个应用的页就只能被换出内存。正如我们所相信的，内核总是将最优的页换出，也就是那些在未来最优可能被访问的页。因此如果你改变的它的行为，那么它就只能将一个次优的页换出了。
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../c/h/a/Chapter8C_4f9d.html" title="Chapter8C">编辑</a>]</div><a name=".E9.94.81.E5.AE.9A.E9.83.A8.E5.88.86.E5.9C.B0.E5.9D.80.E7.A9.BA.E9.97.B4"></a><h3>锁定部分地址空间</h3>
<p>POSIX1003.1b-1993定义了两个接口用来将一个或多个页锁定在物理内存中，保证它们永远不会被换出内存。第一个用来锁定给定地址长度的函数是：
</p>
<pre>#include &lt;sys/mman.h&gt;
int mlock (const void *addr, size_t len);
</pre>
<p>调用mlock()后会将开始于addr，长度为len的虚拟内存锁定在物理内存中。如果调用成功返回0，否则返回-1并适当设置errno。
</p><p>一次成功的调用将包含[addr,addr+len)的物理页锁定在内存中。比如说，如果一个调用指定某一个字节，那么这个字节所在的整个页都将被锁定在内存中。POSIX标准规定addr应该页对齐。Linux并没有强调这个要求，需要时自动将addr向下调整到最近的页边缘。对于要求可移植到其它系统的程序需要保证addr是页对齐的。
</p><p>有效的errno信息包括：
</p><p>EINVAL：长度参数是负的。
</p><p>ENOMEM：函数尝试锁定多于RLIMIT_MEMLOCK限制的页(详见之后“锁定限制”部分)。
</p><p>EPERM:RLIMIT_MEMLOCK限制为0，但进程不具有CAO_IPC_LOCK功能（同样请见“锁定限制”部分）。
</p><p>一个子进程并不能通过fork()来继承锁定的内存。然而，由于Linux的写时保护行为，一个子进程的页会被有效的锁定在内存中直到子进程需要改写它们。
</p><p>下面这个例子，假设一个程序在内存中有一个加密的字符串。一个进程可以通过下面代码来锁定拥有这个字符串的页：
</p>
<pre>int ret;
/* lock 'secret' in memory */
ret = mlock (secret, strlen (secret));
if (ret)
   perror ("mlock");
</pre>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../c/h/a/Chapter8C_4f9d.html" title="Chapter8C">编辑</a>]</div><a name=".E9.94.81.E5.AE.9A.E5.85.A8.E9.83.A8.E5.9C.B0.E5.9D.80.E7.A9.BA.E9.97.B4"></a><h3>锁定全部地址空间</h3>
<p>如果一个进程想要将它的全部地址空间锁定在内存中，使用mlock()就不再合适了。POSIX定义了mlockall()函数来满足这个常见real-time(?)的需要：
</p>
<pre>#include &lt;sys/mman.h&gt;
int mlockall (int flags);
</pre>
<p>调用mlockall()后将当前进程的地址空间锁定在内存中。参数flags是下面两个变量的按位或。
</p><p>MCL_CURRENT 如果设置，这个变量会要求mlockall()将当前所有的映射页----栈，堆栈段，映射文件等等锁定在进程的地址空间。
</p><p>MCL_FUTRUE 如果设置，这个变量将要求mlockall()保证将来所有的映射页也被锁定在内存中。
</p><p>大部分应用会指定这两个变量按位或的值。
</p><p>调用成功，函数返回0。如果失败就会返回-1，并将errno设置为以下几种错误信息之一：
</p><p>EINVAL：参数flags为负。
</p><p>ENOMEM：函数尝试锁定多于RLIMIT_MEMLOCK限制的页(详见之后“锁定限制”部分)。
</p><p>EPERM:RLIMIT_MEMLOCK限制为0，但进程不具有CAO_IPC_LOCK功能（同样请见“锁定限制”部分）。
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../c/h/a/Chapter8C_4f9d.html" title="Chapter8C">编辑</a>]</div><a name=".E5.AD.98.E5.82.A8.E5.99.A8.E8.A7.A3.E9.94.81"></a><h3>存储器解锁</h3>
<p>POSIX标准提供了两个接口用来将页从内存中解锁，允许内核根据需要将页换出至硬盘中：
</p>
<pre>#include &lt;sys/mman.h&gt;
int munlock (const void *addr, size_t len);
int munlockall (void);
</pre>
<p>函数munlock()将从addr处开始长为len字节的页解锁。它的效果和mlock()相反。而munlockall()则和mlockall()效果相反。调用成功都将返回0，如果失败则返回-1，并将errno设置为一下错误信息之一：
</p><p>EINVAL：参数len不合法(仅在munlock()时)。
</p><p>ENOMEM：某些指定页无效。
</p><p>EPERM：RLIMIT_MEMLOCK限制为0，但进程不具有CAO_IPC_LOCK功能（同样请见“锁定限制”部分）。 
</p><p>内存锁定并不会重叠。因此调用一次munlock()或是munlockall()就能解锁一个锁定的页，无论这个页通过mlock()或是mlockall()锁定了多少次。
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../c/h/a/Chapter8C_4f9d.html" title="Chapter8C">编辑</a>]</div><a name=".E9.94.81.E5.AE.9A.E9.99.90.E5.88.B6"></a><h3>锁定限制</h3>
<p>由于锁定内存可能影响整个系统的性能，如太多的页被锁定了，内存分配就很有可能失败等，Linux给一个进程可以锁定多少内存进行了限制。
</p><p>拥有CAP_IPC_LOCK标签的进程可以将任意数量的页锁定在内存中。没有这个标签的内存只能锁定RLIMIT_MEMLOCK字节大小的页。这个限制默认为32KB，足够存储一两个必要的内容在内存中而不会影响整个系统的性能。（第六章讨论了资源限制，以及如何找到并修改这个值。）
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../c/h/a/Chapter8C_4f9d.html" title="Chapter8C">编辑</a>]</div><a name=".E5.88.A4.E6.96.AD.E4.B8.80.E4.B8.AA.E9.A1.B5.E6.98.AF.E5.90.A6.E5.9C.A8.E5.86.85.E5.AD.98.E4.B8.AD"></a><h3>判断一个页是否在内存中</h3>
<p>出于调试的需要，Linux提供了mincore()函数，可以用来确定一个给定范围内的内存是在物理内存中还是被交换到了硬盘中：
</p>
<pre>#include &lt;unistd.h&gt;
#include &lt;sys/mman.h&gt;
int mincore (void *start,
             size_t length,
             unsigned char *vec);
</pre>
<p>mincore()提供了一个向量还描绘调用时一个映射中的哪些页在内存中。函数通过vec返回这个向量，并用start描述页起始的地方（必须满足页对齐）以及长度length个字节（不需要页对齐）。vec中的每个字节对应提供范围中的一个页，第一个字节描述第一个页，以此类推。因此，vec必须足够大以存下至少（length-1+页大小）/页 大小个字节。如果这个页在内存中，则这个字节中的最低为是1，如是0则不在。其它的位暂时都未定义，为未来需要保留。
</p><p>调用成功函数返回0，如果发生错误则返回-1，并设置errno为以下错误信息之一：
</p><p>EAGAIN：内核资源不足无法实现该函数。
</p><p>EFAULT：参数vec指向一个无效的地址。
</p><p>EINVAL：参数start没有页对齐。
</p><p>ENOMEM：[address,address+1)包含不是文件映射（？）的部分。
</p><p>目前，这个系统调用只适用于通过MAP_SHARED生成的文件映射。这大大限制了这个函数的使用。
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../c/h/a/Chapter8C_4f9d.html" title="Chapter8C">编辑</a>]</div><a name=".E6.8A.95.E6.9C.BA.E6.80.A7.E5.AD.98.E5.82.A8.E5.88.86.E9.85.8D"></a><h2>投机性存储分配</h2>
<p>Linux提供了一种随机分配的策略。当一个进程需要向内核申请额外的内存，如扩大它的数据段或是创建新的内存映射，内核记录下这个需要但并不提供任何物理内存，直到进程需要在这块新申请的内存中进行写操作内核才将这个需要转变成物理内存。内核基于页到页的原则进行这个操作，同时也满足命令页（？）和写时拷贝。
</p><p>这样的行为有几个优点。首先，推迟（？）分配内存可以让内核推迟大部分的工作直到真正需要满足分配请求的最后一刻。第二，由于这些请求是按页满足的（？），只有实际使用中的物理内存需要消耗存储空间。最后请求的空间可以大大超过物理内存甚至交换空间的大小。最后这个特性称为过量分配。
</p>
<div class="editsection" style="float:right;margin-left:5px;">[<a href="../../../c/h/a/Chapter8C_4f9d.html" title="Chapter8C">编辑</a>]</div><a name=".E8.BF.87.E9.87.8F.E5.88.86.E9.85.8D.E5.92.8C.E5.86.85.E5.AD.98.E4.B8.8D.E8.B6.B3"></a><h3>过量分配和内存不足</h3>
<p>相比在申请时分配物理空间，在使用时才进行分配的过量分配允许系统运行更多更大的应用。如果没有过量分配，映射一个写时保护的2GB的文件需要内核另开设2GB的大小。而通过过量分配，映射一个2GB的文件只需要实际使用的页的大小的空间。相似的，没有过量分配，每次fork()都需要足够的空间来复制地址空间，即使是大量从来不需要的页。
</p><p>然而当所有进程试图申请的空间大于了系统所有的物理内存和交换空间会怎样呢？在这种情况下，一个或是更多的请求将失败。由于内核已经记录下了请求，而且申请的系统调用已经成功返回，当一个进程试图使用那块申请的内存时，内核唯一的方法就是结束一个过程，释放出可用的内存。
</p><p>当过量分配导致没有足够的内存来满足请求，我们就说发生了内存不足。在内存不足的情况下，内核会使用OOM killer来选出一个最值得终止的过程。为此，内核会试图寻找消耗了最多内存而最不重要的过程。
</p><p>内存不足的情况是很少见的，因此将过量分配放在第一位是十分有效的。然而可以肯定的是，这样的情况绝对是不受欢迎的，像这样不受控的用OOM killer来终结一个过程也是无法接受的。
</p><p>对于那些有这种情况的系统，内核允许用过文件/proc/sys/vm/overcommit_memory来禁止过量分配，同样也可以使用系统控制参数vm.overcommit_memory。
</p><p>这个参数的缺省值是0，表示内核对于那些需求较少的允许进行过量分配，而拒绝过大的分配请求。如果该值为1则将允许所有的过量分配。对于那些内存密集型的应用，比如那些用于科学领域的，趋向于申请比所需远远大的多的内存，这种情况下将该值设为1就是有意义的了。
</p><p>如果值是2则禁用过量分配，并且启用了了严格的accounting。在这种模式下，内存申请的大小被限制在交换空间加上物理内存一部分的大小。使用多大的物理内存是可以通过文件/proc/sys/vm/overcommit_ratio或是系统参数vm.overcommit_ratio进行调解了。缺省值为50，表示内存申请最大为交换空间加上物理内存一半的大小。由于物理内存中还包含了内核，页表，系统保留页，锁定页等等，因此其中只有一部分可以用来进行交换以满足内存的申请。需要小心的是strict accounting。在很多系统设计的理念中都排斥OOM killer，考虑到strict accounting是万能的。然而，应用常常申请很多不需要的内存以致超出了过量分配的范围，而这也是导致我们后面所讲的虚存出现的主要原因。
</p>
<div class="printfooter">
<p>取自"<a href="http://dns.cs.hit.edu.cn../../../c/h/a/Chapter8C_4f9d.html">http://dns.cs.hit.edu.cn../../../c/h/a/Chapter8C_4f9d.html</a>"</p>

<p>本页面已经被浏览274次。 This page was last modified 12:53 2009年4月6日 by <a href="../../../e/x/c/User%7EExcalibur.html" class="new" title="User:Excalibur">陈盛</a>.  </p>
</div>

</div><br style="clear:both" />

<div id='footer'><table border="0" cellspacing="0"><tr><td width='152' rowspan='1'>&nbsp;</td><td class='bottom' align='left' valign='top'><strong><a href="../../../c/h/a/Chapter8C_4f9d.html" title="Chapter8C">编辑本页</a></strong> |
<a href="../../../c/h/a/Talk%7EChapter8C_3577.html" class="new" title="Talk:Chapter8C">讨论本页</a> |
<a href="../../../c/h/a/Chapter8C_4f9d.html" title="Chapter8C">较早版本</a> |
<a href="../../../w/h/a/Special%7EWhatlinkshere.html" title="Special:Whatlinkshere">链入页面</a> |
<a href="../../../r/e/c/Special%7ERecentchangeslinked.html" title="Special:Recentchangeslinked">链出更改</a>
<br /><br />

<br /><a href="../../../index.html" title="首页">首页</a> | <a href="../../../w/i/k/Wikipedia%7E%E5%85%B3%E4%BA%8E.html" title="Wikipedia:关于">关于Wikipedia</a> | <a href="../../../r/e/c/Special%7ERecentchanges.html" title="Special:Recentchanges">最近更改</a> | <form name="search" class="inline" method="post" action="../../../s/e/a/Special%7ESearch.html">
<input type="text" name="search" size="19" value="" />
<input type="submit" name="go" value="进入" />&nbsp;<input type="submit" name="fulltext" value="搜索" />
</form><br /><span id="pagestats">本页面已经被浏览274次。 This page was last modified 12:53 2009年4月6日 by <a href="../../../e/x/c/User%7EExcalibur.html" class="new" title="User:Excalibur">陈盛</a>.  </span></td></tr></table>
</div>
</div>

<div id='quickbar'>
<a href='../../../index.html'><img src='../../../../skins/common/images/wiki.jpg' alt='[首页]' /></a>
<hr class='sep' /><a href="../../../index.html">首页</a>
<br /><a href="../../../c/o/m/WIKI-HIT_IBM_CLUB%7ECommunity_Portal_9150.html">社区</a>
<br /><a href="../../../c/u/r/Current_events.html">新闻动态</a>
<br /><a href="../../../r/e/c/Special%7ERecentchanges.html">最近更改</a>
<br /><a href="../../../r/a/n/Special%7ERandom.html">随机页面</a>
<br /><a href="../../../w/i/k/Wikipedia%7E%E5%B8%AE%E5%8A%A9.html">帮助</a>
<br /><a href="../../../s/i/t/WIKI-HIT_IBM_CLUB%7ESite_support.html">Donations</a>
<br />
<hr class='sep' /><strong><a href="../../../c/h/a/Chapter8C_4f9d.html" title="Chapter8C">编辑本页</a></strong>
<br /><a href="../../../c/h/a/Talk%7EChapter8C_3577.html" class="new" title="Talk:Chapter8C">讨论本页</a>
<br /><a href="../../../c/h/a/Chapter8C_4f9d.html" title="Chapter8C">较早版本</a>
<br /><a href="../../../w/h/a/Special%7EWhatlinkshere.html" title="Special:Whatlinkshere">链入页面</a>
<br /><a href="../../../r/e/c/Special%7ERecentchangeslinked.html" title="Special:Recentchangeslinked">链出更改</a>
<br /><hr class='sep' /><a href="../../../s/p/e/Special%7ESpecialpages.html" title="Special:Specialpages">特殊页面</a>
<br /><a href="../../../w/i/k/Wikipedia%7E%E9%94%99%E8%AF%AF%E6%8A%A5%E5%91%8A.html" title="Wikipedia:错误报告">错误报告</a>
<br /></div>
<!-- Served by dns.cs.hit.edu.cn in 1351393318.59 secs. -->
</body></html>